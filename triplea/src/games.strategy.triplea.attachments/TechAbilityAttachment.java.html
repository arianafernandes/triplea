<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>TechAbilityAttachment.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">test (25/nov/2016 10:16:58)</a> &gt; <a href="../../index.html" class="el_group">triplea</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">games.strategy.triplea.attachments</a> &gt; <span class="el_source">TechAbilityAttachment.java</span></div><h1>TechAbilityAttachment.java</h1><pre class="source lang-java linenums">package games.strategy.triplea.attachments;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;

import games.strategy.engine.data.Attachable;
import games.strategy.engine.data.DefaultAttachment;
import games.strategy.engine.data.GameData;
import games.strategy.engine.data.GameParseException;
import games.strategy.engine.data.PlayerID;
import games.strategy.engine.data.Unit;
import games.strategy.engine.data.UnitType;
import games.strategy.engine.data.annotations.GameProperty;
import games.strategy.engine.data.annotations.InternalDoNotExport;
import games.strategy.triplea.Constants;
import games.strategy.triplea.MapSupport;
import games.strategy.triplea.TripleAUnit;
import games.strategy.triplea.delegate.GenericTechAdvance;
import games.strategy.triplea.delegate.Matches;
import games.strategy.triplea.delegate.TechAdvance;
import games.strategy.triplea.delegate.TechTracker;
import games.strategy.util.CompositeMatchAnd;
import games.strategy.util.IntegerMap;
import games.strategy.util.Match;

/**
 * Attaches to technologies.
 * Also contains static methods of interpreting data from all technology attachments that a player has.
 */
@MapSupport
public class TechAbilityAttachment extends DefaultAttachment {
  private static final long serialVersionUID = 1866305599625384294L;

  /**
   * Convenience method.
   */
  public static TechAbilityAttachment get(final TechAdvance type) {
<span class="pc bpc" id="L42" title="1 of 2 branches missed.">    if (type instanceof GenericTechAdvance) {</span>
      // generic techs can name a hardcoded tech, therefore if it exists we should use the hard coded tech's attachment.
      // (if the map maker doesn't want to use the hardcoded tech's attachment, they should not name a hardcoded tech)
<span class="nc" id="L45">      final TechAdvance hardCodedAdvance = ((GenericTechAdvance) type).getAdvance();</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">      if (hardCodedAdvance != null) {</span>
<span class="nc" id="L47">        final TechAbilityAttachment hardCodedTechAttachment =</span>
<span class="nc" id="L48">            (TechAbilityAttachment) hardCodedAdvance.getAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME);</span>
<span class="nc" id="L49">        return hardCodedTechAttachment;</span>
      }
    }
<span class="fc" id="L52">    final TechAbilityAttachment rVal =</span>
<span class="fc" id="L53">        (TechAbilityAttachment) type.getAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME);</span>
<span class="fc" id="L54">    return rVal;</span>
  }

  /**
   * Convenience method.
   */
  public static TechAbilityAttachment get(final TechAdvance type, final String nameOfAttachment) {
<span class="nc" id="L61">    final TechAbilityAttachment rVal = (TechAbilityAttachment) type.getAttachment(nameOfAttachment);</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">    if (rVal == null) {</span>
<span class="nc" id="L63">      throw new IllegalStateException(</span>
<span class="nc" id="L64">          &quot;No technology attachment for:&quot; + type.getName() + &quot; with name:&quot; + nameOfAttachment);</span>
    }
<span class="nc" id="L66">    return rVal;</span>
  }

  // unitAbilitiesGained Static Strings
  public static final String ABILITY_CAN_BLITZ = &quot;canBlitz&quot;;
  public static final String ABILITY_CAN_BOMBARD = &quot;canBombard&quot;;
  // attachment fields
<span class="fc" id="L73">  private IntegerMap&lt;UnitType&gt; m_attackBonus = new IntegerMap&lt;&gt;();</span>
<span class="fc" id="L74">  private IntegerMap&lt;UnitType&gt; m_defenseBonus = new IntegerMap&lt;&gt;();</span>
<span class="fc" id="L75">  private IntegerMap&lt;UnitType&gt; m_movementBonus = new IntegerMap&lt;&gt;();</span>
<span class="fc" id="L76">  private IntegerMap&lt;UnitType&gt; m_radarBonus = new IntegerMap&lt;&gt;();</span>
<span class="fc" id="L77">  private IntegerMap&lt;UnitType&gt; m_airAttackBonus = new IntegerMap&lt;&gt;();</span>
<span class="fc" id="L78">  private IntegerMap&lt;UnitType&gt; m_airDefenseBonus = new IntegerMap&lt;&gt;();</span>
<span class="fc" id="L79">  private IntegerMap&lt;UnitType&gt; m_productionBonus = new IntegerMap&lt;&gt;();</span>
  // -1 means not set
<span class="fc" id="L81">  private int m_minimumTerritoryValueForProductionBonus = -1;</span>
  // -1 means not set
<span class="fc" id="L83">  private int m_repairDiscount = -1;</span>
  // -1 means not set
<span class="fc" id="L85">  private int m_warBondDiceSides = -1;</span>
<span class="fc" id="L86">  private int m_warBondDiceNumber = 0;</span>
  // -1 means not set // not needed because this is controlled in the unit attachment with
  // private int m_rocketDiceSides = -1;
  // bombingBonus and bombingMaxDieSides
<span class="fc" id="L90">  private IntegerMap&lt;UnitType&gt; m_rocketDiceNumber = new IntegerMap&lt;&gt;();</span>
<span class="fc" id="L91">  private int m_rocketDistance = 0;</span>
<span class="fc" id="L92">  private int m_rocketNumberPerTerritory = 0;</span>
<span class="fc" id="L93">  private HashMap&lt;UnitType, HashSet&lt;String&gt;&gt; m_unitAbilitiesGained = new HashMap&lt;&gt;();</span>
<span class="fc" id="L94">  private boolean m_airborneForces = false;</span>
<span class="fc" id="L95">  private IntegerMap&lt;UnitType&gt; m_airborneCapacity = new IntegerMap&lt;&gt;();</span>
<span class="fc" id="L96">  private HashSet&lt;UnitType&gt; m_airborneTypes = new HashSet&lt;&gt;();</span>
<span class="fc" id="L97">  private int m_airborneDistance = 0;</span>
<span class="fc" id="L98">  private HashSet&lt;UnitType&gt; m_airborneBases = new HashSet&lt;&gt;();</span>
<span class="fc" id="L99">  private HashMap&lt;String, HashSet&lt;UnitType&gt;&gt; m_airborneTargettedByAA = new HashMap&lt;&gt;();</span>
<span class="fc" id="L100">  private IntegerMap&lt;UnitType&gt; m_attackRollsBonus = new IntegerMap&lt;&gt;();</span>
<span class="fc" id="L101">  private IntegerMap&lt;UnitType&gt; m_defenseRollsBonus = new IntegerMap&lt;&gt;();</span>
<span class="fc" id="L102">  private IntegerMap&lt;UnitType&gt; m_bombingBonus = new IntegerMap&lt;&gt;();</span>

  public TechAbilityAttachment(final String name, final Attachable attachable, final GameData gameData) {
<span class="fc" id="L105">    super(name, attachable, gameData);</span>
<span class="fc" id="L106">  }</span>

  // setters and getters
  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setAttackBonus(final String value) throws GameParseException {
<span class="fc" id="L114">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L115" title="2 of 4 branches missed.">    if (s.length &lt;= 0 || s.length &gt; 2) {</span>
<span class="nc" id="L116">      throw new GameParseException(&quot;attackBonus cannot be empty or have more than two fields&quot; + thisErrorMsg());</span>
    }
    String unitType;
<span class="fc" id="L119">    unitType = s[1];</span>
    // validate that this unit exists in the xml
<span class="fc" id="L121">    final UnitType ut = getData().getUnitTypeList().getUnitType(unitType);</span>
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L123">      throw new GameParseException(&quot;No unit called:&quot; + unitType + thisErrorMsg());</span>
    }
    // we should allow positive and negative numbers
<span class="fc" id="L126">    final int n = getInt(s[0]);</span>
<span class="fc" id="L127">    m_attackBonus.put(ut, n);</span>
<span class="fc" id="L128">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAttackBonus(final IntegerMap&lt;UnitType&gt; value) {
<span class="nc" id="L132">    m_attackBonus = value;</span>
<span class="nc" id="L133">  }</span>

  public IntegerMap&lt;UnitType&gt; getAttackBonus() {
<span class="fc" id="L136">    return m_attackBonus;</span>
  }

  public void clearAttackBonus() {
<span class="nc" id="L140">    m_attackBonus.clear();</span>
<span class="nc" id="L141">  }</span>

  public void resetAttackBonus() {
<span class="nc" id="L144">    m_attackBonus = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L145">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setDefenseBonus(final String value) throws GameParseException {
<span class="fc" id="L152">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L153" title="2 of 4 branches missed.">    if (s.length &lt;= 0 || s.length &gt; 2) {</span>
<span class="nc" id="L154">      throw new GameParseException(&quot;defenseBonus cannot be empty or have more than two fields&quot; + thisErrorMsg());</span>
    }
    String unitType;
<span class="fc" id="L157">    unitType = s[1];</span>
    // validate that this unit exists in the xml
<span class="fc" id="L159">    final UnitType ut = getData().getUnitTypeList().getUnitType(unitType);</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L161">      throw new GameParseException(&quot;No unit called:&quot; + unitType + thisErrorMsg());</span>
    }
    // we should allow positive and negative numbers
<span class="fc" id="L164">    final int n = getInt(s[0]);</span>
<span class="fc" id="L165">    m_defenseBonus.put(ut, n);</span>
<span class="fc" id="L166">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setDefenseBonus(final IntegerMap&lt;UnitType&gt; value) {
<span class="nc" id="L170">    m_defenseBonus = value;</span>
<span class="nc" id="L171">  }</span>

  public IntegerMap&lt;UnitType&gt; getDefenseBonus() {
<span class="fc" id="L174">    return m_defenseBonus;</span>
  }

  public void clearDefenseBonus() {
<span class="nc" id="L178">    m_defenseBonus.clear();</span>
<span class="nc" id="L179">  }</span>

  public void resetDefenseBonus() {
<span class="nc" id="L182">    m_defenseBonus = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L183">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setMovementBonus(final String value) throws GameParseException {
<span class="fc" id="L190">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L191" title="2 of 4 branches missed.">    if (s.length &lt;= 0 || s.length &gt; 2) {</span>
<span class="nc" id="L192">      throw new GameParseException(&quot;movementBonus cannot be empty or have more than two fields&quot; + thisErrorMsg());</span>
    }
    String unitType;
<span class="fc" id="L195">    unitType = s[1];</span>
    // validate that this unit exists in the xml
<span class="fc" id="L197">    final UnitType ut = getData().getUnitTypeList().getUnitType(unitType);</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L199">      throw new GameParseException(&quot;No unit called:&quot; + unitType + thisErrorMsg());</span>
    }
    // we should allow positive and negative numbers
<span class="fc" id="L202">    final int n = getInt(s[0]);</span>
<span class="fc" id="L203">    m_movementBonus.put(ut, n);</span>
<span class="fc" id="L204">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMovementBonus(final IntegerMap&lt;UnitType&gt; value) {
<span class="nc" id="L208">    m_movementBonus = value;</span>
<span class="nc" id="L209">  }</span>

  public IntegerMap&lt;UnitType&gt; getMovementBonus() {
<span class="fc" id="L212">    return m_movementBonus;</span>
  }

  public void clearMovementBonus() {
<span class="nc" id="L216">    m_movementBonus.clear();</span>
<span class="nc" id="L217">  }</span>

  public void resetMovementBonus() {
<span class="nc" id="L220">    m_movementBonus = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L221">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setRadarBonus(final String value) throws GameParseException {
<span class="fc" id="L228">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L229" title="2 of 4 branches missed.">    if (s.length &lt;= 0 || s.length &gt; 2) {</span>
<span class="nc" id="L230">      throw new GameParseException(&quot;radarBonus cannot be empty or have more than two fields&quot; + thisErrorMsg());</span>
    }
    String unitType;
<span class="fc" id="L233">    unitType = s[1];</span>
    // validate that this unit exists in the xml
<span class="fc" id="L235">    final UnitType ut = getData().getUnitTypeList().getUnitType(unitType);</span>
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L237">      throw new GameParseException(&quot;No unit called:&quot; + unitType + thisErrorMsg());</span>
    }
    // we should allow positive and negative numbers
<span class="fc" id="L240">    final int n = getInt(s[0]);</span>
<span class="fc" id="L241">    m_radarBonus.put(ut, n);</span>
<span class="fc" id="L242">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setRadarBonus(final IntegerMap&lt;UnitType&gt; value) {
<span class="nc" id="L246">    m_radarBonus = value;</span>
<span class="nc" id="L247">  }</span>

  public IntegerMap&lt;UnitType&gt; getRadarBonus() {
<span class="fc" id="L250">    return m_radarBonus;</span>
  }

  public void clearRadarBonus() {
<span class="nc" id="L254">    m_radarBonus.clear();</span>
<span class="nc" id="L255">  }</span>

  public void resetRadarBonus() {
<span class="nc" id="L258">    m_radarBonus = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L259">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setAirAttackBonus(final String value) throws GameParseException {
<span class="fc" id="L266">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L267" title="2 of 4 branches missed.">    if (s.length &lt;= 0 || s.length &gt; 2) {</span>
<span class="nc" id="L268">      throw new GameParseException(&quot;airAttackBonus cannot be empty or have more than two fields&quot; + thisErrorMsg());</span>
    }
    String unitType;
<span class="fc" id="L271">    unitType = s[1];</span>
    // validate that this unit exists in the xml
<span class="fc" id="L273">    final UnitType ut = getData().getUnitTypeList().getUnitType(unitType);</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L275">      throw new GameParseException(&quot;No unit called:&quot; + unitType + thisErrorMsg());</span>
    }
    // we should allow positive and negative numbers
<span class="fc" id="L278">    final int n = getInt(s[0]);</span>
<span class="fc" id="L279">    m_airAttackBonus.put(ut, n);</span>
<span class="fc" id="L280">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAirAttackBonus(final IntegerMap&lt;UnitType&gt; value) {
<span class="nc" id="L284">    m_airAttackBonus = value;</span>
<span class="nc" id="L285">  }</span>

  public IntegerMap&lt;UnitType&gt; getAirAttackBonus() {
<span class="nc" id="L288">    return m_airAttackBonus;</span>
  }

  public void clearAirAttackBonus() {
<span class="nc" id="L292">    m_airAttackBonus.clear();</span>
<span class="nc" id="L293">  }</span>

  public void resetAirAttackBonus() {
<span class="nc" id="L296">    m_airAttackBonus = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L297">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setAirDefenseBonus(final String value) throws GameParseException {
<span class="fc" id="L304">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L305" title="2 of 4 branches missed.">    if (s.length &lt;= 0 || s.length &gt; 2) {</span>
<span class="nc" id="L306">      throw new GameParseException(&quot;airDefenseBonus cannot be empty or have more than two fields&quot; + thisErrorMsg());</span>
    }
    String unitType;
<span class="fc" id="L309">    unitType = s[1];</span>
    // validate that this unit exists in the xml
<span class="fc" id="L311">    final UnitType ut = getData().getUnitTypeList().getUnitType(unitType);</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L313">      throw new GameParseException(&quot;No unit called:&quot; + unitType + thisErrorMsg());</span>
    }
    // we should allow positive and negative numbers
<span class="fc" id="L316">    final int n = getInt(s[0]);</span>
<span class="fc" id="L317">    m_airDefenseBonus.put(ut, n);</span>
<span class="fc" id="L318">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAirDefenseBonus(final IntegerMap&lt;UnitType&gt; value) {
<span class="nc" id="L322">    m_airDefenseBonus = value;</span>
<span class="nc" id="L323">  }</span>

  public IntegerMap&lt;UnitType&gt; getAirDefenseBonus() {
<span class="nc" id="L326">    return m_airDefenseBonus;</span>
  }

  public void clearAirDefenseBonus() {
<span class="nc" id="L330">    m_airDefenseBonus.clear();</span>
<span class="nc" id="L331">  }</span>

  public void resetAirDefenseBonus() {
<span class="nc" id="L334">    m_airDefenseBonus = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L335">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setProductionBonus(final String value) throws GameParseException {
<span class="fc" id="L342">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L343" title="2 of 4 branches missed.">    if (s.length &lt;= 0 || s.length &gt; 2) {</span>
<span class="nc" id="L344">      throw new GameParseException(&quot;productionBonus cannot be empty or have more than two fields&quot; + thisErrorMsg());</span>
    }
    String unitType;
<span class="fc" id="L347">    unitType = s[1];</span>
    // validate that this unit exists in the xml
<span class="fc" id="L349">    final UnitType ut = getData().getUnitTypeList().getUnitType(unitType);</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L351">      throw new GameParseException(&quot;No unit called:&quot; + unitType + thisErrorMsg());</span>
    }
    // we should allow positive and negative numbers
<span class="fc" id="L354">    final int n = getInt(s[0]);</span>
<span class="fc" id="L355">    m_productionBonus.put(ut, n);</span>
<span class="fc" id="L356">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setProductionBonus(final IntegerMap&lt;UnitType&gt; value) {
<span class="nc" id="L360">    m_productionBonus = value;</span>
<span class="nc" id="L361">  }</span>

  public IntegerMap&lt;UnitType&gt; getProductionBonus() {
<span class="nc" id="L364">    return m_productionBonus;</span>
  }

  public void clearProductionBonus() {
<span class="nc" id="L368">    m_productionBonus.clear();</span>
<span class="nc" id="L369">  }</span>

  public void resetProductionBonus() {
<span class="nc" id="L372">    m_productionBonus = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L373">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMinimumTerritoryValueForProductionBonus(final String value) throws GameParseException {
<span class="fc" id="L377">    final int v = getInt(value);</span>
<span class="pc bpc" id="L378" title="3 of 6 branches missed.">    if ((v != -1) &amp;&amp; (v &lt; 0 || v &gt; 10000)) {</span>
<span class="nc" id="L379">      throw new GameParseException(</span>
<span class="nc" id="L380">          &quot;minimumTerritoryValueForProductionBonus must be -1 (no effect), or be between 0 and 10000&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L382">    m_minimumTerritoryValueForProductionBonus = v;</span>
<span class="fc" id="L383">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMinimumTerritoryValueForProductionBonus(final Integer value) {
<span class="fc" id="L387">    m_minimumTerritoryValueForProductionBonus = value;</span>
<span class="fc" id="L388">  }</span>

  public int getMinimumTerritoryValueForProductionBonus() {
<span class="fc" id="L391">    return m_minimumTerritoryValueForProductionBonus;</span>
  }

  public void resetMinimumTerritoryValueForProductionBonus() {
<span class="nc" id="L395">    m_minimumTerritoryValueForProductionBonus = -1;</span>
<span class="nc" id="L396">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setRepairDiscount(final String value) throws GameParseException {
<span class="fc" id="L400">    final int v = getInt(value);</span>
<span class="pc bpc" id="L401" title="3 of 6 branches missed.">    if ((v != -1) &amp;&amp; (v &lt; 0 || v &gt; 100)) {</span>
<span class="nc" id="L402">      throw new GameParseException(&quot;m_repairDiscount must be -1 (no effect), or be between 0 and 100&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L404">    m_repairDiscount = v;</span>
<span class="fc" id="L405">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setRepairDiscount(final Integer value) {
<span class="fc" id="L409">    m_repairDiscount = value;</span>
<span class="fc" id="L410">  }</span>

  public int getRepairDiscount() {
<span class="fc" id="L413">    return m_repairDiscount;</span>
  }

  public void resetRepairDiscount() {
<span class="nc" id="L417">    m_repairDiscount = -1;</span>
<span class="nc" id="L418">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setWarBondDiceSides(final String value) throws GameParseException {
<span class="fc" id="L422">    final int v = getInt(value);</span>
<span class="pc bpc" id="L423" title="3 of 6 branches missed.">    if ((v != -1) &amp;&amp; (v &lt; 0 || v &gt; 200)) {</span>
<span class="nc" id="L424">      throw new GameParseException(&quot;warBondDiceSides must be -1 (no effect), or be between 0 and 200&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L426">    m_warBondDiceSides = v;</span>
<span class="fc" id="L427">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setWarBondDiceSides(final Integer value) {
<span class="fc" id="L431">    m_warBondDiceSides = value;</span>
<span class="fc" id="L432">  }</span>

  public int getWarBondDiceSides() {
<span class="fc" id="L435">    return m_warBondDiceSides;</span>
  }

  public void resetWarBondDiceSides() {
<span class="nc" id="L439">    m_warBondDiceSides = -1;</span>
<span class="nc" id="L440">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setWarBondDiceNumber(final String value) throws GameParseException {
<span class="fc" id="L444">    final int v = getInt(value);</span>
<span class="pc bpc" id="L445" title="2 of 4 branches missed.">    if (v &lt; 0 || v &gt; 100) {</span>
<span class="nc" id="L446">      throw new GameParseException(&quot;warBondDiceNumber must be between 0 and 100&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L448">    m_warBondDiceNumber = v;</span>
<span class="fc" id="L449">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setWarBondDiceNumber(final Integer value) {
<span class="fc" id="L453">    m_warBondDiceNumber = value;</span>
<span class="fc" id="L454">  }</span>

  public int getWarBondDiceNumber() {
<span class="fc" id="L457">    return m_warBondDiceNumber;</span>
  }

  public void resetWarBondDiceNumber() {
<span class="nc" id="L461">    m_warBondDiceNumber = 0;</span>
<span class="nc" id="L462">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setRocketDiceNumber(final String value) throws GameParseException {
<span class="fc" id="L469">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">    if (s.length != 2) {</span>
<span class="nc" id="L471">      throw new GameParseException(&quot;rocketDiceNumber must have two fields&quot; + thisErrorMsg());</span>
    }
    String unitType;
<span class="fc" id="L474">    unitType = s[1];</span>
    // validate that this unit exists in the xml
<span class="fc" id="L476">    final UnitType ut = getData().getUnitTypeList().getUnitType(unitType);</span>
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L478">      throw new GameParseException(&quot;No unit called:&quot; + unitType + thisErrorMsg());</span>
    }
    // we should allow positive and negative numbers
<span class="fc" id="L481">    final int n = getInt(s[0]);</span>
<span class="fc" id="L482">    m_rocketDiceNumber.put(ut, n);</span>
<span class="fc" id="L483">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setRocketDiceNumber(final IntegerMap&lt;UnitType&gt; value) {
<span class="nc" id="L487">    m_rocketDiceNumber = value;</span>
<span class="nc" id="L488">  }</span>

  public IntegerMap&lt;UnitType&gt; getRocketDiceNumber() {
<span class="nc" id="L491">    return m_rocketDiceNumber;</span>
  }

  public void clearRocketDiceNumber() {
<span class="nc" id="L495">    m_rocketDiceNumber.clear();</span>
<span class="nc" id="L496">  }</span>

  public void resetRocketDiceNumber() {
<span class="nc" id="L499">    m_rocketDiceNumber = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L500">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setRocketDistance(final String value) throws GameParseException {
<span class="fc" id="L504">    final int v = getInt(value);</span>
<span class="pc bpc" id="L505" title="2 of 4 branches missed.">    if (v &lt; 0 || v &gt; 100) {</span>
<span class="nc" id="L506">      throw new GameParseException(&quot;rocketDistance must be between 0 and 100&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L508">    m_rocketDistance = v;</span>
<span class="fc" id="L509">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setRocketDistance(final Integer value) {
<span class="fc" id="L513">    m_rocketDistance = value;</span>
<span class="fc" id="L514">  }</span>

  public int getRocketDistance() {
<span class="fc" id="L517">    return m_rocketDistance;</span>
  }

  public void resetRocketDistance() {
<span class="nc" id="L521">    m_rocketDistance = 0;</span>
<span class="nc" id="L522">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setRocketNumberPerTerritory(final String value) throws GameParseException {
<span class="fc" id="L526">    final int v = getInt(value);</span>
<span class="pc bpc" id="L527" title="2 of 4 branches missed.">    if (v &lt; 0 || v &gt; 200) {</span>
<span class="nc" id="L528">      throw new GameParseException(&quot;rocketNumberPerTerritory must be between 0 and 200&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L530">    m_rocketNumberPerTerritory = v;</span>
<span class="fc" id="L531">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setRocketNumberPerTerritory(final int value) {
<span class="fc" id="L535">    m_rocketNumberPerTerritory = value;</span>
<span class="fc" id="L536">  }</span>

  public int getRocketNumberPerTerritory() {
<span class="fc" id="L539">    return m_rocketNumberPerTerritory;</span>
  }

  public void resetRocketNumberPerTerritory() {
<span class="nc" id="L543">    m_rocketNumberPerTerritory = 0;</span>
<span class="nc" id="L544">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setUnitAbilitiesGained(final String value) throws GameParseException {
<span class="fc" id="L551">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">    if (s.length &lt; 2) {</span>
<span class="nc" id="L553">      throw new GameParseException(</span>
<span class="nc" id="L554">          &quot;unitAbilitiesGained must list the unit type, then all abilities gained&quot; + thisErrorMsg());</span>
    }
    String unitType;
<span class="fc" id="L557">    unitType = s[0];</span>
    // validate that this unit exists in the xml
<span class="fc" id="L559">    final UnitType ut = getData().getUnitTypeList().getUnitType(unitType);</span>
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L561">      throw new GameParseException(&quot;No unit called:&quot; + unitType + thisErrorMsg());</span>
    }
<span class="fc" id="L563">    HashSet&lt;String&gt; abilities = m_unitAbilitiesGained.get(ut);</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">    if (abilities == null) {</span>
<span class="fc" id="L565">      abilities = new HashSet&lt;&gt;();</span>
    }
    // start at 1
<span class="fc bfc" id="L568" title="All 2 branches covered.">    for (int i = 1; i &lt; s.length; i++) {</span>
<span class="fc" id="L569">      final String ability = s[i];</span>
<span class="pc bpc" id="L570" title="1 of 4 branches missed.">      if (!(ability.equals(ABILITY_CAN_BLITZ) || ability.equals(ABILITY_CAN_BOMBARD))) {</span>
<span class="nc" id="L571">        throw new GameParseException(&quot;unitAbilitiesGained so far only supports: &quot; + ABILITY_CAN_BLITZ + &quot; and &quot;</span>
<span class="nc" id="L572">            + ABILITY_CAN_BOMBARD + thisErrorMsg());</span>
      }
<span class="fc" id="L574">      abilities.add(ability);</span>
    }
<span class="fc" id="L576">    m_unitAbilitiesGained.put(ut, abilities);</span>
<span class="fc" id="L577">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setUnitAbilitiesGained(final HashMap&lt;UnitType, HashSet&lt;String&gt;&gt; value) {
<span class="nc" id="L581">    m_unitAbilitiesGained = value;</span>
<span class="nc" id="L582">  }</span>

  public HashMap&lt;UnitType, HashSet&lt;String&gt;&gt; getUnitAbilitiesGained() {
<span class="nc" id="L585">    return m_unitAbilitiesGained;</span>
  }

  public void clearUnitAbilitiesGained() {
<span class="nc" id="L589">    m_unitAbilitiesGained.clear();</span>
<span class="nc" id="L590">  }</span>

  public void resetUnitAbilitiesGained() {
<span class="nc" id="L593">    m_unitAbilitiesGained = new HashMap&lt;&gt;();</span>
<span class="nc" id="L594">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAirborneForces(final String value) throws GameParseException {
<span class="fc" id="L598">    m_airborneForces = getBool(value);</span>
<span class="fc" id="L599">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAirborneForces(final Boolean value) {
<span class="fc" id="L603">    m_airborneForces = value;</span>
<span class="fc" id="L604">  }</span>

  public boolean getAirborneForces() {
<span class="fc" id="L607">    return m_airborneForces;</span>
  }

  public void resetAirborneForces() {
<span class="nc" id="L611">    m_airborneForces = false;</span>
<span class="nc" id="L612">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setAirborneCapacity(final String value) throws GameParseException {
<span class="fc" id="L619">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L620" title="2 of 4 branches missed.">    if (s.length &lt;= 0 || s.length &gt; 2) {</span>
<span class="nc" id="L621">      throw new GameParseException(&quot;airborneCapacity cannot be empty or have more than two fields&quot; + thisErrorMsg());</span>
    }
    String unitType;
<span class="fc" id="L624">    unitType = s[1];</span>
    // validate that this unit exists in the xml
<span class="fc" id="L626">    final UnitType ut = getData().getUnitTypeList().getUnitType(unitType);</span>
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L628">      throw new GameParseException(&quot;No unit called:&quot; + unitType + thisErrorMsg());</span>
    }
    // we should allow positive and negative numbers
<span class="fc" id="L631">    final int n = getInt(s[0]);</span>
<span class="fc" id="L632">    m_airborneCapacity.put(ut, n);</span>
<span class="fc" id="L633">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAirborneCapacity(final IntegerMap&lt;UnitType&gt; value) {
<span class="nc" id="L637">    m_airborneCapacity = value;</span>
<span class="nc" id="L638">  }</span>

  public IntegerMap&lt;UnitType&gt; getAirborneCapacity() {
<span class="nc" id="L641">    return m_airborneCapacity;</span>
  }

  public void clearAirborneCapacity() {
<span class="nc" id="L645">    m_airborneCapacity.clear();</span>
<span class="nc" id="L646">  }</span>

  public void resetAirborneCapacity() {
<span class="nc" id="L649">    m_airborneCapacity = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L650">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setAirborneTypes(final String value) throws GameParseException {
<span class="fc" id="L657">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">    for (final String u : s) {</span>
<span class="fc" id="L659">      final UnitType ut = getData().getUnitTypeList().getUnitType(u);</span>
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">      if (ut == null) {</span>
<span class="nc" id="L661">        throw new GameParseException(&quot;airborneTypes: no such unit type: &quot; + u + thisErrorMsg());</span>
      }
<span class="fc" id="L663">      m_airborneTypes.add(ut);</span>
    }
<span class="fc" id="L665">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAirborneTypes(final HashSet&lt;UnitType&gt; value) {
<span class="nc" id="L669">    m_airborneTypes = value;</span>
<span class="nc" id="L670">  }</span>

  public HashSet&lt;UnitType&gt; getAirborneTypes() {
<span class="nc" id="L673">    return m_airborneTypes;</span>
  }

  public void clearAirborneTypes() {
<span class="nc" id="L677">    m_airborneTypes.clear();</span>
<span class="nc" id="L678">  }</span>

  public void resetAirborneTypes() {
<span class="nc" id="L681">    m_airborneTypes = new HashSet&lt;&gt;();</span>
<span class="nc" id="L682">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAirborneDistance(final String value) throws GameParseException {
<span class="fc" id="L686">    final int v = getInt(value);</span>
<span class="pc bpc" id="L687" title="2 of 4 branches missed.">    if (v &lt; 0 || v &gt; 100) {</span>
<span class="nc" id="L688">      throw new GameParseException(&quot;airborneDistance must be between 0 and 100&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L690">    m_airborneDistance = v;</span>
<span class="fc" id="L691">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAirborneDistance(final Integer value) {
<span class="fc" id="L695">    m_airborneDistance = value;</span>
<span class="fc" id="L696">  }</span>

  public int getAirborneDistance() {
<span class="fc" id="L699">    return m_airborneDistance;</span>
  }

  public void resetAirborneDistance() {
<span class="nc" id="L703">    m_airborneDistance = 0;</span>
<span class="nc" id="L704">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setAirborneBases(final String value) throws GameParseException {
<span class="fc" id="L711">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">    for (final String u : s) {</span>
<span class="fc" id="L713">      final UnitType ut = getData().getUnitTypeList().getUnitType(u);</span>
<span class="pc bpc" id="L714" title="1 of 2 branches missed.">      if (ut == null) {</span>
<span class="nc" id="L715">        throw new GameParseException(&quot;airborneBases: no such unit type: &quot; + u + thisErrorMsg());</span>
      }
<span class="fc" id="L717">      m_airborneBases.add(ut);</span>
    }
<span class="fc" id="L719">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAirborneBases(final HashSet&lt;UnitType&gt; value) {
<span class="nc" id="L723">    m_airborneBases = value;</span>
<span class="nc" id="L724">  }</span>

  public HashSet&lt;UnitType&gt; getAirborneBases() {
<span class="nc" id="L727">    return m_airborneBases;</span>
  }

  public void clearAirborneBases() {
<span class="nc" id="L731">    m_airborneBases.clear();</span>
<span class="nc" id="L732">  }</span>

  public void resetAirborneBases() {
<span class="nc" id="L735">    m_airborneBases = new HashSet&lt;&gt;();</span>
<span class="nc" id="L736">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setAirborneTargettedByAA(final String value) throws GameParseException {
<span class="fc" id="L743">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">    if (s.length &lt; 2) {</span>
<span class="nc" id="L745">      throw new GameParseException(&quot;airborneTargettedByAA must have at least two fields&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L747">    final String aaType = s[0];</span>
<span class="fc" id="L748">    final HashSet&lt;UnitType&gt; unitTypes = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">    for (int i = 1; i &lt; s.length; i++) {</span>
<span class="fc" id="L750">      final UnitType ut = getData().getUnitTypeList().getUnitType(s[i]);</span>
<span class="pc bpc" id="L751" title="1 of 2 branches missed.">      if (ut == null) {</span>
<span class="nc" id="L752">        throw new GameParseException(&quot;airborneTargettedByAA: no such unit type: &quot; + s[i] + thisErrorMsg());</span>
      }
<span class="fc" id="L754">      unitTypes.add(ut);</span>
    }
<span class="fc" id="L756">    m_airborneTargettedByAA.put(aaType, unitTypes);</span>
<span class="fc" id="L757">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAirborneTargettedByAA(final HashMap&lt;String, HashSet&lt;UnitType&gt;&gt; value) {
<span class="nc" id="L761">    m_airborneTargettedByAA = value;</span>
<span class="nc" id="L762">  }</span>

  public HashMap&lt;String, HashSet&lt;UnitType&gt;&gt; getAirborneTargettedByAA() {
<span class="fc" id="L765">    return m_airborneTargettedByAA;</span>
  }

  public void clearAirborneTargettedByAA() {
<span class="nc" id="L769">    m_airborneTargettedByAA.clear();</span>
<span class="nc" id="L770">  }</span>

  public void resetAirborneTargettedByAA() {
<span class="nc" id="L773">    m_airborneTargettedByAA = new HashMap&lt;&gt;();</span>
<span class="nc" id="L774">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setAttackRollsBonus(final String value) throws GameParseException {
<span class="fc" id="L781">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L782" title="2 of 4 branches missed.">    if (s.length &lt;= 0 || s.length &gt; 2) {</span>
<span class="nc" id="L783">      throw new GameParseException(&quot;attackRollsBonus cannot be empty or have more than two fields&quot; + thisErrorMsg());</span>
    }
    String unitType;
<span class="fc" id="L786">    unitType = s[1];</span>
    // validate that this unit exists in the xml
<span class="fc" id="L788">    final UnitType ut = getData().getUnitTypeList().getUnitType(unitType);</span>
<span class="pc bpc" id="L789" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L790">      throw new GameParseException(&quot;No unit called:&quot; + unitType + thisErrorMsg());</span>
    }
    // we should allow positive and negative numbers
<span class="fc" id="L793">    final int n = getInt(s[0]);</span>
<span class="fc" id="L794">    m_attackRollsBonus.put(ut, n);</span>
<span class="fc" id="L795">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAttackRollsBonus(final IntegerMap&lt;UnitType&gt; value) {
<span class="nc" id="L799">    m_attackRollsBonus = value;</span>
<span class="nc" id="L800">  }</span>

  public IntegerMap&lt;UnitType&gt; getAttackRollsBonus() {
<span class="fc" id="L803">    return m_attackRollsBonus;</span>
  }

  public void clearAttackRollsBonus() {
<span class="nc" id="L807">    m_attackRollsBonus.clear();</span>
<span class="nc" id="L808">  }</span>

  public void resetAttackRollsBonus() {
<span class="nc" id="L811">    m_attackRollsBonus = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L812">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setDefenseRollsBonus(final String value) throws GameParseException {
<span class="fc" id="L819">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L820" title="2 of 4 branches missed.">    if (s.length &lt;= 0 || s.length &gt; 2) {</span>
<span class="nc" id="L821">      throw new GameParseException(&quot;defenseRollsBonus cannot be empty or have more than two fields&quot; + thisErrorMsg());</span>
    }
    String unitType;
<span class="fc" id="L824">    unitType = s[1];</span>
    // validate that this unit exists in the xml
<span class="fc" id="L826">    final UnitType ut = getData().getUnitTypeList().getUnitType(unitType);</span>
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L828">      throw new GameParseException(&quot;No unit called:&quot; + unitType + thisErrorMsg());</span>
    }
    // we should allow positive and negative numbers
<span class="fc" id="L831">    final int n = getInt(s[0]);</span>
<span class="fc" id="L832">    m_defenseRollsBonus.put(ut, n);</span>
<span class="fc" id="L833">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setDefenseRollsBonus(final IntegerMap&lt;UnitType&gt; value) {
<span class="nc" id="L837">    m_defenseRollsBonus = value;</span>
<span class="nc" id="L838">  }</span>

  public IntegerMap&lt;UnitType&gt; getDefenseRollsBonus() {
<span class="fc" id="L841">    return m_defenseRollsBonus;</span>
  }

  public void clearDefenseRollsBonus() {
<span class="nc" id="L845">    m_defenseRollsBonus.clear();</span>
<span class="nc" id="L846">  }</span>

  public void resetDefenseRollsBonus() {
<span class="nc" id="L849">    m_defenseRollsBonus = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L850">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setBombingBonus(final String value) throws GameParseException {
<span class="fc" id="L857">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L858" title="2 of 4 branches missed.">    if (s.length &lt;= 0 || s.length &gt; 2) {</span>
<span class="nc" id="L859">      throw new GameParseException(&quot;bombingBonus cannot be empty or have more than two fields&quot; + thisErrorMsg());</span>
    }
    String unitType;
<span class="fc" id="L862">    unitType = s[1];</span>
    // validate that this unit exists in the xml
<span class="fc" id="L864">    final UnitType ut = getData().getUnitTypeList().getUnitType(unitType);</span>
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L866">      throw new GameParseException(&quot;No unit called:&quot; + unitType + thisErrorMsg());</span>
    }
    // we should allow positive and negative numbers
<span class="fc" id="L869">    final int n = getInt(s[0]);</span>
<span class="fc" id="L870">    m_bombingBonus.put(ut, n);</span>
<span class="fc" id="L871">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setBombingBonus(final IntegerMap&lt;UnitType&gt; value) {
<span class="nc" id="L875">    m_bombingBonus = value;</span>
<span class="nc" id="L876">  }</span>

  public IntegerMap&lt;UnitType&gt; getBombingBonus() {
<span class="fc" id="L879">    return m_bombingBonus;</span>
  }

  public void clearBombingBonus() {
<span class="nc" id="L883">    m_bombingBonus.clear();</span>
<span class="nc" id="L884">  }</span>

  public void resetBombingBonus() {
<span class="nc" id="L887">    m_bombingBonus = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L888">  }</span>

  // Static Methods for interpreting data in attachments
  public static int getAttackBonus(final UnitType ut, final PlayerID player, final GameData data) {
<span class="fc" id="L892">    int rVal = 0;</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="fc" id="L894">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">      if (taa != null) {</span>
<span class="fc" id="L896">        rVal += taa.getAttackBonus().getInt(ut);</span>
      }
    }
<span class="fc" id="L899">    return rVal;</span>
  }

  public static int getDefenseBonus(final UnitType ut, final PlayerID player, final GameData data) {
<span class="fc" id="L903">    int rVal = 0;</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="fc" id="L905">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">      if (taa != null) {</span>
<span class="fc" id="L907">        rVal += taa.getDefenseBonus().getInt(ut);</span>
      }
    }
<span class="fc" id="L910">    return rVal;</span>
  }

  public static int getMovementBonus(final UnitType ut, final PlayerID player, final GameData data) {
<span class="fc" id="L914">    int rVal = 0;</span>
<span class="fc bfc" id="L915" title="All 2 branches covered.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="fc" id="L916">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="fc bfc" id="L917" title="All 2 branches covered.">      if (taa != null) {</span>
<span class="fc" id="L918">        rVal += taa.getMovementBonus().getInt(ut);</span>
      }
    }
<span class="fc" id="L921">    return rVal;</span>
  }

  public static int getRadarBonus(final UnitType ut, final PlayerID player, final GameData data) {
<span class="fc" id="L925">    int rVal = 0;</span>
<span class="fc bfc" id="L926" title="All 2 branches covered.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="fc" id="L927">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">      if (taa != null) {</span>
<span class="fc" id="L929">        rVal += taa.getRadarBonus().getInt(ut);</span>
      }
    }
<span class="fc" id="L932">    return rVal;</span>
  }

  public static int getAirAttackBonus(final UnitType ut, final PlayerID player, final GameData data) {
<span class="nc" id="L936">    int rVal = 0;</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="nc" id="L938">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">      if (taa != null) {</span>
<span class="nc" id="L940">        rVal += taa.getAirAttackBonus().getInt(ut);</span>
      }
    }
<span class="nc" id="L943">    return rVal;</span>
  }

  public static int getAirDefenseBonus(final UnitType ut, final PlayerID player, final GameData data) {
<span class="nc" id="L947">    int rVal = 0;</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="nc" id="L949">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">      if (taa != null) {</span>
<span class="nc" id="L951">        rVal += taa.getAirDefenseBonus().getInt(ut);</span>
      }
    }
<span class="nc" id="L954">    return rVal;</span>
  }

  public static int getProductionBonus(final UnitType ut, final PlayerID player, final GameData data) {
<span class="fc" id="L958">    int rVal = 0;</span>
<span class="pc bpc" id="L959" title="1 of 2 branches missed.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="nc" id="L960">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">      if (taa != null) {</span>
<span class="nc" id="L962">        rVal += taa.getProductionBonus().getInt(ut);</span>
      }
    }
<span class="fc" id="L965">    return rVal;</span>
  }

  public static int getMinimumTerritoryValueForProductionBonus(final PlayerID player, final GameData data) {
<span class="fc" id="L969">    int rVal = -1;</span>
<span class="pc bpc" id="L970" title="1 of 2 branches missed.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="nc" id="L971">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">      if (taa != null) {</span>
<span class="nc" id="L973">        final int min = taa.getMinimumTerritoryValueForProductionBonus();</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">        if (min == -1) {</span>
<span class="nc" id="L975">          continue;</span>
<span class="nc bnc" id="L976" title="All 4 branches missed.">        } else if (rVal == -1 || min &lt; rVal) {</span>
<span class="nc" id="L977">          rVal = min;</span>
        }
      }
    }
<span class="fc" id="L981">    return Math.max(0, rVal);</span>
  }

  public static double getRepairDiscount(final PlayerID player, final GameData data) {
<span class="fc" id="L985">    double rVal = 1.0D;</span>
<span class="fc bfc" id="L986" title="All 2 branches covered.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="fc" id="L987">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="pc bpc" id="L988" title="1 of 2 branches missed.">      if (taa != null) {</span>
<span class="fc" id="L989">        final int min = taa.getRepairDiscount();</span>
<span class="pc bpc" id="L990" title="1 of 2 branches missed.">        if (min == -1) {</span>
<span class="nc" id="L991">          continue;</span>
        } else {
<span class="fc" id="L993">          double fmin = min;</span>
<span class="fc" id="L994">          fmin = fmin / 100.0F;</span>
<span class="fc" id="L995">          rVal -= fmin;</span>
        }
      }
    }
<span class="fc" id="L999">    return Math.max(0.0D, rVal);</span>
  }

  public static int getWarBondDiceSides(final PlayerID player, final GameData data) {
<span class="nc" id="L1003">    int rVal = 0;</span>
<span class="nc bnc" id="L1004" title="All 2 branches missed.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="nc" id="L1005">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">      if (taa != null) {</span>
<span class="nc" id="L1007">        final int sides = taa.getWarBondDiceSides();</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">        if (sides &gt; 0) {</span>
<span class="nc" id="L1009">          rVal += sides;</span>
        }
      }
    }
<span class="nc" id="L1013">    return Math.max(0, rVal);</span>
  }

  public static int getWarBondDiceNumber(final PlayerID player, final GameData data) {
<span class="nc" id="L1017">    int rVal = 0;</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="nc" id="L1019">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">      if (taa != null) {</span>
<span class="nc" id="L1021">        final int number = taa.getWarBondDiceNumber();</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">        if (number &gt; 0) {</span>
<span class="nc" id="L1023">          rVal += number;</span>
        }
      }
    }
<span class="nc" id="L1027">    return Math.max(0, rVal);</span>
  }

  private static int getRocketDiceNumber(final UnitType ut, final PlayerID player, final GameData data) {
<span class="nc" id="L1031">    int rVal = 0;</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="nc" id="L1033">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">      if (taa != null) {</span>
<span class="nc" id="L1035">        rVal += taa.getRocketDiceNumber().getInt(ut);</span>
      }
    }
<span class="nc" id="L1038">    return rVal;</span>
  }

  public static int getRocketDiceNumber(final Collection&lt;Unit&gt; rockets, final GameData data) {
<span class="nc" id="L1042">    int rVal = 0;</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">    for (final Unit u : rockets) {</span>
<span class="nc" id="L1044">      rVal += getRocketDiceNumber(u.getType(), u.getOwner(), data);</span>
    }
<span class="nc" id="L1046">    return rVal;</span>
  }

  public static int getRocketDistance(final PlayerID player, final GameData data) {
<span class="nc" id="L1050">    int rVal = 0;</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="nc" id="L1052">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">      if (taa != null) {</span>
<span class="nc" id="L1054">        final int distance = taa.getRocketDistance();</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">        if (distance &gt; 0) {</span>
<span class="nc" id="L1056">          rVal += distance;</span>
        }
      }
    }
<span class="nc" id="L1060">    return Math.max(0, rVal);</span>
  }

  public static int getRocketNumberPerTerritory(final PlayerID player, final GameData data) {
<span class="nc" id="L1064">    int rVal = 0;</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="nc" id="L1066">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">      if (taa != null) {</span>
<span class="nc" id="L1068">        final int number = taa.getRocketNumberPerTerritory();</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">        if (number &gt; 0) {</span>
<span class="nc" id="L1070">          rVal += number;</span>
        }
      }
    }
<span class="nc" id="L1074">    return Math.max(0, rVal);</span>
  }

  private static HashSet&lt;String&gt; getUnitAbilitiesGained(final UnitType ut, final PlayerID player, final GameData data) {
<span class="fc" id="L1078">    final HashSet&lt;String&gt; rVal = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L1079" title="All 2 branches covered.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="fc" id="L1080">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="pc bpc" id="L1081" title="1 of 2 branches missed.">      if (taa != null) {</span>
<span class="nc" id="L1082">        final HashSet&lt;String&gt; abilities = taa.getUnitAbilitiesGained().get(ut);</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">        if (abilities != null) {</span>
<span class="nc" id="L1084">          rVal.addAll(abilities);</span>
        }
      }
    }
<span class="fc" id="L1088">    return rVal;</span>
  }

  public static boolean getUnitAbilitiesGained(final String filterForAbility, final UnitType ut, final PlayerID player,
      final GameData data) {
<span class="fc" id="L1093">    final HashSet&lt;String&gt; abilities = getUnitAbilitiesGained(ut, player, data);</span>
<span class="fc" id="L1094">    return abilities.contains(filterForAbility);</span>
  }

  public static boolean getAllowAirborneForces(final PlayerID player, final GameData data) {
<span class="nc bnc" id="L1098" title="All 2 branches missed.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="nc" id="L1099">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">      if (taa != null) {</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">        if (taa.getAirborneForces()) {</span>
<span class="nc" id="L1102">          return true;</span>
        }
      }
    }
<span class="nc" id="L1106">    return false;</span>
  }

  public static IntegerMap&lt;UnitType&gt; getAirborneCapacity(final PlayerID player, final GameData data) {
<span class="nc" id="L1110">    final IntegerMap&lt;UnitType&gt; capacityMap = new IntegerMap&lt;&gt;();</span>
<span class="nc bnc" id="L1111" title="All 2 branches missed.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="nc" id="L1112">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">      if (taa != null) {</span>
<span class="nc" id="L1114">        capacityMap.add(taa.getAirborneCapacity());</span>
      }
    }
<span class="nc" id="L1117">    return capacityMap;</span>
  }

  public static int getAirborneCapacity(final Collection&lt;Unit&gt; units, final PlayerID player, final GameData data) {
<span class="nc" id="L1121">    final IntegerMap&lt;UnitType&gt; capacityMap = getAirborneCapacity(player, data);</span>
<span class="nc" id="L1122">    int rVal = 0;</span>
<span class="nc bnc" id="L1123" title="All 2 branches missed.">    for (final Unit u : units) {</span>
<span class="nc" id="L1124">      rVal += Math.max(0, (capacityMap.getInt(u.getType()) - ((TripleAUnit) u).getLaunched()));</span>
    }
<span class="nc" id="L1126">    return rVal;</span>
  }

  public static Set&lt;UnitType&gt; getAirborneTypes(final PlayerID player, final GameData data) {
<span class="nc" id="L1130">    final Set&lt;UnitType&gt; airborneUnits = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="nc" id="L1132">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="nc bnc" id="L1133" title="All 2 branches missed.">      if (taa != null) {</span>
<span class="nc" id="L1134">        airborneUnits.addAll(taa.getAirborneTypes());</span>
      }
    }
<span class="nc" id="L1137">    return airborneUnits;</span>
  }

  public static int getAirborneDistance(final PlayerID player, final GameData data) {
<span class="nc" id="L1141">    int rVal = 0;</span>
<span class="nc bnc" id="L1142" title="All 2 branches missed.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="nc" id="L1143">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">      if (taa != null) {</span>
<span class="nc" id="L1145">        rVal += taa.getAirborneDistance();</span>
      }
    }
<span class="nc" id="L1148">    return Math.max(0, rVal);</span>
  }

  public static Set&lt;UnitType&gt; getAirborneBases(final PlayerID player, final GameData data) {
<span class="nc" id="L1152">    final Set&lt;UnitType&gt; airborneBases = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="nc" id="L1154">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="nc bnc" id="L1155" title="All 2 branches missed.">      if (taa != null) {</span>
<span class="nc" id="L1156">        airborneBases.addAll(taa.getAirborneBases());</span>
      }
    }
<span class="nc" id="L1159">    return airborneBases;</span>
  }

  public static HashMap&lt;String, HashSet&lt;UnitType&gt;&gt; getAirborneTargettedByAA(final PlayerID player,
      final GameData data) {
<span class="fc" id="L1164">    final HashMap&lt;String, HashSet&lt;UnitType&gt;&gt; rVal = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L1165" title="All 2 branches covered.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="fc" id="L1166">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="pc bpc" id="L1167" title="1 of 2 branches missed.">      if (taa != null) {</span>
<span class="fc" id="L1168">        final HashMap&lt;String, HashSet&lt;UnitType&gt;&gt; mapAA = taa.getAirborneTargettedByAA();</span>
<span class="pc bpc" id="L1169" title="2 of 4 branches missed.">        if (mapAA != null &amp;&amp; !mapAA.isEmpty()) {</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">          for (final Entry&lt;String, HashSet&lt;UnitType&gt;&gt; entry : mapAA.entrySet()) {</span>
<span class="nc" id="L1171">            HashSet&lt;UnitType&gt; current = rVal.get(entry.getKey());</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">            if (current == null) {</span>
<span class="nc" id="L1173">              current = new HashSet&lt;&gt;();</span>
            }
<span class="nc" id="L1175">            current.addAll(entry.getValue());</span>
<span class="nc" id="L1176">            rVal.put(entry.getKey(), current);</span>
          }
        }
      }
    }
<span class="fc" id="L1181">    return rVal;</span>
  }

  public static int getAttackRollsBonus(final UnitType ut, final PlayerID player, final GameData data) {
<span class="fc" id="L1185">    int rVal = 0;</span>
<span class="fc bfc" id="L1186" title="All 2 branches covered.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="fc" id="L1187">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="pc bpc" id="L1188" title="1 of 2 branches missed.">      if (taa != null) {</span>
<span class="fc" id="L1189">        rVal += taa.getAttackRollsBonus().getInt(ut);</span>
      }
    }
<span class="fc" id="L1192">    return rVal;</span>
  }

  public static int getDefenseRollsBonus(final UnitType ut, final PlayerID player, final GameData data) {
<span class="fc" id="L1196">    int rVal = 0;</span>
<span class="fc bfc" id="L1197" title="All 2 branches covered.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="fc" id="L1198">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="pc bpc" id="L1199" title="1 of 2 branches missed.">      if (taa != null) {</span>
<span class="fc" id="L1200">        rVal += taa.getDefenseRollsBonus().getInt(ut);</span>
      }
    }
<span class="fc" id="L1203">    return rVal;</span>
  }

  public static int getBombingBonus(final UnitType ut, final PlayerID player, final GameData data) {
<span class="fc" id="L1207">    int rVal = 0;</span>
<span class="fc bfc" id="L1208" title="All 2 branches covered.">    for (final TechAdvance ta : TechTracker.getCurrentTechAdvances(player, data)) {</span>
<span class="fc" id="L1209">      final TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="pc bpc" id="L1210" title="1 of 2 branches missed.">      if (taa != null) {</span>
<span class="fc" id="L1211">        rVal += taa.getBombingBonus().getInt(ut);</span>
      }
    }
<span class="fc" id="L1214">    return rVal;</span>
  }

  /**
   * Must be done only in GameParser, and only after we have already parsed ALL technologies, attachments, and game
   * options/properties.
   *
   * @param data
   * @throws GameParseException
   */
  @InternalDoNotExport
  public static void setDefaultTechnologyAttachments(final GameData data) throws GameParseException {
    // loop through all technologies. any &quot;default/hard-coded&quot; tech that doesn't have an attachment, will get its
    // &quot;default&quot; attachment. any
    // non-default tech are ignored.
<span class="fc bfc" id="L1229" title="All 2 branches covered.">    for (final TechAdvance techAdvance : TechAdvance.getTechAdvances(data)) {</span>
      final TechAdvance ta;
<span class="fc bfc" id="L1231" title="All 2 branches covered.">      if (techAdvance instanceof GenericTechAdvance) {</span>
<span class="fc" id="L1232">        final TechAdvance adv = ((GenericTechAdvance) techAdvance).getAdvance();</span>
<span class="fc bfc" id="L1233" title="All 2 branches covered.">        if (adv != null) {</span>
<span class="fc" id="L1234">          ta = adv;</span>
        } else {
          continue;
        }
<span class="fc" id="L1238">      } else {</span>
<span class="fc" id="L1239">        ta = techAdvance;</span>
      }
<span class="fc" id="L1241">      final String propertyString = ta.getProperty();</span>
<span class="fc" id="L1242">      TechAbilityAttachment taa = TechAbilityAttachment.get(ta);</span>
<span class="fc bfc" id="L1243" title="All 2 branches covered.">      if (taa == null) {</span>
        // debating if we should have flags for things like &quot;air&quot;, &quot;land&quot;, &quot;sea&quot;, &quot;aaGun&quot;, &quot;factory&quot;, &quot;strategic
        // bomber&quot;, etc.
        // perhaps just the easy ones, of air, land, and sea?
<span class="fc bfc" id="L1247" title="All 2 branches covered.">        if (propertyString.equals(TechAdvance.TECH_PROPERTY_LONG_RANGE_AIRCRAFT)) {</span>
<span class="fc" id="L1248">          taa = new TechAbilityAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME, ta, data);</span>
<span class="fc" id="L1249">          ta.addAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME, taa);</span>
<span class="fc" id="L1250">          final List&lt;UnitType&gt; allAir =</span>
<span class="fc" id="L1251">              Match.getMatches(data.getUnitTypeList().getAllUnitTypes(), Matches.UnitTypeIsAir);</span>
<span class="fc bfc" id="L1252" title="All 2 branches covered.">          for (final UnitType air : allAir) {</span>
<span class="fc" id="L1253">            taa.setMovementBonus(&quot;2:&quot; + air.getName());</span>
          }
<span class="fc bfc" id="L1255" title="All 2 branches covered.">        } else if (propertyString.equals(TechAdvance.TECH_PROPERTY_AA_RADAR)) {</span>
<span class="fc" id="L1256">          taa = new TechAbilityAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME, ta, data);</span>
<span class="fc" id="L1257">          ta.addAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME, taa);</span>
<span class="fc" id="L1258">          final List&lt;UnitType&gt; allAA =</span>
<span class="fc" id="L1259">              Match.getMatches(data.getUnitTypeList().getAllUnitTypes(), Matches.UnitTypeIsAAforAnything);</span>
<span class="fc bfc" id="L1260" title="All 2 branches covered.">          for (final UnitType aa : allAA) {</span>
<span class="fc" id="L1261">            taa.setRadarBonus(&quot;1:&quot; + aa.getName());</span>
          }
<span class="fc bfc" id="L1263" title="All 2 branches covered.">        } else if (propertyString.equals(TechAdvance.TECH_PROPERTY_SUPER_SUBS)) {</span>
<span class="fc" id="L1264">          taa = new TechAbilityAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME, ta, data);</span>
<span class="fc" id="L1265">          ta.addAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME, taa);</span>
<span class="fc" id="L1266">          final List&lt;UnitType&gt; allSubs =</span>
<span class="fc" id="L1267">              Match.getMatches(data.getUnitTypeList().getAllUnitTypes(), Matches.UnitTypeIsSub);</span>
<span class="fc bfc" id="L1268" title="All 2 branches covered.">          for (final UnitType sub : allSubs) {</span>
<span class="fc" id="L1269">            taa.setAttackBonus(&quot;1:&quot; + sub.getName());</span>
          }
<span class="fc bfc" id="L1271" title="All 2 branches covered.">        } else if (propertyString.equals(TechAdvance.TECH_PROPERTY_JET_POWER)) {</span>
<span class="fc" id="L1272">          taa = new TechAbilityAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME, ta, data);</span>
<span class="fc" id="L1273">          ta.addAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME, taa);</span>
<span class="fc" id="L1274">          final List&lt;UnitType&gt; allJets = Match.getMatches(data.getUnitTypeList().getAllUnitTypes(),</span>
<span class="fc" id="L1275">              new CompositeMatchAnd&lt;&gt;(Matches.UnitTypeIsAir, Matches.UnitTypeIsStrategicBomber.invert()));</span>
<span class="fc" id="L1276">          final boolean ww2v3TechModel = games.strategy.triplea.Properties.getWW2V3TechModel(data);</span>
<span class="fc bfc" id="L1277" title="All 2 branches covered.">          for (final UnitType jet : allJets) {</span>
<span class="fc bfc" id="L1278" title="All 2 branches covered.">            if (ww2v3TechModel) {</span>
<span class="fc" id="L1279">              taa.setAttackBonus(&quot;1:&quot; + jet.getName());</span>
<span class="fc" id="L1280">            } else {</span>
<span class="fc" id="L1281">              taa.setDefenseBonus(&quot;1:&quot; + jet.getName());</span>
            }
          }
<span class="fc bfc" id="L1284" title="All 2 branches covered.">        } else if (propertyString.equals(TechAdvance.TECH_PROPERTY_INCREASED_FACTORY_PRODUCTION)) {</span>
<span class="fc" id="L1285">          taa = new TechAbilityAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME, ta, data);</span>
<span class="fc" id="L1286">          ta.addAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME, taa);</span>
<span class="fc" id="L1287">          final List&lt;UnitType&gt; allFactories =</span>
<span class="fc" id="L1288">              Match.getMatches(data.getUnitTypeList().getAllUnitTypes(), Matches.UnitTypeCanProduceUnits);</span>
<span class="fc bfc" id="L1289" title="All 2 branches covered.">          for (final UnitType factory : allFactories) {</span>
<span class="fc" id="L1290">            taa.setProductionBonus(&quot;2:&quot; + factory.getName());</span>
<span class="fc" id="L1291">            taa.setMinimumTerritoryValueForProductionBonus(&quot;3&quot;);</span>
            // means a 50% discount, which is half price
<span class="fc" id="L1293">            taa.setRepairDiscount(&quot;50&quot;);</span>
          }
<span class="fc bfc" id="L1295" title="All 2 branches covered.">        } else if (propertyString.equals(TechAdvance.TECH_PROPERTY_WAR_BONDS)) {</span>
<span class="fc" id="L1296">          taa = new TechAbilityAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME, ta, data);</span>
<span class="fc" id="L1297">          ta.addAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME, taa);</span>
<span class="fc" id="L1298">          taa.setWarBondDiceSides(Integer.toString(data.getDiceSides()));</span>
<span class="fc" id="L1299">          taa.setWarBondDiceNumber(&quot;1&quot;);</span>
<span class="fc bfc" id="L1300" title="All 2 branches covered.">        } else if (propertyString.equals(TechAdvance.TECH_PROPERTY_ROCKETS)) {</span>
<span class="fc" id="L1301">          taa = new TechAbilityAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME, ta, data);</span>
<span class="fc" id="L1302">          ta.addAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME, taa);</span>
<span class="fc" id="L1303">          final List&lt;UnitType&gt; allRockets =</span>
<span class="fc" id="L1304">              Match.getMatches(data.getUnitTypeList().getAllUnitTypes(), Matches.UnitTypeIsRocket);</span>
<span class="fc bfc" id="L1305" title="All 2 branches covered.">          for (final UnitType rocket : allRockets) {</span>
<span class="fc" id="L1306">            taa.setRocketDiceNumber(&quot;1:&quot; + rocket.getName());</span>
          }
          // taa.setRocketDiceSides(Integer.toString(data.getDiceSides()));
<span class="fc" id="L1309">          taa.setRocketDistance(&quot;3&quot;);</span>
<span class="fc" id="L1310">          taa.setRocketNumberPerTerritory(&quot;1&quot;);</span>
<span class="fc bfc" id="L1311" title="All 2 branches covered.">        } else if (propertyString.equals(TechAdvance.TECH_PROPERTY_DESTROYER_BOMBARD)) {</span>
<span class="fc" id="L1312">          taa = new TechAbilityAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME, ta, data);</span>
<span class="fc" id="L1313">          ta.addAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME, taa);</span>
<span class="fc" id="L1314">          final List&lt;UnitType&gt; allDestroyers =</span>
<span class="fc" id="L1315">              Match.getMatches(data.getUnitTypeList().getAllUnitTypes(), Matches.UnitTypeIsDestroyer);</span>
<span class="fc bfc" id="L1316" title="All 2 branches covered.">          for (final UnitType destroyer : allDestroyers) {</span>
<span class="fc" id="L1317">            taa.setUnitAbilitiesGained(destroyer.getName() + &quot;:&quot; + ABILITY_CAN_BOMBARD);</span>
          }
<span class="fc bfc" id="L1319" title="All 2 branches covered.">        } else if (propertyString.equals(TechAdvance.TECH_PROPERTY_HEAVY_BOMBER)) {</span>
<span class="fc" id="L1320">          taa = new TechAbilityAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME, ta, data);</span>
<span class="fc" id="L1321">          ta.addAttachment(Constants.TECH_ABILITY_ATTACHMENT_NAME, taa);</span>
<span class="fc" id="L1322">          final List&lt;UnitType&gt; allBombers =</span>
<span class="fc" id="L1323">              Match.getMatches(data.getUnitTypeList().getAllUnitTypes(), Matches.UnitTypeIsStrategicBomber);</span>
<span class="fc" id="L1324">          final int heavyBomberDiceRollsTotal = games.strategy.triplea.Properties.getHeavyBomberDiceRolls(data);</span>
<span class="fc" id="L1325">          final boolean heavyBombersLHTR = games.strategy.triplea.Properties.getLHTR_Heavy_Bombers(data);</span>
<span class="fc bfc" id="L1326" title="All 2 branches covered.">          for (final UnitType bomber : allBombers) {</span>
            // TODO: The bomber dice rolls get set when the xml is parsed.
            // we subtract the base rolls to get the bonus
<span class="fc" id="L1329">            final int heavyBomberDiceRollsBonus =</span>
<span class="fc" id="L1330">                heavyBomberDiceRollsTotal - UnitAttachment.get(bomber).getAttackRolls(PlayerID.NULL_PLAYERID);</span>
<span class="fc" id="L1331">            taa.setAttackRollsBonus(heavyBomberDiceRollsBonus + &quot;:&quot; + bomber.getName());</span>
<span class="fc bfc" id="L1332" title="All 2 branches covered.">            if (heavyBombersLHTR) {</span>
              // TODO: this all happens WHEN the xml is parsed. Which means if the user changes the game options, this
              // does not get changed.
              // (meaning, turning on LHTR bombers will not result in this bonus damage, etc. It would have to start on,
              // in the xml.)
<span class="fc" id="L1337">              taa.setDefenseRollsBonus(heavyBomberDiceRollsBonus + &quot;:&quot; + bomber.getName());</span>
              // LHTR adds 1 to base roll
<span class="fc" id="L1339">              taa.setBombingBonus(&quot;1:&quot; + bomber.getName());</span>
            }
          }
        }
        // The following technologies should NOT have ability attachments for them:
        // shipyards and industrialTechnology = because it is better to use a Trigger to change player's production
        // improvedArtillerySupport = because it is already completely atomized and controlled through support
        // attachments
        // paratroopers = because it is already completely atomized and controlled through unit attachments + game
        // options
        // mechanizedInfantry = because it is already completely atomized and controlled through unit attachments
        // IF one of the above named techs changes what it does in a future version of a&amp;a, and the change is large
        // enough or different
        // enough that it cannot be done easily with a new game option,
        // then it is better to create a new tech rather than change the old one, and give the new one a new name, like
        // paratroopers2 or
        // paratroopersAttack or Airborne_Forces, or some crap.
      }
    }
<span class="fc" id="L1358">  }</span>

  // validator
  @Override
  public void validate(final GameData data) throws GameParseException {
<span class="fc" id="L1363">    final TechAdvance ta = (TechAdvance) this.getAttachedTo();</span>
<span class="fc bfc" id="L1364" title="All 2 branches covered.">    if (ta instanceof GenericTechAdvance) {</span>
<span class="fc" id="L1365">      final TechAdvance hardCodedAdvance = ((GenericTechAdvance) ta).getAdvance();</span>
<span class="pc bpc" id="L1366" title="1 of 2 branches missed.">      if (hardCodedAdvance != null) {</span>
<span class="nc" id="L1367">        throw new GameParseException(</span>
<span class="nc" id="L1368">            &quot;A custom Generic Tech Advance naming a hardcoded tech, may not have a Tech Ability Attachment!&quot;</span>
<span class="nc" id="L1369">                + this.thisErrorMsg());</span>
      }
    }
<span class="fc" id="L1372">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>test (25/nov/2016 10:16:58)</div></body></html>