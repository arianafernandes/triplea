<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>UnitAttachment.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">test (25/nov/2016 10:16:58)</a> &gt; <a href="../../index.html" class="el_group">triplea</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">games.strategy.triplea.attachments</a> &gt; <span class="el_source">UnitAttachment.java</span></div><h1>UnitAttachment.java</h1><pre class="source lang-java linenums">package games.strategy.triplea.attachments;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;

import games.strategy.engine.data.Attachable;
import games.strategy.engine.data.DefaultAttachment;
import games.strategy.engine.data.GameData;
import games.strategy.engine.data.GameParseException;
import games.strategy.engine.data.PlayerID;
import games.strategy.engine.data.Resource;
import games.strategy.engine.data.Territory;
import games.strategy.engine.data.Unit;
import games.strategy.engine.data.UnitType;
import games.strategy.engine.data.annotations.GameProperty;
import games.strategy.triplea.Constants;
import games.strategy.triplea.MapSupport;
import games.strategy.triplea.Properties;
import games.strategy.triplea.delegate.Matches;
import games.strategy.triplea.delegate.TechTracker;
import games.strategy.triplea.formatter.MyFormatter;
import games.strategy.util.CompositeMatchAnd;
import games.strategy.util.IntegerMap;
import games.strategy.util.Match;
import games.strategy.util.Tuple;

/**
 * Despite the misleading name, this attaches not to individual Units but to UnitTypes.
 * Please follow this naming convention:
 * if the property is called &quot;m_fooBar&quot;
 * then you must have a &quot;setFooBar&quot; and &quot;getFooBar&quot;,
 * and if the set method adds to a list or map, then you also need a &quot;clearFooBar&quot;.
 * Do not change the name fooBar to make it plural or any other crap.
 */
@MapSupport
public class UnitAttachment extends DefaultAttachment {
  private static final long serialVersionUID = -2946748686268541820L;

  /**
   * Convenience method.
   */
  public static UnitAttachment get(final UnitType type) {
<span class="fc" id="L52">    final UnitAttachment rVal = (UnitAttachment) type.getAttachment(Constants.UNIT_ATTACHMENT_NAME);</span>
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">    if (rVal == null) {</span>
<span class="nc" id="L54">      throw new IllegalStateException(&quot;No unit type attachment for:&quot; + type.getName());</span>
    }
<span class="fc" id="L56">    return rVal;</span>
  }

  public static UnitAttachment get(final UnitType type, final String nameOfAttachment) {
<span class="nc" id="L60">    final UnitAttachment rVal = (UnitAttachment) type.getAttachment(nameOfAttachment);</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">    if (rVal == null) {</span>
<span class="nc" id="L62">      throw new IllegalStateException(</span>
<span class="nc" id="L63">          &quot;No unit type attachment for:&quot; + type.getName() + &quot; with name:&quot; + nameOfAttachment);</span>
    }
<span class="nc" id="L65">    return rVal;</span>
  }

  private static Collection&lt;UnitType&gt; getUnitTypesFromUnitList(final Collection&lt;Unit&gt; units) {
<span class="nc" id="L69">    final Collection&lt;UnitType&gt; types = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">    for (final Unit u : units) {</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">      if (!types.contains(u.getType())) {</span>
<span class="nc" id="L72">        types.add(u.getType());</span>
      }
    }
<span class="nc" id="L75">    return types;</span>
  }

  public static final String UNITSMAYNOTLANDONCARRIER = &quot;unitsMayNotLandOnCarrier&quot;;
  public static final String UNITSMAYNOTLEAVEALLIEDCARRIER = &quot;unitsMayNotLeaveAlliedCarrier&quot;;
  // movement related
<span class="fc" id="L81">  private boolean m_isAir = false;</span>
<span class="fc" id="L82">  private boolean m_isSea = false;</span>
<span class="fc" id="L83">  private int m_movement = 0;</span>
<span class="fc" id="L84">  private boolean m_canBlitz = false;</span>
<span class="fc" id="L85">  private boolean m_isKamikaze = false;</span>
  // a colon delimited list of transports where this unit may invade from, it supports &quot;none&quot;
  // and if empty it allows you to invade from all
<span class="fc" id="L88">  private String[] m_canInvadeOnlyFrom = null;</span>
<span class="fc" id="L89">  private IntegerMap&lt;Resource&gt; m_fuelCost = new IntegerMap&lt;&gt;();</span>
<span class="fc" id="L90">  private boolean m_canNotMoveDuringCombatMove = false;</span>
<span class="fc" id="L91">  private Tuple&lt;Integer, String&gt; m_movementLimit = null;</span>
  // combat related
<span class="fc" id="L93">  private int m_attack = 0;</span>
<span class="fc" id="L94">  private int m_defense = 0;</span>
<span class="fc" id="L95">  private boolean m_isInfrastructure = false;</span>
<span class="fc" id="L96">  private boolean m_canBombard = false;</span>
<span class="fc" id="L97">  private int m_bombard = -1;</span>
<span class="fc" id="L98">  private boolean m_isSub = false;</span>
<span class="fc" id="L99">  private boolean m_isDestroyer = false;</span>
<span class="fc" id="L100">  private boolean m_artillery = false;</span>
<span class="fc" id="L101">  private boolean m_artillerySupportable = false;</span>
<span class="fc" id="L102">  private int m_unitSupportCount = -1;</span>
<span class="fc" id="L103">  private int m_isMarine = 0;</span>
<span class="fc" id="L104">  private boolean m_isSuicide = false;</span>
<span class="fc" id="L105">  private Tuple&lt;Integer, String&gt; m_attackingLimit = null;</span>
<span class="fc" id="L106">  private int m_attackRolls = 1;</span>
<span class="fc" id="L107">  private int m_defenseRolls = 1;</span>
<span class="fc" id="L108">  private boolean m_chooseBestRoll = false;</span>
  // transportation related
<span class="fc" id="L110">  private boolean m_isCombatTransport = false;</span>
  // -1 if cant transport
<span class="fc" id="L112">  private int m_transportCapacity = -1;</span>
  // -1 if cant be transported
<span class="fc" id="L114">  private int m_transportCost = -1;</span>
  // -1 if cant act as a carrier
<span class="fc" id="L116">  private int m_carrierCapacity = -1;</span>
  // -1 if cant land on a carrier
<span class="fc" id="L118">  private int m_carrierCost = -1;</span>
<span class="fc" id="L119">  private boolean m_isAirTransport = false;</span>
<span class="fc" id="L120">  private boolean m_isAirTransportable = false;</span>
<span class="fc" id="L121">  private boolean m_isInfantry = false;</span>
<span class="fc" id="L122">  private boolean m_isLandTransport = false;</span>
  // aa related
  // &quot;isAA&quot; and &quot;isAAmovement&quot; are also valid setters, used as shortcuts for calling multiple aa related setters. Must
  // keep.
<span class="fc" id="L126">  private boolean m_isAAforCombatOnly = false;</span>
<span class="fc" id="L127">  private boolean m_isAAforBombingThisUnitOnly = false;</span>
<span class="fc" id="L128">  private boolean m_isAAforFlyOverOnly = false;</span>
<span class="fc" id="L129">  private boolean m_isRocket = false;</span>
<span class="fc" id="L130">  private int m_attackAA = 1;</span>
<span class="fc" id="L131">  private int m_offensiveAttackAA = 0;</span>
<span class="fc" id="L132">  private int m_attackAAmaxDieSides = -1;</span>
<span class="fc" id="L133">  private int m_offensiveAttackAAmaxDieSides = -1;</span>
  // -1 means infinite
<span class="fc" id="L135">  private int m_maxAAattacks = -1;</span>
  // -1 means infinite
<span class="fc" id="L137">  private int m_maxRoundsAA = 1;</span>
  // default value for when it is not set
<span class="fc" id="L139">  private String m_typeAA = &quot;AA&quot;;</span>
  // null means targeting air units only
<span class="fc" id="L141">  private HashSet&lt;UnitType&gt; m_targetsAA = null;</span>
  // if false, we cannot shoot more times than there are number of planes
<span class="fc" id="L143">  private boolean m_mayOverStackAA = false;</span>
  // if false, we instantly kill anything our AA shot hits
<span class="fc" id="L145">  private boolean m_damageableAA = false;</span>
  // if these enemy units are present, the gun does not fire at all
<span class="fc" id="L147">  private HashSet&lt;UnitType&gt; m_willNotFireIfPresent = new HashSet&lt;&gt;();</span>
  // strategic bombing related
<span class="fc" id="L149">  private boolean m_isStrategicBomber = false;</span>
<span class="fc" id="L150">  private int m_bombingMaxDieSides = -1;</span>
<span class="fc" id="L151">  private int m_bombingBonus = -1;</span>
<span class="fc" id="L152">  private boolean m_canIntercept = false;</span>
<span class="fc" id="L153">  private boolean m_canEscort = false;</span>
<span class="fc" id="L154">  private boolean m_canAirBattle = false;</span>
<span class="fc" id="L155">  private int m_airDefense = 0;</span>
<span class="fc" id="L156">  private int m_airAttack = 0;</span>
  // null means they can target any unit that can be damaged
<span class="fc" id="L158">  private HashSet&lt;UnitType&gt; m_bombingTargets = null;</span>
  // production related
  // this has been split into canProduceUnits, isConstruction, canBeDamaged, and isInfrastructure
  // private boolean m_isFactory = false;
<span class="fc" id="L162">  private boolean m_canProduceUnits = false;</span>
  // -1 means either it can't produce any, or it produces at the value of the territory it is located in
<span class="fc" id="L164">  private int m_canProduceXUnits = -1;</span>
<span class="fc" id="L165">  private IntegerMap&lt;UnitType&gt; m_createsUnitsList = new IntegerMap&lt;&gt;();</span>
<span class="fc" id="L166">  private IntegerMap&lt;Resource&gt; m_createsResourcesList = new IntegerMap&lt;&gt;();</span>
  // damage related
<span class="fc" id="L168">  private int m_hitPoints = 1;</span>
<span class="fc" id="L169">  private boolean m_canBeDamaged = false;</span>
  // this is bombing damage, not hitpoints. default of 2 means that factories will take 2x the territory value
  // they are in, of damage.
<span class="fc" id="L172">  private int m_maxDamage = 2;</span>
  // -1 if can't be disabled
<span class="fc" id="L174">  private int m_maxOperationalDamage = -1;</span>
<span class="fc" id="L175">  private boolean m_canDieFromReachingMaxDamage = false;</span>
  // placement related
<span class="fc" id="L177">  private boolean m_isConstruction = false;</span>
  // can be any String except for &quot;none&quot; if isConstruction is true
<span class="fc" id="L179">  private String m_constructionType = &quot;none&quot;;</span>
  // -1 if not set, is meaningless
<span class="fc" id="L181">  private int m_constructionsPerTerrPerTypePerTurn = -1;</span>
  // -1 if not set, is meaningless
<span class="fc" id="L183">  private int m_maxConstructionsPerTypePerTerr = -1;</span>
  // -1 means anywhere
<span class="fc" id="L185">  private int m_canOnlyBePlacedInTerritoryValuedAtX = -1;</span>
  // multiple colon delimited lists of the unit combos required for
  // this unit to be built somewhere. (units must be in same
  // territory, owned by player, not be disabled)
<span class="fc" id="L189">  private ArrayList&lt;String[]&gt; m_requiresUnits = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L190">  private IntegerMap&lt;UnitType&gt; m_consumesUnits = new IntegerMap&lt;&gt;();</span>
  // a colon delimited list of territories where this unit may not be placed
  // also an allowed setter is &quot;setUnitPlacementOnlyAllowedIn&quot;,
  // which just creates m_unitPlacementRestrictions with an inverted list of territories
<span class="fc" id="L194">  private String[] m_unitPlacementRestrictions = null;</span>
  // -1 if infinite (infinite is default)
<span class="fc" id="L196">  private int m_maxBuiltPerPlayer = -1;</span>
<span class="fc" id="L197">  private Tuple&lt;Integer, String&gt; m_placementLimit = null;</span>
  // scrambling related
<span class="fc" id="L199">  private boolean m_canScramble = false;</span>
<span class="fc" id="L200">  private boolean m_isAirBase = false;</span>
  // -1 if can't scramble
<span class="fc" id="L202">  private int m_maxScrambleDistance = -1;</span>
  // -1 for infinite
<span class="fc" id="L204">  private int m_maxScrambleCount = -1;</span>
  // special abilities
<span class="fc" id="L206">  private int m_blockade = 0;</span>
  // a colon delimited list of the units this unit can repair.
  // (units must be in same territory, unless this unit is land
  // and the repaired unit is sea)
<span class="fc" id="L210">  private IntegerMap&lt;UnitType&gt; m_repairsUnits = new IntegerMap&lt;&gt;();</span>
<span class="fc" id="L211">  private IntegerMap&lt;UnitType&gt; m_givesMovement = new IntegerMap&lt;&gt;();</span>
<span class="fc" id="L212">  private ArrayList&lt;Tuple&lt;String, PlayerID&gt;&gt; m_destroyedWhenCapturedBy = new ArrayList&lt;&gt;();</span>
  // also an allowed setter is &quot;setDestroyedWhenCapturedFrom&quot; which will just create m_destroyedWhenCapturedBy with a
  // specific list
<span class="fc" id="L215">  private LinkedHashMap&lt;String, Tuple&lt;String, IntegerMap&lt;UnitType&gt;&gt;&gt; m_whenCapturedChangesInto =</span>
<span class="fc" id="L216">      new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L217">  private ArrayList&lt;PlayerID&gt; m_canBeCapturedOnEnteringBy = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L218">  private ArrayList&lt;PlayerID&gt; m_canBeGivenByTerritoryTo = new ArrayList&lt;&gt;();</span>
  // a set of information for dealing with special abilities or
  // loss of abilities when a unit takes x-y amount of damage
<span class="fc" id="L221">  private ArrayList&lt;Tuple&lt;Tuple&lt;Integer, Integer&gt;, Tuple&lt;String, String&gt;&gt;&gt; m_whenCombatDamaged =</span>
<span class="fc" id="L222">      new ArrayList&lt;&gt;();</span>
  // a kind of support attachment for giving actual unit
  // attachment abilities or other to a unit, when in the
  // precense or on the same route with another unit
<span class="fc" id="L226">  private ArrayList&lt;String&gt; m_receivesAbilityWhenWith = new ArrayList&lt;&gt;();</span>
  // currently used for: placement in original territories only
<span class="fc" id="L228">  private HashSet&lt;String&gt; m_special = new HashSet&lt;&gt;();</span>

  /** Creates new UnitAttachment */
  public UnitAttachment(final String name, final Attachable attachable, final GameData gameData) {
<span class="fc" id="L232">    super(name, attachable, gameData);</span>
<span class="fc" id="L233">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanIntercept(final String value) {
<span class="fc" id="L237">    m_canIntercept = getBool(value);</span>
<span class="fc" id="L238">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanIntercept(final boolean value) {
<span class="fc" id="L242">    m_canIntercept = value;</span>
<span class="fc" id="L243">  }</span>

  public boolean getCanIntercept() {
<span class="fc" id="L246">    return m_canIntercept;</span>
  }

  public void resetCanIntercept() {
<span class="nc" id="L250">    m_canIntercept = false;</span>
<span class="nc" id="L251">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanEscort(final String value) {
<span class="fc" id="L255">    m_canEscort = getBool(value);</span>
<span class="fc" id="L256">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanEscort(final boolean value) {
<span class="fc" id="L260">    m_canEscort = value;</span>
<span class="fc" id="L261">  }</span>

  public boolean getCanEscort() {
<span class="fc" id="L264">    return m_canEscort;</span>
  }

  public void resetCanEscort() {
<span class="nc" id="L268">    m_canEscort = false;</span>
<span class="nc" id="L269">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanAirBattle(final String value) {
<span class="fc" id="L273">    m_canAirBattle = getBool(value);</span>
<span class="fc" id="L274">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanAirBattle(final Boolean value) {
<span class="fc" id="L278">    m_canAirBattle = value;</span>
<span class="fc" id="L279">  }</span>

  public boolean getCanAirBattle() {
<span class="fc" id="L282">    return m_canAirBattle;</span>
  }

  public void resetCanAirBattle() {
<span class="nc" id="L286">    m_canAirBattle = false;</span>
<span class="nc" id="L287">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAirDefense(final String value) {
<span class="fc" id="L291">    m_airDefense = getInt(value);</span>
<span class="fc" id="L292">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAirDefense(final Integer value) {
<span class="nc" id="L296">    m_airDefense = value;</span>
<span class="nc" id="L297">  }</span>

  public int getAirDefense(final PlayerID player) {
<span class="nc" id="L300">    return (Math.min(getData().getDiceSides(), Math.max(0,</span>
<span class="nc" id="L301">        m_airDefense + TechAbilityAttachment.getAirDefenseBonus((UnitType) this.getAttachedTo(), player, getData()))));</span>
  }

  public void resetAirDefense() {
<span class="nc" id="L305">    m_airDefense = 0;</span>
<span class="nc" id="L306">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAirAttack(final String value) {
<span class="fc" id="L310">    m_airAttack = getInt(value);</span>
<span class="fc" id="L311">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAirAttack(final Integer value) {
<span class="nc" id="L315">    m_airAttack = value;</span>
<span class="nc" id="L316">  }</span>

  public int getAirAttack(final PlayerID player) {
<span class="nc" id="L319">    return (Math.min(getData().getDiceSides(), Math.max(0,</span>
<span class="nc" id="L320">        m_airAttack + TechAbilityAttachment.getAirAttackBonus((UnitType) this.getAttachedTo(), player, getData()))));</span>
  }

  public void resetAirAttack() {
<span class="nc" id="L324">    m_airAttack = 0;</span>
<span class="nc" id="L325">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsAirTransport(final String s) {
<span class="fc" id="L329">    m_isAirTransport = getBool(s);</span>
<span class="fc" id="L330">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsAirTransport(final Boolean s) {
<span class="fc" id="L334">    m_isAirTransport = s;</span>
<span class="fc" id="L335">  }</span>

  public boolean getIsAirTransport() {
<span class="fc" id="L338">    return m_isAirTransport;</span>
  }

  public void resetIsAirTransport() {
<span class="nc" id="L342">    m_isAirTransport = false;</span>
<span class="nc" id="L343">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsAirTransportable(final String s) {
<span class="fc" id="L347">    m_isAirTransportable = getBool(s);</span>
<span class="fc" id="L348">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsAirTransportable(final Boolean s) {
<span class="fc" id="L352">    m_isAirTransportable = s;</span>
<span class="fc" id="L353">  }</span>

  public boolean getIsAirTransportable() {
<span class="fc" id="L356">    return m_isAirTransportable;</span>
  }

  public void resetIsAirTransportable() {
<span class="nc" id="L360">    m_isAirTransportable = false;</span>
<span class="nc" id="L361">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   *
   * @param value
   * @throws GameParseException
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setCanBeGivenByTerritoryTo(final String value) throws GameParseException {
<span class="fc" id="L371">    final String[] temp = value.split(&quot;:&quot;);</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">    for (final String name : temp) {</span>
<span class="fc" id="L373">      final PlayerID tempPlayer = getData().getPlayerList().getPlayerID(name);</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">      if (tempPlayer != null) {</span>
<span class="fc" id="L375">        m_canBeGivenByTerritoryTo.add(tempPlayer);</span>
<span class="pc bnc" id="L376" title="All 4 branches missed.">      } else if (name.equalsIgnoreCase(&quot;true&quot;) || name.equalsIgnoreCase(&quot;false&quot;)) {</span>
<span class="nc" id="L377">        m_canBeGivenByTerritoryTo.clear();</span>
<span class="nc" id="L378">      } else {</span>
<span class="nc" id="L379">        throw new GameParseException(&quot;No player named: &quot; + name + thisErrorMsg());</span>
      }
    }
<span class="fc" id="L382">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanBeGivenByTerritoryTo(final ArrayList&lt;PlayerID&gt; value) {
<span class="nc" id="L386">    m_canBeGivenByTerritoryTo = value;</span>
<span class="nc" id="L387">  }</span>

  public ArrayList&lt;PlayerID&gt; getCanBeGivenByTerritoryTo() {
<span class="nc" id="L390">    return m_canBeGivenByTerritoryTo;</span>
  }

  public void clearCanBeGivenByTerritoryTo() {
<span class="nc" id="L394">    m_canBeGivenByTerritoryTo.clear();</span>
<span class="nc" id="L395">  }</span>

  public void resetCanBeGivenByTerritoryTo() {
<span class="nc" id="L398">    m_canBeGivenByTerritoryTo = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L399">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   *
   * @param value
   * @throws GameParseException
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setCanBeCapturedOnEnteringBy(final String value) throws GameParseException {
<span class="fc" id="L409">    final String[] temp = value.split(&quot;:&quot;);</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">    for (final String name : temp) {</span>
<span class="fc" id="L411">      final PlayerID tempPlayer = getData().getPlayerList().getPlayerID(name);</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">      if (tempPlayer != null) {</span>
<span class="fc" id="L413">        m_canBeCapturedOnEnteringBy.add(tempPlayer);</span>
<span class="fc" id="L414">      } else {</span>
<span class="nc" id="L415">        throw new GameParseException(&quot;No player named: &quot; + name + thisErrorMsg());</span>
      }
    }
<span class="fc" id="L418">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanBeCapturedOnEnteringBy(final ArrayList&lt;PlayerID&gt; value) {
<span class="nc" id="L422">    m_canBeCapturedOnEnteringBy = value;</span>
<span class="nc" id="L423">  }</span>

  public ArrayList&lt;PlayerID&gt; getCanBeCapturedOnEnteringBy() {
<span class="nc" id="L426">    return m_canBeCapturedOnEnteringBy;</span>
  }

  public void clearCanBeCapturedOnEnteringBy() {
<span class="nc" id="L430">    m_canBeCapturedOnEnteringBy.clear();</span>
<span class="nc" id="L431">  }</span>

  public void resetCanBeCapturedOnEnteringBy() {
<span class="nc" id="L434">    m_canBeCapturedOnEnteringBy = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L435">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   *
   * @param value
   * @throws GameParseException
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setWhenCapturedChangesInto(final String value) throws GameParseException {
<span class="fc" id="L445">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L446" title="2 of 4 branches missed.">    if (s.length &lt; 5 || (s.length - 1) % 2 != 0) {</span>
<span class="nc" id="L447">      throw new GameParseException(&quot;whenCapturedChangesInto must have 5 or more values, &quot;</span>
          + &quot;playerFrom:playerTo:keepAttributes:unitType:howMany (you may have additional unitType:howMany:unitType:howMany, etc&quot;
<span class="nc" id="L449">          + thisErrorMsg());</span>
    }
<span class="fc" id="L451">    final PlayerID pfrom = getData().getPlayerList().getPlayerID(s[0]);</span>
<span class="pc bpc" id="L452" title="2 of 4 branches missed.">    if (pfrom == null &amp;&amp; !s[0].equals(&quot;any&quot;)) {</span>
<span class="nc" id="L453">      throw new GameParseException(&quot;whenCapturedChangesInto: No player named: &quot; + s[0] + thisErrorMsg());</span>
    }
<span class="fc" id="L455">    final PlayerID pto = getData().getPlayerList().getPlayerID(s[1]);</span>
<span class="pc bpc" id="L456" title="2 of 4 branches missed.">    if (pto == null &amp;&amp; !s[1].equals(&quot;any&quot;)) {</span>
<span class="nc" id="L457">      throw new GameParseException(&quot;whenCapturedChangesInto: No player named: &quot; + s[1] + thisErrorMsg());</span>
    }
<span class="fc" id="L459">    getBool(s[2]);</span>
<span class="fc" id="L460">    final IntegerMap&lt;UnitType&gt; unitsToMake = new IntegerMap&lt;&gt;();</span>
<span class="fc bfc" id="L461" title="All 2 branches covered.">    for (int i = 3; i &lt; s.length; i++) {</span>
<span class="fc" id="L462">      final UnitType ut = getData().getUnitTypeList().getUnitType(s[i]);</span>
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">      if (ut == null) {</span>
<span class="nc" id="L464">        throw new GameParseException(&quot;whenCapturedChangesInto: No unit named: &quot; + s[3] + thisErrorMsg());</span>
      }
<span class="fc" id="L466">      i++;</span>
<span class="fc" id="L467">      final int howMany = getInt(s[i]);</span>
<span class="fc" id="L468">      unitsToMake.put(ut, howMany);</span>
    }
<span class="fc" id="L470">    m_whenCapturedChangesInto.put(s[0] + &quot;:&quot; + s[1], Tuple.of(s[2], unitsToMake));</span>
<span class="fc" id="L471">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setWhenCapturedChangesInto(final LinkedHashMap&lt;String, Tuple&lt;String, IntegerMap&lt;UnitType&gt;&gt;&gt; value) {
<span class="nc" id="L475">    m_whenCapturedChangesInto = value;</span>
<span class="nc" id="L476">  }</span>

  public LinkedHashMap&lt;String, Tuple&lt;String, IntegerMap&lt;UnitType&gt;&gt;&gt; getWhenCapturedChangesInto() {
<span class="nc" id="L479">    return m_whenCapturedChangesInto;</span>
  }

  public void clearWhenCapturedChangesInto() {
<span class="nc" id="L483">    m_whenCapturedChangesInto.clear();</span>
<span class="nc" id="L484">  }</span>

  public void resetWhenCapturedChangesInto() {
<span class="nc" id="L487">    m_whenCapturedChangesInto = new LinkedHashMap&lt;&gt;();</span>
<span class="nc" id="L488">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   *
   * @param value
   * @throws GameParseException
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setDestroyedWhenCapturedBy(String value) throws GameParseException {
    // We can prefix this value with &quot;BY&quot; or &quot;FROM&quot; to change the setting. If no setting, default to &quot;BY&quot; since this
    // this is called by
    // destroyedWhenCapturedBy
<span class="fc" id="L501">    String byOrFrom = &quot;BY&quot;;</span>
<span class="pc bpc" id="L502" title="3 of 4 branches missed.">    if (value.startsWith(&quot;BY:&quot;) &amp;&amp; getData().getPlayerList().getPlayerID(&quot;BY&quot;) == null) {</span>
<span class="nc" id="L503">      byOrFrom = &quot;BY&quot;;</span>
<span class="nc" id="L504">      value = value.replaceFirst(&quot;BY:&quot;, &quot;&quot;);</span>
<span class="pc bpc" id="L505" title="1 of 4 branches missed.">    } else if (value.startsWith(&quot;FROM:&quot;) &amp;&amp; getData().getPlayerList().getPlayerID(&quot;FROM&quot;) == null) {</span>
<span class="fc" id="L506">      byOrFrom = &quot;FROM&quot;;</span>
<span class="fc" id="L507">      value = value.replaceFirst(&quot;FROM:&quot;, &quot;&quot;);</span>
    }
<span class="fc" id="L509">    final String[] temp = value.split(&quot;:&quot;);</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">    for (final String name : temp) {</span>
<span class="fc" id="L511">      final PlayerID tempPlayer = getData().getPlayerList().getPlayerID(name);</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">      if (tempPlayer != null) {</span>
<span class="fc" id="L513">        m_destroyedWhenCapturedBy.add(Tuple.of(byOrFrom, tempPlayer));</span>
<span class="fc" id="L514">      } else {</span>
<span class="nc" id="L515">        throw new GameParseException(&quot;No player named: &quot; + name + thisErrorMsg());</span>
      }
    }
<span class="fc" id="L518">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setDestroyedWhenCapturedBy(final ArrayList&lt;Tuple&lt;String, PlayerID&gt;&gt; value) {
<span class="nc" id="L522">    m_destroyedWhenCapturedBy = value;</span>
<span class="nc" id="L523">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setDestroyedWhenCapturedFrom(String value) throws GameParseException {
<span class="pc bpc" id="L527" title="2 of 4 branches missed.">    if (!(value.startsWith(&quot;BY:&quot;) || value.startsWith(&quot;FROM:&quot;))) {</span>
<span class="fc" id="L528">      value = &quot;FROM:&quot; + value;</span>
    }
<span class="fc" id="L530">    setDestroyedWhenCapturedBy(value);</span>
<span class="fc" id="L531">  }</span>

  public ArrayList&lt;Tuple&lt;String, PlayerID&gt;&gt; getDestroyedWhenCapturedBy() {
<span class="nc" id="L534">    return m_destroyedWhenCapturedBy;</span>
  }

  public void clearDestroyedWhenCapturedBy() {
<span class="nc" id="L538">    m_destroyedWhenCapturedBy.clear();</span>
<span class="nc" id="L539">  }</span>

  public void resetDestroyedWhenCapturedBy() {
<span class="nc" id="L542">    m_destroyedWhenCapturedBy = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L543">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanBlitz(final String s) {
<span class="fc" id="L547">    m_canBlitz = getBool(s);</span>
<span class="fc" id="L548">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanBlitz(final Boolean s) {
<span class="nc" id="L552">    m_canBlitz = s;</span>
<span class="nc" id="L553">  }</span>

  public boolean getCanBlitz(final PlayerID player) {
<span class="fc bfc" id="L556" title="All 2 branches covered.">    if (m_canBlitz) {</span>
<span class="fc" id="L557">      return true;</span>
    }
<span class="fc" id="L559">    return TechAbilityAttachment.getUnitAbilitiesGained(TechAbilityAttachment.ABILITY_CAN_BLITZ,</span>
<span class="fc" id="L560">        (UnitType) this.getAttachedTo(), player, getData());</span>
  }

  public void resetCanBlitz() {
<span class="nc" id="L564">    m_canBlitz = false;</span>
<span class="nc" id="L565">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsSub(final String s) {
<span class="fc" id="L569">    m_isSub = getBool(s);</span>
<span class="fc" id="L570">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsSub(final Boolean s) {
<span class="fc" id="L574">    m_isSub = s;</span>
<span class="fc" id="L575">  }</span>

  public boolean getIsSub() {
<span class="fc" id="L578">    return m_isSub;</span>
  }

  public void resetIsSub() {
<span class="nc" id="L582">    m_isSub = false;</span>
<span class="nc" id="L583">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsCombatTransport(final String s) {
<span class="fc" id="L587">    m_isCombatTransport = getBool(s);</span>
<span class="fc" id="L588">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsCombatTransport(final Boolean s) {
<span class="fc" id="L592">    m_isCombatTransport = s;</span>
<span class="fc" id="L593">  }</span>

  public boolean getIsCombatTransport() {
<span class="fc" id="L596">    return m_isCombatTransport;</span>
  }

  public void resetIsCombatTransport() {
<span class="nc" id="L600">    m_isCombatTransport = false;</span>
<span class="nc" id="L601">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsStrategicBomber(final String s) {
<span class="fc" id="L605">    m_isStrategicBomber = getBool(s);</span>
<span class="fc" id="L606">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsStrategicBomber(final Boolean s) {
<span class="fc" id="L610">    m_isStrategicBomber = s;</span>
<span class="fc" id="L611">  }</span>

  public boolean getIsStrategicBomber() {
<span class="fc" id="L614">    return m_isStrategicBomber;</span>
  }

  public void resetIsStrategicBomber() {
<span class="nc" id="L618">    m_isStrategicBomber = false;</span>
<span class="nc" id="L619">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsDestroyer(final String s) {
<span class="fc" id="L623">    m_isDestroyer = getBool(s);</span>
<span class="fc" id="L624">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsDestroyer(final Boolean s) {
<span class="fc" id="L628">    m_isDestroyer = s;</span>
<span class="fc" id="L629">  }</span>

  public boolean getIsDestroyer() {
<span class="fc" id="L632">    return m_isDestroyer;</span>
  }

  public void resetIsDestroyer() {
<span class="nc" id="L636">    m_isDestroyer = false;</span>
<span class="nc" id="L637">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanBombard(final String s) {
<span class="fc" id="L641">    m_canBombard = getBool(s);</span>
<span class="fc" id="L642">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanBombard(final Boolean s) {
<span class="nc" id="L646">    m_canBombard = s;</span>
<span class="nc" id="L647">  }</span>

  public boolean getCanBombard(final PlayerID player) {
<span class="fc bfc" id="L650" title="All 2 branches covered.">    if (m_canBombard) {</span>
<span class="fc" id="L651">      return true;</span>
    }
<span class="fc" id="L653">    return TechAbilityAttachment.getUnitAbilitiesGained(TechAbilityAttachment.ABILITY_CAN_BOMBARD,</span>
<span class="fc" id="L654">        (UnitType) this.getAttachedTo(), player, getData());</span>
  }

  public void resetCanBombard() {
<span class="nc" id="L658">    m_canBombard = false;</span>
<span class="nc" id="L659">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsAir(final String s) {
<span class="fc" id="L663">    m_isAir = getBool(s);</span>
<span class="fc" id="L664">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsAir(final Boolean s) {
<span class="fc" id="L668">    m_isAir = s;</span>
<span class="fc" id="L669">  }</span>

  public boolean getIsAir() {
<span class="fc" id="L672">    return m_isAir;</span>
  }

  public void resetIsAir() {
<span class="nc" id="L676">    m_isAir = false;</span>
<span class="nc" id="L677">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsSea(final String s) {
<span class="fc" id="L681">    m_isSea = getBool(s);</span>
<span class="fc" id="L682">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsSea(final Boolean s) {
<span class="fc" id="L686">    m_isSea = s;</span>
<span class="fc" id="L687">  }</span>

  public boolean getIsSea() {
<span class="fc" id="L690">    return m_isSea;</span>
  }

  public void resetIsSea() {
<span class="nc" id="L694">    m_isSea = false;</span>
<span class="nc" id="L695">  }</span>

  // DO NOT REMOVE, this is an important convenience method for xmls
  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsFactory(final String s) {
<span class="fc" id="L700">    setIsFactory(getBool(s));</span>
<span class="fc" id="L701">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsFactory(final Boolean s) {
<span class="fc" id="L705">    setCanBeDamaged(s);</span>
<span class="fc" id="L706">    setIsInfrastructure(s);</span>
<span class="fc" id="L707">    setCanProduceUnits(s);</span>
<span class="fc" id="L708">    setIsConstruction(s);</span>
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">    if (s) {</span>
<span class="fc" id="L710">      setConstructionType(Constants.CONSTRUCTION_TYPE_FACTORY);</span>
<span class="fc" id="L711">      setMaxConstructionsPerTypePerTerr(&quot;1&quot;);</span>
<span class="fc" id="L712">      setConstructionsPerTerrPerTypePerTurn(&quot;1&quot;);</span>
<span class="fc" id="L713">    } else {</span>
      // return to defaults
<span class="nc" id="L715">      setConstructionType(&quot;none&quot;);</span>
<span class="nc" id="L716">      setMaxConstructionsPerTypePerTerr(&quot;-1&quot;);</span>
<span class="nc" id="L717">      setConstructionsPerTerrPerTypePerTurn(&quot;-1&quot;);</span>
    }
<span class="fc" id="L719">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanProduceUnits(final String s) {
<span class="fc" id="L723">    m_canProduceUnits = getBool(s);</span>
<span class="fc" id="L724">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanProduceUnits(final Boolean s) {
<span class="fc" id="L728">    m_canProduceUnits = s;</span>
<span class="fc" id="L729">  }</span>

  public boolean getCanProduceUnits() {
<span class="fc" id="L732">    return m_canProduceUnits;</span>
  }

  public void resetCanProduceUnits() {
<span class="nc" id="L736">    m_canProduceUnits = false;</span>
<span class="nc" id="L737">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanProduceXUnits(final String s) {
<span class="fc" id="L741">    m_canProduceXUnits = getInt(s);</span>
<span class="fc" id="L742">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanProduceXUnits(final Integer s) {
<span class="fc" id="L746">    m_canProduceXUnits = s;</span>
<span class="fc" id="L747">  }</span>

  public int getCanProduceXUnits() {
<span class="fc" id="L750">    return m_canProduceXUnits;</span>
  }

  public void resetCanProduceXUnits() {
<span class="nc" id="L754">    m_canProduceXUnits = -1;</span>
<span class="nc" id="L755">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanOnlyBePlacedInTerritoryValuedAtX(final String s) {
<span class="fc" id="L759">    m_canOnlyBePlacedInTerritoryValuedAtX = getInt(s);</span>
<span class="fc" id="L760">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanOnlyBePlacedInTerritoryValuedAtX(final Integer s) {
<span class="fc" id="L764">    m_canOnlyBePlacedInTerritoryValuedAtX = s;</span>
<span class="fc" id="L765">  }</span>

  public int getCanOnlyBePlacedInTerritoryValuedAtX() {
<span class="fc" id="L768">    return m_canOnlyBePlacedInTerritoryValuedAtX;</span>
  }

  public void resetCanOnlyBePlacedInTerritoryValuedAtX() {
<span class="nc" id="L772">    m_canOnlyBePlacedInTerritoryValuedAtX = -1;</span>
<span class="nc" id="L773">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setUnitPlacementRestrictions(final String value) {
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L778">      m_unitPlacementRestrictions = null;</span>
<span class="nc" id="L779">      return;</span>
    }
<span class="fc" id="L781">    m_unitPlacementRestrictions = value.split(&quot;:&quot;);</span>
<span class="fc" id="L782">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setUnitPlacementRestrictions(final String[] value) {
<span class="nc" id="L786">    m_unitPlacementRestrictions = value;</span>
<span class="nc" id="L787">  }</span>

  public String[] getUnitPlacementRestrictions() {
<span class="nc" id="L790">    return m_unitPlacementRestrictions;</span>
  }

  public void resetUnitPlacementRestrictions() {
<span class="nc" id="L794">    m_unitPlacementRestrictions = null;</span>
<span class="nc" id="L795">  }</span>

  // no m_ variable for this, since it is the inverse of m_unitPlacementRestrictions
  // we might as well just use m_unitPlacementRestrictions
  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setUnitPlacementOnlyAllowedIn(final String value) throws GameParseException {
<span class="nc" id="L801">    final Collection&lt;Territory&gt; allowedTerritories = getListedTerritories(value.split(&quot;:&quot;));</span>
<span class="nc" id="L802">    final Collection&lt;Territory&gt; restrictedTerritories = new HashSet&lt;&gt;(getData().getMap().getTerritories());</span>
<span class="nc" id="L803">    restrictedTerritories.removeAll(allowedTerritories);</span>
<span class="nc" id="L804">    m_unitPlacementRestrictions = restrictedTerritories.stream()</span>
<span class="nc" id="L805">        .map(Territory::getName)</span>
<span class="nc" id="L806">        .toArray(size -&gt; new String[size]);</span>
<span class="nc" id="L807">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setRepairsUnits(final String value) throws GameParseException {
<span class="fc" id="L811">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L812" title="1 of 2 branches missed.">    if (s.length &lt;= 0) {</span>
<span class="nc" id="L813">      throw new GameParseException(&quot;repairsUnits cannot be empty&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L815">    int amount = 1;</span>
<span class="fc" id="L816">    int i = 0;</span>
    try {
<span class="nc" id="L818">      amount = Integer.parseInt(s[0]);</span>
<span class="nc" id="L819">      i++;</span>
<span class="pc" id="L820">    } catch (final NumberFormatException nfe) {</span>
<span class="fc" id="L821">      amount = 1;</span>
    }
<span class="fc bfc" id="L823" title="All 2 branches covered.">    for (; i &lt; s.length; i++) {</span>
<span class="fc" id="L824">      final UnitType ut = getData().getUnitTypeList().getUnitType(s[i]);</span>
<span class="pc bpc" id="L825" title="1 of 2 branches missed.">      if (ut == null) {</span>
<span class="nc" id="L826">        throw new GameParseException(&quot;No unit called:&quot; + s[i] + thisErrorMsg());</span>
      }
<span class="fc" id="L828">      m_repairsUnits.put(ut, amount);</span>
    }
<span class="fc" id="L830">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setRepairsUnits(final IntegerMap&lt;UnitType&gt; value) {
<span class="nc" id="L834">    m_repairsUnits = value;</span>
<span class="nc" id="L835">  }</span>

  public IntegerMap&lt;UnitType&gt; getRepairsUnits() {
<span class="nc" id="L838">    return m_repairsUnits;</span>
  }

  public void clearRepairsUnits() {
<span class="nc" id="L842">    m_repairsUnits.clear();</span>
<span class="nc" id="L843">  }</span>

  public void resetRepairsUnits() {
<span class="nc" id="L846">    m_repairsUnits = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L847">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   *
   * @param value
   * @throws GameParseException
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setSpecial(final String value) throws GameParseException {
<span class="fc" id="L857">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="fc bfc" id="L858" title="All 2 branches covered.">    for (final String option : s) {</span>
<span class="pc bpc" id="L859" title="2 of 4 branches missed.">      if (!(option.equals(&quot;none&quot;) || option.equals(&quot;canOnlyPlaceInOriginalTerritories&quot;))) {</span>
<span class="nc" id="L860">        throw new GameParseException(&quot;special does not allow: &quot; + option + thisErrorMsg());</span>
      }
<span class="fc" id="L862">      m_special.add(option);</span>
    }
<span class="fc" id="L864">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setSpecial(final HashSet&lt;String&gt; value) {
<span class="nc" id="L868">    m_special = value;</span>
<span class="nc" id="L869">  }</span>

  public HashSet&lt;String&gt; getSpecial() {
<span class="nc" id="L872">    return m_special;</span>
  }

  public void clearSpecial() {
<span class="nc" id="L876">    m_special.clear();</span>
<span class="nc" id="L877">  }</span>

  public void resetSpecial() {
<span class="nc" id="L880">    m_special = new HashSet&lt;&gt;();</span>
<span class="nc" id="L881">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanInvadeOnlyFrom(final String value) {
<span class="pc bpc" id="L885" title="1 of 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L886">      m_canInvadeOnlyFrom = null;</span>
<span class="nc" id="L887">      return;</span>
    }
<span class="fc" id="L889">    final String[] canOnlyInvadeFrom = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">    if (canOnlyInvadeFrom[0].toLowerCase().equals(&quot;none&quot;)) {</span>
<span class="nc" id="L891">      m_canInvadeOnlyFrom = new String[] {&quot;none&quot;};</span>
<span class="nc" id="L892">      return;</span>
    }
<span class="pc bpc" id="L894" title="1 of 2 branches missed.">    if (canOnlyInvadeFrom[0].toLowerCase().equals(&quot;all&quot;)) {</span>
<span class="nc" id="L895">      m_canInvadeOnlyFrom = new String[] {&quot;all&quot;};</span>
<span class="nc" id="L896">      return;</span>
    }
<span class="fc" id="L898">    m_canInvadeOnlyFrom = canOnlyInvadeFrom;</span>
<span class="fc" id="L899">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanInvadeOnlyFrom(final String[] value) {
<span class="nc" id="L903">    m_canInvadeOnlyFrom = value;</span>
<span class="nc" id="L904">  }</span>

  public boolean canInvadeFrom(final String transport) {
<span class="fc" id="L907">    final UnitType ut = getData().getUnitTypeList().getUnitType(transport);</span>
<span class="pc bpc" id="L908" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L909">      throw new IllegalStateException(&quot;No unit called:&quot; + transport + thisErrorMsg());</span>
    }
    // (UnitAttachment) ut.getAttachments().values().iterator().next();
    // UnitAttachment ua = UnitAttachment.get(ut);
    // Units may be considered transported if they are on a carrier, or if they are paratroopers, or if they are mech
    // infantry. The
    // &quot;transporter&quot; may not be an actual transport, so we should not check for that here.
<span class="pc bpc" id="L916" title="5 of 6 branches missed.">    if (m_canInvadeOnlyFrom == null || Arrays.asList(m_canInvadeOnlyFrom).isEmpty() || m_canInvadeOnlyFrom[0].equals(&quot;&quot;)</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">        || m_canInvadeOnlyFrom[0].equals(&quot;all&quot;)) {</span>
<span class="fc" id="L918">      return true;</span>
    }
<span class="nc" id="L920">    return Arrays.asList(m_canInvadeOnlyFrom).contains(transport);</span>
  }

  public void resetCanInvadeOnlyFrom() {
<span class="nc" id="L924">    m_canInvadeOnlyFrom = null;</span>
<span class="nc" id="L925">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   *
   * @param value
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setRequiresUnits(final String value) {
<span class="fc" id="L934">    m_requiresUnits.add(value.split(&quot;:&quot;));</span>
<span class="fc" id="L935">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setRequiresUnits(final ArrayList&lt;String[]&gt; value) {
<span class="nc" id="L939">    m_requiresUnits = value;</span>
<span class="nc" id="L940">  }</span>

  public ArrayList&lt;String[]&gt; getRequiresUnits() {
<span class="fc" id="L943">    return m_requiresUnits;</span>
  }

  public void clearRequiresUnits() {
<span class="nc" id="L947">    m_requiresUnits.clear();</span>
<span class="nc" id="L948">  }</span>

  public void resetRequiresUnits() {
<span class="nc" id="L951">    m_requiresUnits = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L952">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   *
   * @param value
   * @throws GameParseException
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setWhenCombatDamaged(final String value) throws GameParseException {
<span class="fc" id="L962">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L963" title="3 of 4 branches missed.">    if (!(s.length == 3 || s.length == 4)) {</span>
<span class="nc" id="L964">      throw new GameParseException(</span>
<span class="nc" id="L965">          &quot;whenCombatDamaged must have 3 or 4 parts: value=effect:optionalNumber, count=integer:integer&quot;</span>
<span class="nc" id="L966">              + thisErrorMsg());</span>
    }
<span class="fc" id="L968">    final int from = getInt(s[0]);</span>
<span class="fc" id="L969">    final int to = getInt(s[1]);</span>
<span class="pc bpc" id="L970" title="3 of 6 branches missed.">    if (from &lt; 0 || to &lt; 0 || to &lt; from) {</span>
<span class="nc" id="L971">      throw new GameParseException(</span>
<span class="nc" id="L972">          &quot;whenCombatDamaged damaged integers must be positive, and the second integer must be equal to or greater than the first&quot;</span>
<span class="nc" id="L973">              + thisErrorMsg());</span>
    }
<span class="fc" id="L975">    final Tuple&lt;Integer, Integer&gt; fromTo = Tuple.of(from, to);</span>
    Tuple&lt;String, String&gt; effectNum;
<span class="pc bpc" id="L977" title="1 of 2 branches missed.">    if (s.length == 3) {</span>
<span class="fc" id="L978">      effectNum = Tuple.of(s[2], null);</span>
<span class="fc" id="L979">    } else {</span>
<span class="nc" id="L980">      effectNum = Tuple.of(s[2], s[3]);</span>
    }
<span class="fc" id="L982">    m_whenCombatDamaged.add(Tuple.of(fromTo, effectNum));</span>
<span class="fc" id="L983">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setWhenCombatDamaged(final ArrayList&lt;Tuple&lt;Tuple&lt;Integer, Integer&gt;, Tuple&lt;String, String&gt;&gt;&gt; value) {
<span class="nc" id="L987">    m_whenCombatDamaged = value;</span>
<span class="nc" id="L988">  }</span>

  public ArrayList&lt;Tuple&lt;Tuple&lt;Integer, Integer&gt;, Tuple&lt;String, String&gt;&gt;&gt; getWhenCombatDamaged() {
<span class="fc" id="L991">    return m_whenCombatDamaged;</span>
  }

  public void clearWhenCombatDamaged() {
<span class="nc" id="L995">    m_whenCombatDamaged.clear();</span>
<span class="nc" id="L996">  }</span>

  public void resetWhenCombatDamaged() {
<span class="nc" id="L999">    m_whenCombatDamaged = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1000">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   *
   * @param value
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setReceivesAbilityWhenWith(final String value) {
<span class="fc" id="L1009">    m_receivesAbilityWhenWith.add(value);</span>
<span class="fc" id="L1010">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setReceivesAbilityWhenWith(final ArrayList&lt;String&gt; value) {
<span class="nc" id="L1014">    m_receivesAbilityWhenWith = value;</span>
<span class="nc" id="L1015">  }</span>

  public ArrayList&lt;String&gt; getReceivesAbilityWhenWith() {
<span class="fc" id="L1018">    return m_receivesAbilityWhenWith;</span>
  }

  public void clearReceivesAbilityWhenWith() {
<span class="nc" id="L1022">    m_receivesAbilityWhenWith.clear();</span>
<span class="nc" id="L1023">  }</span>

  public void resetReceivesAbilityWhenWith() {
<span class="nc" id="L1026">    m_receivesAbilityWhenWith = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1027">  }</span>

  private static IntegerMap&lt;Tuple&lt;String, String&gt;&gt; getReceivesAbilityWhenWithMap(final Collection&lt;Unit&gt; units,
      final String filterForAbility, final GameData data) {
<span class="nc" id="L1031">    final IntegerMap&lt;Tuple&lt;String, String&gt;&gt; map = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L1032">    final Collection&lt;UnitType&gt; canReceive =</span>
<span class="nc" id="L1033">        getUnitTypesFromUnitList(Match.getMatches(units, Matches.UnitCanReceivesAbilityWhenWith()));</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">    for (final UnitType ut : canReceive) {</span>
<span class="nc" id="L1035">      final Collection&lt;String&gt; receives = UnitAttachment.get(ut).getReceivesAbilityWhenWith();</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">      for (final String receive : receives) {</span>
<span class="nc" id="L1037">        final String[] s = receive.split(&quot;:&quot;);</span>
<span class="nc bnc" id="L1038" title="All 4 branches missed.">        if (filterForAbility != null &amp;&amp; !filterForAbility.equals(s[0])) {</span>
<span class="nc" id="L1039">          continue;</span>
        }
<span class="nc" id="L1041">        map.put(Tuple.of(s[0], s[1]),</span>
<span class="nc" id="L1042">            Match.countMatches(units, Matches.unitIsOfType(data.getUnitTypeList().getUnitType(s[1]))));</span>
      }
    }
<span class="nc" id="L1045">    return map;</span>
  }

  public static Collection&lt;Unit&gt; getUnitsWhichReceivesAbilityWhenWith(final Collection&lt;Unit&gt; units,
      final String filterForAbility, final GameData data) {
<span class="pc bpc" id="L1050" title="1 of 2 branches missed.">    if (Match.noneMatch(units, Matches.UnitCanReceivesAbilityWhenWith())) {</span>
<span class="fc" id="L1051">      return new ArrayList&lt;&gt;();</span>
    }
<span class="nc" id="L1053">    final Collection&lt;Unit&gt; unitsCopy = new ArrayList&lt;&gt;(units);</span>
<span class="nc" id="L1054">    final HashSet&lt;Unit&gt; whichReceiveNoDuplicates = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1055">    final IntegerMap&lt;Tuple&lt;String, String&gt;&gt; whichGive =</span>
<span class="nc" id="L1056">        getReceivesAbilityWhenWithMap(unitsCopy, filterForAbility, data);</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">    for (final Tuple&lt;String, String&gt; abilityUnitType : whichGive.keySet()) {</span>
<span class="nc" id="L1058">      final Collection&lt;Unit&gt; receives = Match.getNMatches(unitsCopy, whichGive.getInt(abilityUnitType),</span>
<span class="nc" id="L1059">          Matches.UnitCanReceivesAbilityWhenWith(filterForAbility, abilityUnitType.getSecond()));</span>
<span class="nc" id="L1060">      whichReceiveNoDuplicates.addAll(receives);</span>
<span class="nc" id="L1061">      unitsCopy.removeAll(receives);</span>
    }
<span class="nc" id="L1063">    return whichReceiveNoDuplicates;</span>
  }

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsConstruction(final String s) {
<span class="fc" id="L1068">    m_isConstruction = getBool(s);</span>
<span class="fc" id="L1069">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsConstruction(final Boolean s) {
<span class="fc" id="L1073">    m_isConstruction = s;</span>
<span class="fc" id="L1074">  }</span>

  public boolean getIsConstruction() {
<span class="fc" id="L1077">    return m_isConstruction;</span>
  }

  public void resetIsConstruction() {
<span class="nc" id="L1081">    m_isConstruction = false;</span>
<span class="nc" id="L1082">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setConstructionType(final String s) {
<span class="fc" id="L1086">    m_constructionType = s;</span>
<span class="fc" id="L1087">  }</span>

  public String getConstructionType() {
<span class="fc" id="L1090">    return m_constructionType;</span>
  }

  public void resetConstructionType() {
<span class="nc" id="L1094">    m_constructionType = &quot;none&quot;;</span>
<span class="nc" id="L1095">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setConstructionsPerTerrPerTypePerTurn(final String s) {
<span class="fc" id="L1099">    m_constructionsPerTerrPerTypePerTurn = getInt(s);</span>
<span class="fc" id="L1100">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setConstructionsPerTerrPerTypePerTurn(final Integer s) {
<span class="fc" id="L1104">    m_constructionsPerTerrPerTypePerTurn = s;</span>
<span class="fc" id="L1105">  }</span>

  public int getConstructionsPerTerrPerTypePerTurn() {
<span class="fc" id="L1108">    return m_constructionsPerTerrPerTypePerTurn;</span>
  }

  public void resetConstructionsPerTerrPerTypePerTurn() {
<span class="nc" id="L1112">    m_constructionsPerTerrPerTypePerTurn = -1;</span>
<span class="nc" id="L1113">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMaxConstructionsPerTypePerTerr(final String s) {
<span class="fc" id="L1117">    m_maxConstructionsPerTypePerTerr = getInt(s);</span>
<span class="fc" id="L1118">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMaxConstructionsPerTypePerTerr(final Integer s) {
<span class="fc" id="L1122">    m_maxConstructionsPerTypePerTerr = s;</span>
<span class="fc" id="L1123">  }</span>

  public int getMaxConstructionsPerTypePerTerr() {
<span class="fc" id="L1126">    return m_maxConstructionsPerTypePerTerr;</span>
  }

  public void resetMaxConstructionsPerTypePerTerr() {
<span class="nc" id="L1130">    m_maxConstructionsPerTypePerTerr = -1;</span>
<span class="nc" id="L1131">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsMarine(final String s) {
<span class="fc bfc" id="L1135" title="All 2 branches covered.">    if (s.equalsIgnoreCase(Constants.PROPERTY_TRUE)) {</span>
<span class="fc" id="L1136">      m_isMarine = 1;</span>
<span class="pc bpc" id="L1137" title="1 of 2 branches missed.">    } else if (s.equalsIgnoreCase(Constants.PROPERTY_FALSE)) {</span>
<span class="nc" id="L1138">      m_isMarine = 0;</span>
<span class="nc" id="L1139">    } else {</span>
<span class="fc" id="L1140">      m_isMarine = getInt(s);</span>
    }
<span class="fc" id="L1142">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsMarine(final Integer s) {
<span class="fc" id="L1146">    m_isMarine = s;</span>
<span class="fc" id="L1147">  }</span>

  public int getIsMarine() {
<span class="fc" id="L1150">    return m_isMarine;</span>
  }

  public void resetIsMarine() {
<span class="nc" id="L1154">    m_isMarine = 0;</span>
<span class="nc" id="L1155">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsInfantry(final String s) {
<span class="fc" id="L1159">    m_isInfantry = getBool(s);</span>
<span class="fc" id="L1160">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsInfantry(final Boolean s) {
<span class="fc" id="L1164">    m_isInfantry = s;</span>
<span class="fc" id="L1165">  }</span>

  public boolean getIsInfantry() {
<span class="fc" id="L1168">    return m_isInfantry;</span>
  }

  public void resetIsInfantry() {
<span class="nc" id="L1172">    m_isInfantry = false;</span>
<span class="nc" id="L1173">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsLandTransport(final String s) {
<span class="fc" id="L1177">    m_isLandTransport = getBool(s);</span>
<span class="fc" id="L1178">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsLandTransport(final Boolean s) {
<span class="fc" id="L1182">    m_isLandTransport = s;</span>
<span class="fc" id="L1183">  }</span>

  public boolean isLandTransport() {
<span class="nc" id="L1186">    return m_isLandTransport;</span>
  }

  public boolean getIsLandTransport() {
<span class="fc" id="L1190">    return m_isLandTransport;</span>
  }

  public void resetIsLandTransport() {
<span class="nc" id="L1194">    m_isLandTransport = false;</span>
<span class="nc" id="L1195">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setTransportCapacity(final String s) {
<span class="fc" id="L1199">    m_transportCapacity = getInt(s);</span>
<span class="fc" id="L1200">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setTransportCapacity(final Integer s) {
<span class="fc" id="L1204">    m_transportCapacity = s;</span>
<span class="fc" id="L1205">  }</span>

  public int getTransportCapacity() {
<span class="fc" id="L1208">    return m_transportCapacity;</span>
  }

  public void resetTransportCapacity() {
<span class="nc" id="L1212">    m_transportCapacity = -1;</span>
<span class="nc" id="L1213">  }</span>

  /**
   * DO NOT REMOVE
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsTwoHit(final String s) {
<span class="nc bnc" id="L1220" title="All 2 branches missed.">    m_hitPoints = getBool(s) ? 2 : 1;</span>
<span class="nc" id="L1221">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setHitPoints(final String s) {
<span class="fc" id="L1225">    m_hitPoints = getInt(s);</span>
<span class="fc" id="L1226">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setHitPoints(final Integer value) {
<span class="fc" id="L1230">    m_hitPoints = value;</span>
<span class="fc" id="L1231">  }</span>

  public int getHitPoints() {
<span class="fc" id="L1234">    return m_hitPoints;</span>
  }

  public void resetHitPoints() {
<span class="nc" id="L1238">    m_hitPoints = 1;</span>
<span class="nc" id="L1239">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setTransportCost(final String s) {
<span class="fc" id="L1243">    m_transportCost = getInt(s);</span>
<span class="fc" id="L1244">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setTransportCost(final Integer s) {
<span class="fc" id="L1248">    m_transportCost = s;</span>
<span class="fc" id="L1249">  }</span>

  public int getTransportCost() {
<span class="fc" id="L1252">    return m_transportCost;</span>
  }

  public void resetTransportCost() {
<span class="nc" id="L1256">    m_transportCost = -1;</span>
<span class="nc" id="L1257">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMaxBuiltPerPlayer(final String s) {
<span class="fc" id="L1261">    m_maxBuiltPerPlayer = getInt(s);</span>
<span class="fc" id="L1262">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMaxBuiltPerPlayer(final Integer s) {
<span class="fc" id="L1266">    m_maxBuiltPerPlayer = s;</span>
<span class="fc" id="L1267">  }</span>

  public int getMaxBuiltPerPlayer() {
<span class="fc" id="L1270">    return m_maxBuiltPerPlayer;</span>
  }

  public void resetMaxBuiltPerPlayer() {
<span class="nc" id="L1274">    m_maxBuiltPerPlayer = -1;</span>
<span class="nc" id="L1275">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCarrierCapacity(final String s) {
<span class="fc" id="L1279">    m_carrierCapacity = getInt(s);</span>
<span class="fc" id="L1280">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCarrierCapacity(final Integer s) {
<span class="fc" id="L1284">    m_carrierCapacity = s;</span>
<span class="fc" id="L1285">  }</span>

  public int getCarrierCapacity() {
<span class="fc" id="L1288">    return m_carrierCapacity;</span>
  }

  public void resetCarrierCapacity() {
<span class="nc" id="L1292">    m_carrierCapacity = -1;</span>
<span class="nc" id="L1293">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCarrierCost(final String s) {
<span class="fc" id="L1297">    m_carrierCost = getInt(s);</span>
<span class="fc" id="L1298">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCarrierCost(final Integer s) {
<span class="fc" id="L1302">    m_carrierCost = s;</span>
<span class="fc" id="L1303">  }</span>

  public int getCarrierCost() {
<span class="fc" id="L1306">    return m_carrierCost;</span>
  }

  public void resetCarrierCost() {
<span class="nc" id="L1310">    m_carrierCost = -1;</span>
<span class="nc" id="L1311">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = false, adds = false)
  public void setArtillery(final String s) throws GameParseException {
<span class="fc" id="L1315">    m_artillery = getBool(s);</span>
<span class="pc bpc" id="L1316" title="1 of 2 branches missed.">    if (m_artillery) {</span>
<span class="fc" id="L1317">      UnitSupportAttachment.addRule((UnitType) getAttachedTo(), getData(), false);</span>
    }
<span class="fc" id="L1319">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = false, adds = false)
  public void setArtillery(final Boolean s) throws GameParseException {
<span class="fc" id="L1323">    m_artillery = s;</span>
<span class="pc bpc" id="L1324" title="1 of 2 branches missed.">    if (m_artillery) {</span>
<span class="nc" id="L1325">      UnitSupportAttachment.addRule((UnitType) getAttachedTo(), getData(), false);</span>
    }
<span class="nc" id="L1327">  }</span>

  public boolean getArtillery() {
<span class="fc" id="L1330">    return m_artillery;</span>
  }

  public void resetArtillery() {
<span class="nc" id="L1334">    throw new IllegalStateException(</span>
<span class="nc" id="L1335">        &quot;Resetting Artillery (UnitAttachment) is not allowed, please use Support Attachments instead.&quot;);</span>
  }

  @GameProperty(xmlProperty = true, gameProperty = false, adds = false)
  public void setArtillerySupportable(final String s) throws GameParseException {
<span class="fc" id="L1340">    m_artillerySupportable = getBool(s);</span>
<span class="pc bpc" id="L1341" title="1 of 2 branches missed.">    if (m_artillerySupportable) {</span>
<span class="fc" id="L1342">      UnitSupportAttachment.addTarget((UnitType) getAttachedTo(), getData());</span>
    }
<span class="fc" id="L1344">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = false, adds = false)
  public void setArtillerySupportable(final Boolean s) throws GameParseException {
<span class="fc" id="L1348">    m_artillerySupportable = s;</span>
<span class="pc bpc" id="L1349" title="1 of 2 branches missed.">    if (m_artillerySupportable) {</span>
<span class="nc" id="L1350">      UnitSupportAttachment.addTarget((UnitType) getAttachedTo(), getData());</span>
    }
<span class="nc" id="L1352">  }</span>

  public boolean getArtillerySupportable() {
<span class="nc" id="L1355">    return m_artillerySupportable;</span>
  }

  public void resetArtillerySupportable() {
<span class="nc" id="L1359">    throw new IllegalStateException(</span>
<span class="nc" id="L1360">        &quot;Resetting Artillery Supportable (UnitAttachment) is not allowed, please use Support Attachments instead.&quot;);</span>
  }

  @GameProperty(xmlProperty = true, gameProperty = false, adds = false)
  public void setUnitSupportCount(final String s) {
<span class="fc" id="L1365">    m_unitSupportCount = getInt(s);</span>
<span class="fc" id="L1366">    UnitSupportAttachment.setOldSupportCount((UnitType) getAttachedTo(), getData(), s);</span>
<span class="fc" id="L1367">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = false, adds = false)
  public void setUnitSupportCount(final Integer s) {
<span class="fc" id="L1371">    m_unitSupportCount = s;</span>
<span class="nc" id="L1372">    UnitSupportAttachment.setOldSupportCount((UnitType) getAttachedTo(), getData(), s.toString());</span>
<span class="nc" id="L1373">  }</span>

  public int getUnitSupportCount() {
<span class="nc bnc" id="L1376" title="All 2 branches missed.">    return m_unitSupportCount &gt; 0 ? m_unitSupportCount : 1;</span>
  }

  public void resetUnitSupportCount() {
<span class="nc" id="L1380">    throw new IllegalStateException(</span>
<span class="nc" id="L1381">        &quot;Resetting Artillery Support Count (UnitAttachment) is not allowed, please use Support Attachments instead.&quot;);</span>
  }

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setBombard(final String s) {
<span class="fc" id="L1386">    m_bombard = getInt(s);</span>
<span class="fc" id="L1387">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setBombard(final Integer s) {
<span class="nc" id="L1391">    m_bombard = s;</span>
<span class="nc" id="L1392">  }</span>

  public int getBombard(final PlayerID player) {
<span class="fc bfc" id="L1395" title="All 2 branches covered.">    return m_bombard &gt; 0 ? m_bombard : m_attack;</span>
  }

  public void resetBombard() {
<span class="nc" id="L1399">    m_bombard = -1;</span>
<span class="nc" id="L1400">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMovement(final String s) {
<span class="fc" id="L1404">    m_movement = getInt(s);</span>
<span class="fc" id="L1405">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMovement(final Integer s) {
<span class="nc" id="L1409">    m_movement = s;</span>
<span class="nc" id="L1410">  }</span>

  public int getMovement(final PlayerID player) {
<span class="fc" id="L1413">    return Math.max(0,</span>
<span class="fc" id="L1414">        m_movement + TechAbilityAttachment.getMovementBonus((UnitType) this.getAttachedTo(), player, getData()));</span>
  }

  public void resetMovement() {
<span class="nc" id="L1418">    m_movement = 0;</span>
<span class="nc" id="L1419">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAttack(final String s) {
<span class="fc" id="L1423">    m_attack = getInt(s);</span>
<span class="fc" id="L1424">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAttack(final int s) {
<span class="nc" id="L1428">    m_attack = s;</span>
<span class="nc" id="L1429">  }</span>

  public int getAttack(final PlayerID player) {
<span class="fc" id="L1432">    int attackValue =</span>
<span class="fc" id="L1433">        m_attack + TechAbilityAttachment.getAttackBonus((UnitType) this.getAttachedTo(), player, getData());</span>
<span class="pc bpc" id="L1434" title="1 of 4 branches missed.">    if (attackValue &gt; 0 &amp;&amp; player.isAI()) {</span>
<span class="nc" id="L1435">      attackValue += games.strategy.triplea.Properties.getAIBonusAttack(getData());</span>
    }
<span class="fc" id="L1437">    return Math.min(getData().getDiceSides(), Math.max(0, attackValue));</span>
  }

  int getRawAttack() {
<span class="fc" id="L1441">    return m_attack;</span>
  }

  public void resetAttack() {
<span class="nc" id="L1445">    m_attack = 0;</span>
<span class="nc" id="L1446">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAttackRolls(final String s) {
<span class="nc" id="L1450">    m_attackRolls = getInt(s);</span>
<span class="nc" id="L1451">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAttackRolls(final Integer s) {
<span class="nc" id="L1455">    m_attackRolls = s;</span>
<span class="nc" id="L1456">  }</span>

  public int getAttackRolls(final PlayerID player) {
<span class="fc" id="L1459">    return Math.max(0,</span>
<span class="fc" id="L1460">        m_attackRolls + TechAbilityAttachment.getAttackRollsBonus((UnitType) this.getAttachedTo(), player, getData()));</span>
  }

  public void resetAttackRolls() {
<span class="nc" id="L1464">    m_attackRolls = 1;</span>
<span class="nc" id="L1465">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setDefense(final String s) {
<span class="fc" id="L1469">    m_defense = getInt(s);</span>
<span class="fc" id="L1470">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setDefense(final Integer s) {
<span class="nc" id="L1474">    m_defense = s;</span>
<span class="nc" id="L1475">  }</span>

  public int getDefense(final PlayerID player) {
<span class="fc" id="L1478">    int defenseValue =</span>
<span class="fc" id="L1479">        m_defense + TechAbilityAttachment.getDefenseBonus((UnitType) this.getAttachedTo(), player, getData());</span>
<span class="fc bfc" id="L1480" title="All 6 branches covered.">    if (defenseValue &gt; 0 &amp;&amp; m_isSub &amp;&amp; TechTracker.hasSuperSubs(player)) {</span>
<span class="fc" id="L1481">      final int bonus = games.strategy.triplea.Properties.getSuper_Sub_Defense_Bonus(getData());</span>
<span class="fc" id="L1482">      defenseValue += bonus;</span>
    }
<span class="pc bpc" id="L1484" title="1 of 4 branches missed.">    if (defenseValue &gt; 0 &amp;&amp; player.isAI()) {</span>
<span class="nc" id="L1485">      defenseValue += games.strategy.triplea.Properties.getAIBonusDefense(getData());</span>
    }
<span class="fc" id="L1487">    return Math.min(getData().getDiceSides(), Math.max(0, defenseValue));</span>
  }

  int getRawDefense() {
<span class="nc" id="L1491">    return m_defense;</span>
  }

  public void resetDefense() {
<span class="nc" id="L1495">    m_defense = 0;</span>
<span class="nc" id="L1496">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setDefenseRolls(final String s) {
<span class="nc" id="L1500">    m_defenseRolls = getInt(s);</span>
<span class="nc" id="L1501">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setDefenseRolls(final Integer s) {
<span class="nc" id="L1505">    m_defenseRolls = s;</span>
<span class="nc" id="L1506">  }</span>

  public int getDefenseRolls(final PlayerID player) {
<span class="fc" id="L1509">    return Math.max(0, m_defenseRolls</span>
<span class="fc" id="L1510">        + TechAbilityAttachment.getDefenseRollsBonus((UnitType) this.getAttachedTo(), player, getData()));</span>
  }

  public void resetDefenseRolls() {
<span class="nc" id="L1514">    m_defenseRolls = 1;</span>
<span class="nc" id="L1515">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setChooseBestRoll(final String s) {
<span class="fc" id="L1519">    m_chooseBestRoll = getBool(s);</span>
<span class="fc" id="L1520">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setChooseBestRoll(final Boolean s) {
<span class="fc" id="L1524">    m_chooseBestRoll = s;</span>
<span class="fc" id="L1525">  }</span>

  public boolean getChooseBestRoll() {
<span class="fc" id="L1528">    return m_chooseBestRoll;</span>
  }

  public void resetChooseBestRoll() {
<span class="nc" id="L1532">    m_chooseBestRoll = false;</span>
<span class="nc" id="L1533">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanScramble(final String s) {
<span class="fc" id="L1537">    m_canScramble = getBool(s);</span>
<span class="fc" id="L1538">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanScramble(final Boolean s) {
<span class="fc" id="L1542">    m_canScramble = s;</span>
<span class="fc" id="L1543">  }</span>

  public boolean getCanScramble() {
<span class="fc" id="L1546">    return m_canScramble;</span>
  }

  public void resetCanScramble() {
<span class="nc" id="L1550">    m_canScramble = false;</span>
<span class="nc" id="L1551">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMaxScrambleCount(final String s) {
<span class="fc" id="L1555">    m_maxScrambleCount = getInt(s);</span>
<span class="fc" id="L1556">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMaxScrambleCount(final Integer s) {
<span class="fc" id="L1560">    m_maxScrambleCount = s;</span>
<span class="fc" id="L1561">  }</span>

  public int getMaxScrambleCount() {
<span class="fc" id="L1564">    return m_maxScrambleCount;</span>
  }

  public void resetMaxScrambleCount() {
<span class="nc" id="L1568">    m_maxScrambleCount = -1;</span>
<span class="nc" id="L1569">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMaxScrambleDistance(final String s) {
<span class="fc" id="L1573">    m_maxScrambleDistance = getInt(s);</span>
<span class="fc" id="L1574">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMaxScrambleDistance(final Integer s) {
<span class="fc" id="L1578">    m_maxScrambleDistance = s;</span>
<span class="fc" id="L1579">  }</span>

  public int getMaxScrambleDistance() {
<span class="fc" id="L1582">    return m_maxScrambleDistance;</span>
  }

  public void resetMaxScrambleDistance() {
<span class="nc" id="L1586">    m_maxScrambleDistance = -1;</span>
<span class="nc" id="L1587">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMaxOperationalDamage(final String s) {
<span class="fc" id="L1591">    m_maxOperationalDamage = getInt(s);</span>
<span class="fc" id="L1592">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMaxOperationalDamage(final Integer s) {
<span class="fc" id="L1596">    m_maxOperationalDamage = s;</span>
<span class="fc" id="L1597">  }</span>

  public int getMaxOperationalDamage() {
<span class="fc" id="L1600">    return m_maxOperationalDamage;</span>
  }

  public void resetMaxOperationalDamage() {
<span class="nc" id="L1604">    m_maxOperationalDamage = -1;</span>
<span class="nc" id="L1605">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMaxDamage(final String s) {
<span class="fc" id="L1609">    m_maxDamage = getInt(s);</span>
<span class="fc" id="L1610">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMaxDamage(final Integer s) {
<span class="fc" id="L1614">    m_maxDamage = s;</span>
<span class="fc" id="L1615">  }</span>

  public int getMaxDamage() {
<span class="fc" id="L1618">    return m_maxDamage;</span>
  }

  public void resetMaxDamage() {
<span class="nc" id="L1622">    m_maxDamage = 2;</span>
<span class="nc" id="L1623">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsAirBase(final String s) {
<span class="fc" id="L1627">    m_isAirBase = getBool(s);</span>
<span class="fc" id="L1628">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsAirBase(final Boolean s) {
<span class="fc" id="L1632">    m_isAirBase = s;</span>
<span class="fc" id="L1633">  }</span>

  public boolean getIsAirBase() {
<span class="fc" id="L1636">    return m_isAirBase;</span>
  }

  public void resetIsAirBase() {
<span class="nc" id="L1640">    m_isAirBase = false;</span>
<span class="nc" id="L1641">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsInfrastructure(final String s) {
<span class="fc" id="L1645">    m_isInfrastructure = getBool(s);</span>
<span class="fc" id="L1646">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsInfrastructure(final Boolean s) {
<span class="fc" id="L1650">    m_isInfrastructure = s;</span>
<span class="fc" id="L1651">  }</span>

  public boolean getIsInfrastructure() {
<span class="fc" id="L1654">    return m_isInfrastructure;</span>
  }

  public void resetIsInfrastructure() {
<span class="nc" id="L1658">    m_isInfrastructure = false;</span>
<span class="nc" id="L1659">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanBeDamaged(final String s) {
<span class="fc" id="L1663">    m_canBeDamaged = getBool(s);</span>
<span class="fc" id="L1664">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanBeDamaged(final Boolean s) {
<span class="fc" id="L1668">    m_canBeDamaged = s;</span>
<span class="fc" id="L1669">  }</span>

  public boolean getCanBeDamaged() {
<span class="fc" id="L1672">    return m_canBeDamaged;</span>
  }

  public void resetCanBeDamaged() {
<span class="nc" id="L1676">    m_canBeDamaged = false;</span>
<span class="nc" id="L1677">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanDieFromReachingMaxDamage(final String s) {
<span class="fc" id="L1681">    m_canDieFromReachingMaxDamage = getBool(s);</span>
<span class="fc" id="L1682">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanDieFromReachingMaxDamage(final Boolean s) {
<span class="fc" id="L1686">    m_canDieFromReachingMaxDamage = s;</span>
<span class="fc" id="L1687">  }</span>

  public boolean getCanDieFromReachingMaxDamage() {
<span class="fc" id="L1690">    return m_canDieFromReachingMaxDamage;</span>
  }

  public void resetCanDieFromReachingMaxDamage() {
<span class="nc" id="L1694">    m_canDieFromReachingMaxDamage = false;</span>
<span class="nc" id="L1695">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsSuicide(final String s) {
<span class="fc" id="L1699">    m_isSuicide = getBool(s);</span>
<span class="fc" id="L1700">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsSuicide(final boolean s) {
<span class="fc" id="L1704">    m_isSuicide = s;</span>
<span class="fc" id="L1705">  }</span>

  public boolean getIsSuicide() {
<span class="fc" id="L1708">    return m_isSuicide;</span>
  }

  public void resetIsSuicide() {
<span class="nc" id="L1712">    m_isSuicide = false;</span>
<span class="nc" id="L1713">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsKamikaze(final String s) {
<span class="fc" id="L1717">    m_isKamikaze = getBool(s);</span>
<span class="fc" id="L1718">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsKamikaze(final boolean s) {
<span class="fc" id="L1722">    m_isKamikaze = s;</span>
<span class="fc" id="L1723">  }</span>

  public boolean getIsKamikaze() {
<span class="fc" id="L1726">    return m_isKamikaze;</span>
  }

  public void resetIsKamikaze() {
<span class="nc" id="L1730">    m_isKamikaze = false;</span>
<span class="nc" id="L1731">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setBlockade(final String s) {
<span class="fc" id="L1735">    m_blockade = getInt(s);</span>
<span class="fc" id="L1736">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setBlockade(final int s) {
<span class="fc" id="L1740">    m_blockade = s;</span>
<span class="fc" id="L1741">  }</span>

  public int getBlockade() {
<span class="fc" id="L1744">    return m_blockade;</span>
  }

  public void resetBlockade() {
<span class="nc" id="L1748">    m_blockade = 0;</span>
<span class="nc" id="L1749">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   *
   * @param value
   * @throws GameParseException
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setGivesMovement(final String value) throws GameParseException {
<span class="fc" id="L1759">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L1760" title="2 of 4 branches missed.">    if (s.length &lt;= 0 || s.length &gt; 2) {</span>
<span class="nc" id="L1761">      throw new GameParseException(&quot;givesMovement cannot be empty or have more than two fields&quot; + thisErrorMsg());</span>
    }
    String unitTypeToProduce;
<span class="fc" id="L1764">    unitTypeToProduce = s[1];</span>
    // validate that this unit exists in the xml
<span class="fc" id="L1766">    final UnitType ut = getData().getUnitTypeList().getUnitType(unitTypeToProduce);</span>
<span class="pc bpc" id="L1767" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L1768">      throw new GameParseException(&quot;No unit called:&quot; + unitTypeToProduce + thisErrorMsg());</span>
    }
    // we should allow positive and negative numbers, since you can give bonuses to units or take away a unit's movement
<span class="fc" id="L1771">    final int n = getInt(s[0]);</span>
<span class="fc" id="L1772">    m_givesMovement.put(ut, n);</span>
<span class="fc" id="L1773">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setGivesMovement(final IntegerMap&lt;UnitType&gt; value) {
<span class="nc" id="L1777">    m_givesMovement = value;</span>
<span class="nc" id="L1778">  }</span>

  public IntegerMap&lt;UnitType&gt; getGivesMovement() {
<span class="fc" id="L1781">    return m_givesMovement;</span>
  }

  public void clearGivesMovement() {
<span class="nc" id="L1785">    m_givesMovement.clear();</span>
<span class="nc" id="L1786">  }</span>

  public void resetGivesMovement() {
<span class="nc" id="L1789">    m_givesMovement = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L1790">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   *
   * @param value
   * @throws GameParseException
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setConsumesUnits(final String value) throws GameParseException {
<span class="fc" id="L1800">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L1801" title="1 of 2 branches missed.">    if (s.length != 2) {</span>
<span class="nc" id="L1802">      throw new GameParseException(&quot;consumesUnits must have two fields&quot; + thisErrorMsg());</span>
    }
    String unitTypeToProduce;
<span class="fc" id="L1805">    unitTypeToProduce = s[1];</span>
    // validate that this unit exists in the xml
<span class="fc" id="L1807">    final UnitType ut = getData().getUnitTypeList().getUnitType(unitTypeToProduce);</span>
<span class="pc bpc" id="L1808" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L1809">      throw new GameParseException(&quot;No unit called:&quot; + unitTypeToProduce + thisErrorMsg());</span>
    }
<span class="fc" id="L1811">    final int n = getInt(s[0]);</span>
<span class="pc bpc" id="L1812" title="1 of 2 branches missed.">    if (n &lt; 1) {</span>
<span class="nc" id="L1813">      throw new GameParseException(&quot;consumesUnits must have positive values&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L1815">    m_consumesUnits.put(ut, n);</span>
<span class="fc" id="L1816">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setConsumesUnits(final IntegerMap&lt;UnitType&gt; value) {
<span class="nc" id="L1820">    m_consumesUnits = value;</span>
<span class="nc" id="L1821">  }</span>

  public IntegerMap&lt;UnitType&gt; getConsumesUnits() {
<span class="fc" id="L1824">    return m_consumesUnits;</span>
  }

  public void clearConsumesUnits() {
<span class="nc" id="L1828">    m_consumesUnits.clear();</span>
<span class="nc" id="L1829">  }</span>

  public void resetConsumesUnits() {
<span class="nc" id="L1832">    m_consumesUnits = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L1833">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   *
   * @param value
   * @throws GameParseException
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setCreatesUnitsList(final String value) throws GameParseException {
<span class="nc" id="L1843">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="nc bnc" id="L1844" title="All 4 branches missed.">    if (s.length &lt;= 0 || s.length &gt; 2) {</span>
<span class="nc" id="L1845">      throw new GameParseException(&quot;createsUnitsList cannot be empty or have more than two fields&quot; + thisErrorMsg());</span>
    }
    String unitTypeToProduce;
<span class="nc" id="L1848">    unitTypeToProduce = s[1];</span>
    // validate that this unit exists in the xml
<span class="nc" id="L1850">    final UnitType ut = getData().getUnitTypeList().getUnitType(unitTypeToProduce);</span>
<span class="nc bnc" id="L1851" title="All 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L1852">      throw new GameParseException(&quot;createsUnitsList: No unit called:&quot; + unitTypeToProduce + thisErrorMsg());</span>
    }
<span class="nc" id="L1854">    final int n = getInt(s[0]);</span>
<span class="nc bnc" id="L1855" title="All 2 branches missed.">    if (n &lt; 1) {</span>
<span class="nc" id="L1856">      throw new GameParseException(&quot;createsUnitsList must have positive values&quot; + thisErrorMsg());</span>
    }
<span class="nc" id="L1858">    m_createsUnitsList.put(ut, n);</span>
<span class="nc" id="L1859">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCreatesUnitsList(final IntegerMap&lt;UnitType&gt; value) {
<span class="nc" id="L1863">    m_createsUnitsList = value;</span>
<span class="nc" id="L1864">  }</span>

  public IntegerMap&lt;UnitType&gt; getCreatesUnitsList() {
<span class="nc" id="L1867">    return m_createsUnitsList;</span>
  }

  public void clearCreatesUnitsList() {
<span class="nc" id="L1871">    m_createsUnitsList.clear();</span>
<span class="nc" id="L1872">  }</span>

  public void resetCreatesUnitsList() {
<span class="nc" id="L1875">    m_createsUnitsList = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L1876">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   *
   * @param value
   * @throws GameParseException
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setCreatesResourcesList(final String value) throws GameParseException {
<span class="nc" id="L1886">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="nc bnc" id="L1887" title="All 4 branches missed.">    if (s.length &lt;= 0 || s.length &gt; 2) {</span>
<span class="nc" id="L1888">      throw new GameParseException(</span>
<span class="nc" id="L1889">          &quot;createsResourcesList cannot be empty or have more than two fields&quot; + thisErrorMsg());</span>
    }
    String resourceToProduce;
<span class="nc" id="L1892">    resourceToProduce = s[1];</span>
    // validate that this resource exists in the xml
<span class="nc" id="L1894">    final Resource r = getData().getResourceList().getResource(resourceToProduce);</span>
<span class="nc bnc" id="L1895" title="All 2 branches missed.">    if (r == null) {</span>
<span class="nc" id="L1896">      throw new GameParseException(&quot;createsResourcesList: No resource called:&quot; + resourceToProduce + thisErrorMsg());</span>
    }
<span class="nc" id="L1898">    final int n = getInt(s[0]);</span>
<span class="nc" id="L1899">    m_createsResourcesList.put(r, n);</span>
<span class="nc" id="L1900">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCreatesResourcesList(final IntegerMap&lt;Resource&gt; value) {
<span class="nc" id="L1904">    m_createsResourcesList = value;</span>
<span class="nc" id="L1905">  }</span>

  public IntegerMap&lt;Resource&gt; getCreatesResourcesList() {
<span class="nc" id="L1908">    return m_createsResourcesList;</span>
  }

  public void clearCreatesResourcesList() {
<span class="nc" id="L1912">    m_createsResourcesList.clear();</span>
<span class="nc" id="L1913">  }</span>

  public void resetCreatesResourcesList() {
<span class="nc" id="L1916">    m_createsResourcesList = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L1917">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   *
   * @param value
   * @throws GameParseException
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setFuelCost(final String value) throws GameParseException {
<span class="fc" id="L1927">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L1928" title="1 of 2 branches missed.">    if (s.length != 2) {</span>
<span class="nc" id="L1929">      throw new GameParseException(&quot;fuelCost must have two fields&quot; + thisErrorMsg());</span>
    }
    String resourceToProduce;
<span class="fc" id="L1932">    resourceToProduce = s[1];</span>
    // validate that this resource exists in the xml
<span class="fc" id="L1934">    final Resource r = getData().getResourceList().getResource(resourceToProduce);</span>
<span class="pc bpc" id="L1935" title="1 of 2 branches missed.">    if (r == null) {</span>
<span class="nc" id="L1936">      throw new GameParseException(&quot;fuelCost: No resource called:&quot; + resourceToProduce + thisErrorMsg());</span>
    }
<span class="fc" id="L1938">    final int n = getInt(s[0]);</span>
<span class="pc bpc" id="L1939" title="1 of 2 branches missed.">    if (n &lt; 0) {</span>
<span class="nc" id="L1940">      throw new GameParseException(&quot;fuelCost must have positive values&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L1942">    m_fuelCost.put(r, n);</span>
<span class="fc" id="L1943">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setFuelCost(final IntegerMap&lt;Resource&gt; value) {
<span class="nc" id="L1947">    m_fuelCost = value;</span>
<span class="nc" id="L1948">  }</span>

  public IntegerMap&lt;Resource&gt; getFuelCost() {
<span class="fc" id="L1951">    return m_fuelCost;</span>
  }

  public void clearFuelCost() {
<span class="nc" id="L1955">    m_fuelCost.clear();</span>
<span class="nc" id="L1956">  }</span>

  public void resetFuelCost() {
<span class="nc" id="L1959">    m_fuelCost = new IntegerMap&lt;&gt;();</span>
<span class="nc" id="L1960">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setBombingBonus(final String s) {
<span class="fc" id="L1964">    m_bombingBonus = getInt(s);</span>
<span class="fc" id="L1965">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setBombingBonus(final int s) {
<span class="fc" id="L1969">    m_bombingBonus = s;</span>
<span class="fc" id="L1970">  }</span>

  public int getBombingBonus() {
<span class="fc" id="L1973">    return m_bombingBonus;</span>
  }

  public void resetBombingBonus() {
<span class="nc" id="L1977">    m_bombingBonus = -1;</span>
<span class="nc" id="L1978">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setBombingMaxDieSides(final String s) {
<span class="fc" id="L1982">    m_bombingMaxDieSides = getInt(s);</span>
<span class="fc" id="L1983">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setBombingMaxDieSides(final int s) {
<span class="fc" id="L1987">    m_bombingMaxDieSides = s;</span>
<span class="fc" id="L1988">  }</span>

  public int getBombingMaxDieSides() {
<span class="fc" id="L1991">    return m_bombingMaxDieSides;</span>
  }

  public void resetBombingMaxDieSides() {
<span class="nc" id="L1995">    m_bombingMaxDieSides = -1;</span>
<span class="nc" id="L1996">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   *
   * @param value
   * @throws GameParseException
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setBombingTargets(final String value) throws GameParseException {
<span class="pc bpc" id="L2006" title="1 of 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L2007">      m_bombingTargets = null;</span>
<span class="nc" id="L2008">      return;</span>
    }
<span class="pc bpc" id="L2010" title="1 of 2 branches missed.">    if (m_bombingTargets == null) {</span>
<span class="fc" id="L2011">      m_bombingTargets = new HashSet&lt;&gt;();</span>
    }
<span class="fc" id="L2013">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="fc bfc" id="L2014" title="All 2 branches covered.">    for (final String u : s) {</span>
<span class="fc" id="L2015">      final UnitType ut = getData().getUnitTypeList().getUnitType(u);</span>
<span class="pc bpc" id="L2016" title="1 of 2 branches missed.">      if (ut == null) {</span>
<span class="nc" id="L2017">        throw new GameParseException(&quot;bombingTargets: no such unit type: &quot; + u + thisErrorMsg());</span>
      }
<span class="fc" id="L2019">      m_bombingTargets.add(ut);</span>
    }
<span class="fc" id="L2021">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setBombingTargets(final HashSet&lt;UnitType&gt; value) {
<span class="nc" id="L2025">    m_bombingTargets = value;</span>
<span class="nc" id="L2026">  }</span>

  public HashSet&lt;UnitType&gt; getBombingTargets(final GameData data) {
<span class="pc bpc" id="L2029" title="1 of 2 branches missed.">    if (m_bombingTargets != null) {</span>
<span class="nc" id="L2030">      return m_bombingTargets;</span>
    }
<span class="fc" id="L2032">    return new HashSet&lt;&gt;(data.getUnitTypeList().getAllUnitTypes());</span>
  }

  public void clearBombingTargets() {
<span class="nc" id="L2036">    m_bombingTargets.clear();</span>
<span class="nc" id="L2037">  }</span>

  public void resetBombingTargets() {
<span class="nc" id="L2040">    m_bombingTargets = null;</span>
<span class="nc" id="L2041">  }</span>

  public static Set&lt;UnitType&gt; getAllowedBombingTargetsIntersection(final Collection&lt;Unit&gt; bombersOrRockets,
      final GameData data) {
<span class="fc bfc" id="L2045" title="All 2 branches covered.">    if (bombersOrRockets.isEmpty()) {</span>
<span class="fc" id="L2046">      return new HashSet&lt;&gt;();</span>
    }
<span class="fc" id="L2048">    Collection&lt;UnitType&gt; allowedTargets = data.getUnitTypeList().getAllUnitTypes();</span>
<span class="fc bfc" id="L2049" title="All 2 branches covered.">    for (final Unit u : bombersOrRockets) {</span>
<span class="fc" id="L2050">      final UnitAttachment ua = UnitAttachment.get(u.getType());</span>
<span class="fc" id="L2051">      final HashSet&lt;UnitType&gt; bombingTargets = ua.getBombingTargets(data);</span>
<span class="pc bpc" id="L2052" title="1 of 2 branches missed.">      if (bombingTargets != null) {</span>
<span class="fc" id="L2053">        allowedTargets = games.strategy.util.Util.intersection(allowedTargets, bombingTargets);</span>
      }
    }
<span class="fc" id="L2056">    return new HashSet&lt;&gt;(allowedTargets);</span>
  }

  // Do not delete, we keep this both for backwards compatibility, and for user convenience when making maps
  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsAA(final String s) throws GameParseException {
<span class="fc" id="L2062">    setIsAA(getBool(s));</span>
<span class="fc" id="L2063">  }</span>

  // Do not delete, we keep this both for backwards compatibility, and for user convenience when making maps
  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsAA(final Boolean s) throws GameParseException {
<span class="fc" id="L2068">    setIsAAforCombatOnly(s);</span>
<span class="fc" id="L2069">    setIsAAforBombingThisUnitOnly(s);</span>
<span class="fc" id="L2070">    setIsAAforFlyOverOnly(s);</span>
<span class="fc" id="L2071">    setIsAAmovement(s);</span>
<span class="fc" id="L2072">    setIsRocket(s);</span>
<span class="fc" id="L2073">    setIsInfrastructure(s);</span>
<span class="fc" id="L2074">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAttackAA(final String s) {
<span class="fc" id="L2078">    m_attackAA = getInt(s);</span>
<span class="fc" id="L2079">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAttackAA(final int s) {
<span class="nc" id="L2083">    m_attackAA = s;</span>
<span class="nc" id="L2084">  }</span>

  public int getAttackAA(final PlayerID player) {
    // TODO: this may cause major problems with Low Luck, if they have diceSides equal to something other than 6, or it
    // does not divide
    // perfectly into attackAAmaxDieSides
<span class="fc" id="L2090">    return Math.max(0, Math.min(getAttackAAmaxDieSides(),</span>
<span class="fc" id="L2091">        m_attackAA + TechAbilityAttachment.getRadarBonus((UnitType) this.getAttachedTo(), player, getData())));</span>
  }

  public void resetAttackAA() {
<span class="nc" id="L2095">    m_attackAA = 1;</span>
<span class="nc" id="L2096">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setOffensiveAttackAA(final String s) {
<span class="nc" id="L2100">    m_offensiveAttackAA = getInt(s);</span>
<span class="nc" id="L2101">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setOffensiveAttackAA(final Integer s) {
<span class="nc" id="L2105">    m_offensiveAttackAA = s;</span>
<span class="nc" id="L2106">  }</span>

  public int getOffensiveAttackAA(final PlayerID player) {
    // TODO: this may cause major problems with Low Luck, if they have diceSides equal to something other than 6, or it
    // does not divide
    // perfectly into attackAAmaxDieSides
<span class="nc" id="L2112">    return Math.max(0, Math.min(getOffensiveAttackAAmaxDieSides(),</span>
<span class="nc" id="L2113">        m_offensiveAttackAA + TechAbilityAttachment.getRadarBonus((UnitType) this.getAttachedTo(), player, getData())));</span>
  }

  public void resetOffensiveAttackAA() {
<span class="nc" id="L2117">    m_offensiveAttackAA = 1;</span>
<span class="nc" id="L2118">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAttackAAmaxDieSides(final String s) {
<span class="fc" id="L2122">    m_attackAAmaxDieSides = getInt(s);</span>
<span class="fc" id="L2123">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAttackAAmaxDieSides(final Integer s) {
<span class="fc" id="L2127">    m_attackAAmaxDieSides = s;</span>
<span class="fc" id="L2128">  }</span>

  public int getAttackAAmaxDieSides() {
<span class="fc bfc" id="L2131" title="All 2 branches covered.">    if (m_attackAAmaxDieSides &lt; 0) {</span>
<span class="fc" id="L2132">      return getData().getDiceSides();</span>
    }
<span class="fc" id="L2134">    return m_attackAAmaxDieSides;</span>
  }

  public void resetAttackAAmaxDieSides() {
<span class="nc" id="L2138">    m_attackAAmaxDieSides = -1;</span>
<span class="nc" id="L2139">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setOffensiveAttackAAmaxDieSides(final String s) {
<span class="fc" id="L2143">    m_offensiveAttackAAmaxDieSides = getInt(s);</span>
<span class="fc" id="L2144">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setOffensiveAttackAAmaxDieSides(final Integer s) {
<span class="fc" id="L2148">    m_offensiveAttackAAmaxDieSides = s;</span>
<span class="fc" id="L2149">  }</span>

  public int getOffensiveAttackAAmaxDieSides() {
<span class="pc bpc" id="L2152" title="1 of 2 branches missed.">    if (m_offensiveAttackAAmaxDieSides &lt; 0) {</span>
<span class="nc" id="L2153">      return getData().getDiceSides();</span>
    }
<span class="fc" id="L2155">    return m_offensiveAttackAAmaxDieSides;</span>
  }

  public void resetOffensiveAttackAAmaxDieSides() {
<span class="nc" id="L2159">    m_offensiveAttackAAmaxDieSides = -1;</span>
<span class="nc" id="L2160">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMaxAAattacks(final String s) throws GameParseException {
<span class="fc" id="L2164">    final int attacks = getInt(s);</span>
<span class="pc bpc" id="L2165" title="1 of 2 branches missed.">    if (attacks &lt; -1) {</span>
<span class="nc" id="L2166">      throw new GameParseException(&quot;maxAAattacks must be positive (or -1 for attacking all) &quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L2168">    m_maxAAattacks = getInt(s);</span>
<span class="fc" id="L2169">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMaxAAattacks(final Integer s) {
<span class="fc" id="L2173">    m_maxAAattacks = s;</span>
<span class="fc" id="L2174">  }</span>

  public int getMaxAAattacks() {
<span class="fc" id="L2177">    return m_maxAAattacks;</span>
  }

  public void resetMaxAAattacks() {
<span class="nc" id="L2181">    m_maxAAattacks = -1;</span>
<span class="nc" id="L2182">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMaxRoundsAA(final String s) throws GameParseException {
<span class="fc" id="L2186">    final int attacks = getInt(s);</span>
<span class="pc bpc" id="L2187" title="1 of 2 branches missed.">    if (attacks &lt; -1) {</span>
<span class="nc" id="L2188">      throw new GameParseException(&quot;maxRoundsAA must be positive (or -1 for infinite) &quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L2190">    m_maxRoundsAA = getInt(s);</span>
<span class="fc" id="L2191">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMaxRoundsAA(final Integer s) {
<span class="fc" id="L2195">    m_maxRoundsAA = s;</span>
<span class="fc" id="L2196">  }</span>

  public int getMaxRoundsAA() {
<span class="fc" id="L2199">    return m_maxRoundsAA;</span>
  }

  public void resetMaxRoundsAA() {
<span class="nc" id="L2203">    m_maxRoundsAA = 1;</span>
<span class="nc" id="L2204">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMayOverStackAA(final String s) {
<span class="fc" id="L2208">    m_mayOverStackAA = getBool(s);</span>
<span class="fc" id="L2209">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMayOverStackAA(final Boolean s) {
<span class="fc" id="L2213">    m_mayOverStackAA = s;</span>
<span class="fc" id="L2214">  }</span>

  public boolean getMayOverStackAA() {
<span class="fc" id="L2217">    return m_mayOverStackAA;</span>
  }

  public void resetMayOverStackAA() {
<span class="nc" id="L2221">    m_mayOverStackAA = false;</span>
<span class="nc" id="L2222">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setDamageableAA(final String s) {
<span class="fc" id="L2226">    m_damageableAA = getBool(s);</span>
<span class="fc" id="L2227">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setDamageableAA(final Boolean s) {
<span class="fc" id="L2231">    m_damageableAA = s;</span>
<span class="fc" id="L2232">  }</span>

  public boolean getDamageableAA() {
<span class="fc" id="L2235">    return m_damageableAA;</span>
  }

  public void resetDamageableAA() {
<span class="nc" id="L2239">    m_damageableAA = false;</span>
<span class="nc" id="L2240">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsAAforCombatOnly(final String s) {
<span class="fc" id="L2244">    m_isAAforCombatOnly = getBool(s);</span>
<span class="fc" id="L2245">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsAAforCombatOnly(final Boolean s) {
<span class="fc" id="L2249">    m_isAAforCombatOnly = s;</span>
<span class="fc" id="L2250">  }</span>

  public boolean getIsAAforCombatOnly() {
<span class="fc" id="L2253">    return m_isAAforCombatOnly;</span>
  }

  public void resetIsAAforCombatOnly() {
<span class="nc" id="L2257">    m_isAAforCombatOnly = false;</span>
<span class="nc" id="L2258">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsAAforBombingThisUnitOnly(final String s) {
<span class="fc" id="L2262">    m_isAAforBombingThisUnitOnly = getBool(s);</span>
<span class="fc" id="L2263">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsAAforBombingThisUnitOnly(final Boolean s) {
<span class="fc" id="L2267">    m_isAAforBombingThisUnitOnly = s;</span>
<span class="fc" id="L2268">  }</span>

  public boolean getIsAAforBombingThisUnitOnly() {
<span class="fc" id="L2271">    return m_isAAforBombingThisUnitOnly;</span>
  }

  public void resetIsAAforBombingThisUnitOnly() {
<span class="nc" id="L2275">    m_isAAforBombingThisUnitOnly = false;</span>
<span class="nc" id="L2276">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsAAforFlyOverOnly(final String s) {
<span class="fc" id="L2280">    m_isAAforFlyOverOnly = getBool(s);</span>
<span class="fc" id="L2281">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsAAforFlyOverOnly(final Boolean s) {
<span class="fc" id="L2285">    m_isAAforFlyOverOnly = s;</span>
<span class="fc" id="L2286">  }</span>

  public boolean getIsAAforFlyOverOnly() {
<span class="fc" id="L2289">    return m_isAAforFlyOverOnly;</span>
  }

  public void resetIsAAforFlyOverOnly() {
<span class="nc" id="L2293">    m_isAAforFlyOverOnly = false;</span>
<span class="nc" id="L2294">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsRocket(final String s) {
<span class="fc" id="L2298">    m_isRocket = getBool(s);</span>
<span class="fc" id="L2299">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsRocket(final Boolean s) {
<span class="fc" id="L2303">    m_isRocket = s;</span>
<span class="fc" id="L2304">  }</span>

  public boolean getIsRocket() {
<span class="fc" id="L2307">    return m_isRocket;</span>
  }

  public void resetIsRocket() {
<span class="nc" id="L2311">    m_isRocket = false;</span>
<span class="nc" id="L2312">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setTypeAA(final String s) {
<span class="fc" id="L2316">    m_typeAA = s;</span>
<span class="fc" id="L2317">  }</span>

  public String getTypeAA() {
<span class="fc" id="L2320">    return m_typeAA;</span>
  }

  public void resetTypeAA() {
<span class="nc" id="L2324">    m_typeAA = &quot;AA&quot;;</span>
<span class="nc" id="L2325">  }</span>

  public static Set&lt;String&gt; getAllOfTypeAAs(final Collection&lt;Unit&gt; aaUnits, final Collection&lt;Unit&gt; targets,
      final Match&lt;Unit&gt; typeOfAA, final HashMap&lt;String, HashSet&lt;UnitType&gt;&gt; airborneTechTargetsAllowed) {
<span class="nc" id="L2329">    final Set&lt;String&gt; rVal = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L2330" title="All 2 branches missed.">    for (final Unit u : Match.getMatches(aaUnits,</span>
<span class="nc" id="L2331">        Matches.UnitIsAAthatCanHitTheseUnits(targets, typeOfAA, airborneTechTargetsAllowed))) {</span>
<span class="nc" id="L2332">      rVal.add(UnitAttachment.get(u.getType()).getTypeAA());</span>
    }
<span class="nc" id="L2334">    return rVal;</span>
  }

  public static List&lt;String&gt; getAllOfTypeAAs(final Collection&lt;Unit&gt; aaUnitsAlreadyVerified) {
<span class="fc" id="L2338">    final Set&lt;String&gt; aaSet = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L2339" title="All 2 branches covered.">    for (final Unit u : aaUnitsAlreadyVerified) {</span>
<span class="fc" id="L2340">      aaSet.add(UnitAttachment.get(u.getType()).getTypeAA());</span>
    }
<span class="fc" id="L2342">    final List&lt;String&gt; rVal = new ArrayList&lt;&gt;(aaSet);</span>
<span class="fc" id="L2343">    Collections.sort(rVal);</span>
<span class="fc" id="L2344">    return rVal;</span>
  }

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   *
   * @param value
   * @throws GameParseException
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setTargetsAA(final String value) throws GameParseException {
<span class="nc bnc" id="L2355" title="All 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L2356">      m_targetsAA = null;</span>
<span class="nc" id="L2357">      return;</span>
    }
<span class="nc bnc" id="L2359" title="All 2 branches missed.">    if (m_targetsAA == null) {</span>
<span class="nc" id="L2360">      m_targetsAA = new HashSet&lt;&gt;();</span>
    }
<span class="nc" id="L2362">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="nc bnc" id="L2363" title="All 2 branches missed.">    for (final String u : s) {</span>
<span class="nc" id="L2364">      final UnitType ut = getData().getUnitTypeList().getUnitType(u);</span>
<span class="nc bnc" id="L2365" title="All 2 branches missed.">      if (ut == null) {</span>
<span class="nc" id="L2366">        throw new GameParseException(&quot;AAtargets: no such unit type: &quot; + u + thisErrorMsg());</span>
      }
<span class="nc" id="L2368">      m_targetsAA.add(ut);</span>
    }
<span class="nc" id="L2370">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setTargetsAA(final HashSet&lt;UnitType&gt; value) {
<span class="nc" id="L2374">    m_targetsAA = value;</span>
<span class="nc" id="L2375">  }</span>

  public HashSet&lt;UnitType&gt; getTargetsAA(final GameData data) {
<span class="pc bpc" id="L2378" title="1 of 2 branches missed.">    if (m_targetsAA != null) {</span>
<span class="nc" id="L2379">      return m_targetsAA;</span>
    }
<span class="fc" id="L2381">    final HashSet&lt;UnitType&gt; airTypes = new HashSet&lt;&gt;();</span>
<span class="fc" id="L2382">    final Iterator&lt;UnitType&gt; utIter = data.getUnitTypeList().iterator();</span>
<span class="fc bfc" id="L2383" title="All 2 branches covered.">    while (utIter.hasNext()) {</span>
<span class="fc" id="L2384">      final UnitType ut = utIter.next();</span>
<span class="fc bfc" id="L2385" title="All 2 branches covered.">      if (UnitAttachment.get(ut).getIsAir()) {</span>
<span class="fc" id="L2386">        airTypes.add(ut);</span>
      }
    }
<span class="fc" id="L2389">    return airTypes;</span>
  }

  public void clearTargetsAA() {
<span class="nc" id="L2393">    m_targetsAA.clear();</span>
<span class="nc" id="L2394">  }</span>

  public void resetTargetsAA() {
<span class="nc" id="L2397">    m_targetsAA = null;</span>
<span class="nc" id="L2398">  }</span>

  /**
   * Adds to, not sets. Anything that adds to instead of setting needs a clear function as well.
   *
   * @param value
   * @throws GameParseException
   */
  @GameProperty(xmlProperty = true, gameProperty = true, adds = true)
  public void setWillNotFireIfPresent(final String value) throws GameParseException {
<span class="nc" id="L2408">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="nc bnc" id="L2409" title="All 2 branches missed.">    for (final String u : s) {</span>
<span class="nc" id="L2410">      final UnitType ut = getData().getUnitTypeList().getUnitType(u);</span>
<span class="nc bnc" id="L2411" title="All 2 branches missed.">      if (ut == null) {</span>
<span class="nc" id="L2412">        throw new GameParseException(&quot;willNotFireIfPresent: no such unit type: &quot; + u + thisErrorMsg());</span>
      }
<span class="nc" id="L2414">      m_willNotFireIfPresent.add(ut);</span>
    }
<span class="nc" id="L2416">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setWillNotFireIfPresent(final HashSet&lt;UnitType&gt; value) {
<span class="nc" id="L2420">    m_willNotFireIfPresent = value;</span>
<span class="nc" id="L2421">  }</span>

  public HashSet&lt;UnitType&gt; getWillNotFireIfPresent() {
<span class="fc" id="L2424">    return m_willNotFireIfPresent;</span>
  }

  public void clearWillNotFireIfPresent() {
<span class="nc" id="L2428">    m_willNotFireIfPresent.clear();</span>
<span class="nc" id="L2429">  }</span>

  public void resetWillNotFireIfPresent() {
<span class="nc" id="L2432">    m_willNotFireIfPresent = new HashSet&lt;&gt;();</span>
<span class="nc" id="L2433">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsAAmovement(final String s) throws GameParseException {
<span class="nc" id="L2437">    setIsAAmovement(getBool(s));</span>
<span class="nc" id="L2438">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setIsAAmovement(final Boolean s) throws GameParseException {
<span class="fc" id="L2442">    setCanNotMoveDuringCombatMove(s);</span>
<span class="pc bpc" id="L2443" title="1 of 2 branches missed.">    if (s) {</span>
<span class="fc" id="L2444">      setMovementLimit(Integer.MAX_VALUE + &quot;:allied&quot;);</span>
<span class="fc" id="L2445">      setAttackingLimit(Integer.MAX_VALUE + &quot;:allied&quot;);</span>
<span class="fc" id="L2446">      setPlacementLimit(Integer.MAX_VALUE + &quot;:allied&quot;);</span>
<span class="fc" id="L2447">    } else {</span>
<span class="nc" id="L2448">      m_movementLimit = null;</span>
<span class="nc" id="L2449">      m_attackingLimit = null;</span>
<span class="nc" id="L2450">      m_placementLimit = null;</span>
    }
<span class="fc" id="L2452">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanNotMoveDuringCombatMove(final String s) {
<span class="fc" id="L2456">    m_canNotMoveDuringCombatMove = getBool(s);</span>
<span class="fc" id="L2457">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setCanNotMoveDuringCombatMove(final Boolean s) {
<span class="fc" id="L2461">    m_canNotMoveDuringCombatMove = s;</span>
<span class="fc" id="L2462">  }</span>

  public boolean getCanNotMoveDuringCombatMove() {
<span class="fc" id="L2465">    return m_canNotMoveDuringCombatMove;</span>
  }

  public void resetCanNotMoveDuringCombatMove() {
<span class="nc" id="L2469">    m_canNotMoveDuringCombatMove = false;</span>
<span class="nc" id="L2470">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMovementLimit(final String value) throws GameParseException {
<span class="pc bpc" id="L2474" title="1 of 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L2475">      m_movementLimit = null;</span>
<span class="nc" id="L2476">      return;</span>
    }
<span class="fc" id="L2478">    final UnitType ut = (UnitType) this.getAttachedTo();</span>
<span class="pc bpc" id="L2479" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L2480">      throw new GameParseException(&quot;getAttachedTo returned null&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L2482">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L2483" title="1 of 2 branches missed.">    if (s.length != 2) {</span>
<span class="nc" id="L2484">      throw new GameParseException(&quot;movementLimit must have 2 fields, value and count&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L2486">    final int max = getInt(s[0]);</span>
<span class="pc bpc" id="L2487" title="1 of 2 branches missed.">    if (max &lt; 0) {</span>
<span class="nc" id="L2488">      throw new GameParseException(&quot;movementLimit count must have a positive number&quot; + thisErrorMsg());</span>
    }
<span class="pc bpc" id="L2490" title="4 of 6 branches missed.">    if (!(s[1].equals(&quot;owned&quot;) || s[1].equals(&quot;allied&quot;) || s[1].equals(&quot;total&quot;))) {</span>
<span class="nc" id="L2491">      throw new GameParseException(&quot;movementLimit value must owned, allied, or total&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L2493">    m_movementLimit = Tuple.of(max, s[1]);</span>
<span class="fc" id="L2494">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setMovementLimit(final Tuple&lt;Integer, String&gt; value) {
<span class="nc" id="L2498">    m_movementLimit = value;</span>
<span class="nc" id="L2499">  }</span>

  public Tuple&lt;Integer, String&gt; getMovementLimit() {
<span class="fc" id="L2502">    return m_movementLimit;</span>
  }

  public void resetMovementLimit() {
<span class="nc" id="L2506">    m_movementLimit = null;</span>
<span class="nc" id="L2507">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAttackingLimit(final String value) throws GameParseException {
<span class="pc bpc" id="L2511" title="1 of 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L2512">      m_attackingLimit = null;</span>
<span class="nc" id="L2513">      return;</span>
    }
<span class="fc" id="L2515">    final UnitType ut = (UnitType) this.getAttachedTo();</span>
<span class="pc bpc" id="L2516" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L2517">      throw new GameParseException(&quot;getAttachedTo returned null&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L2519">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L2520" title="1 of 2 branches missed.">    if (s.length != 2) {</span>
<span class="nc" id="L2521">      throw new GameParseException(&quot;attackingLimit must have 2 fields, value and count&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L2523">    final int max = getInt(s[0]);</span>
<span class="pc bpc" id="L2524" title="1 of 2 branches missed.">    if (max &lt; 0) {</span>
<span class="nc" id="L2525">      throw new GameParseException(&quot;attackingLimit count must have a positive number&quot; + thisErrorMsg());</span>
    }
<span class="pc bpc" id="L2527" title="4 of 6 branches missed.">    if (!(s[1].equals(&quot;owned&quot;) || s[1].equals(&quot;allied&quot;) || s[1].equals(&quot;total&quot;))) {</span>
<span class="nc" id="L2528">      throw new GameParseException(&quot;attackingLimit value must owned, allied, or total&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L2530">    m_attackingLimit = Tuple.of(max, s[1]);</span>
<span class="fc" id="L2531">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setAttackingLimit(final Tuple&lt;Integer, String&gt; value) {
<span class="nc" id="L2535">    m_attackingLimit = value;</span>
<span class="nc" id="L2536">  }</span>

  public Tuple&lt;Integer, String&gt; getAttackingLimit() {
<span class="fc" id="L2539">    return m_attackingLimit;</span>
  }

  public void resetAttackingLimit() {
<span class="nc" id="L2543">    m_attackingLimit = null;</span>
<span class="nc" id="L2544">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setPlacementLimit(final String value) throws GameParseException {
<span class="pc bpc" id="L2548" title="1 of 2 branches missed.">    if (value == null) {</span>
<span class="nc" id="L2549">      m_placementLimit = null;</span>
<span class="nc" id="L2550">      return;</span>
    }
<span class="fc" id="L2552">    final UnitType ut = (UnitType) this.getAttachedTo();</span>
<span class="pc bpc" id="L2553" title="1 of 2 branches missed.">    if (ut == null) {</span>
<span class="nc" id="L2554">      throw new GameParseException(&quot;getAttachedTo returned null&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L2556">    final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L2557" title="1 of 2 branches missed.">    if (s.length != 2) {</span>
<span class="nc" id="L2558">      throw new GameParseException(&quot;placementLimit must have 2 fields, value and count&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L2560">    final int max = getInt(s[0]);</span>
<span class="pc bpc" id="L2561" title="1 of 2 branches missed.">    if (max &lt; 0) {</span>
<span class="nc" id="L2562">      throw new GameParseException(&quot;placementLimit count must have a positive number&quot; + thisErrorMsg());</span>
    }
<span class="pc bpc" id="L2564" title="4 of 6 branches missed.">    if (!(s[1].equals(&quot;owned&quot;) || s[1].equals(&quot;allied&quot;) || s[1].equals(&quot;total&quot;))) {</span>
<span class="nc" id="L2565">      throw new GameParseException(&quot;placementLimit value must owned, allied, or total&quot; + thisErrorMsg());</span>
    }
<span class="fc" id="L2567">    m_placementLimit = Tuple.of(max, s[1]);</span>
<span class="fc" id="L2568">  }</span>

  @GameProperty(xmlProperty = true, gameProperty = true, adds = false)
  public void setPlacementLimit(final Tuple&lt;Integer, String&gt; value) {
<span class="nc" id="L2572">    m_placementLimit = value;</span>
<span class="nc" id="L2573">  }</span>

  public Tuple&lt;Integer, String&gt; getPlacementLimit() {
<span class="fc" id="L2576">    return m_placementLimit;</span>
  }

  public void resetPlacementLimit() {
<span class="nc" id="L2580">    m_placementLimit = null;</span>
<span class="nc" id="L2581">  }</span>

  public static int getMaximumNumberOfThisUnitTypeToReachStackingLimit(final String limitType, final UnitType ut,
      final Territory t, final PlayerID owner, final GameData data) {
<span class="fc" id="L2585">    final UnitAttachment ua = UnitAttachment.get(ut);</span>
    final Tuple&lt;Integer, String&gt; stackingLimit;
<span class="fc bfc" id="L2587" title="All 2 branches covered.">    if (limitType.equals(&quot;movementLimit&quot;)) {</span>
<span class="fc" id="L2588">      stackingLimit = ua.getMovementLimit();</span>
<span class="pc bpc" id="L2589" title="1 of 2 branches missed.">    } else if (limitType.equals(&quot;attackingLimit&quot;)) {</span>
<span class="nc" id="L2590">      stackingLimit = ua.getAttackingLimit();</span>
<span class="pc bpc" id="L2591" title="1 of 2 branches missed.">    } else if (limitType.equals(&quot;placementLimit&quot;)) {</span>
<span class="fc" id="L2592">      stackingLimit = ua.getPlacementLimit();</span>
<span class="fc" id="L2593">    } else {</span>
<span class="nc" id="L2594">      throw new IllegalStateException(</span>
<span class="nc" id="L2595">          &quot;getMaximumNumberOfThisUnitTypeToReachStackingLimit does not allow limitType: &quot; + limitType);</span>
    }
<span class="fc bfc" id="L2597" title="All 2 branches covered.">    if (stackingLimit == null) {</span>
<span class="fc" id="L2598">      return Integer.MAX_VALUE;</span>
    }
<span class="fc" id="L2600">    int max = stackingLimit.getFirst();</span>
<span class="pc bpc" id="L2601" title="4 of 6 branches missed.">    if (max == Integer.MAX_VALUE &amp;&amp; (ua.getIsAAforBombingThisUnitOnly() || ua.getIsAAforCombatOnly())) {</span>
      // under certain rules (classic rules) there can only be 1 aa gun in a territory.
<span class="pc bpc" id="L2603" title="1 of 4 branches missed.">      if (!(games.strategy.triplea.Properties.getWW2V2(data) || games.strategy.triplea.Properties.getWW2V3(data)</span>
<span class="pc bpc" id="L2604" title="1 of 2 branches missed.">          || games.strategy.triplea.Properties.getMultipleAAPerTerritory(data))) {</span>
<span class="fc" id="L2605">        max = 1;</span>
      }
    }
<span class="fc" id="L2608">    final CompositeMatchAnd&lt;Unit&gt; stackingMatch = new CompositeMatchAnd&lt;&gt;(Matches.unitIsOfType(ut));</span>
<span class="fc" id="L2609">    final String stackingType = stackingLimit.getSecond();</span>
<span class="pc bpc" id="L2610" title="1 of 2 branches missed.">    if (stackingType.equals(&quot;owned&quot;)) {</span>
<span class="nc" id="L2611">      stackingMatch.add(Matches.unitIsOwnedBy(owner));</span>
<span class="pc bpc" id="L2612" title="1 of 2 branches missed.">    } else if (stackingType.equals(&quot;allied&quot;)) {</span>
<span class="fc" id="L2613">      stackingMatch.add(Matches.isUnitAllied(owner, data));</span>
    }
    // else if (stackingType.equals(&quot;total&quot;))
<span class="fc" id="L2616">    final int totalInTerritory = Match.countMatches(t.getUnits().getUnits(), stackingMatch);</span>
<span class="fc" id="L2617">    return Math.max(0, max - totalInTerritory);</span>
  }

  @Override
  public void validate(final GameData data) throws GameParseException {
<span class="fc bfc" id="L2622" title="All 2 branches covered.">    if (m_isAir) {</span>
<span class="pc bpc" id="L2623" title="5 of 10 branches missed.">      if (m_isSea /* || m_isFactory */ || m_isSub || m_transportCost != -1 || m_carrierCapacity != -1 || m_canBlitz</span>
<span class="pc bpc" id="L2624" title="5 of 10 branches missed.">          || m_canBombard || m_isMarine != 0 || m_isInfantry || m_isLandTransport || m_isAirTransportable</span>
<span class="pc bpc" id="L2625" title="1 of 2 branches missed.">          || m_isCombatTransport) {</span>
<span class="nc" id="L2626">        throw new GameParseException(&quot;air units cannot have certain properties, &quot; + thisErrorMsg());</span>
      }
<span class="fc bfc" id="L2628" title="All 2 branches covered.">    } else if (m_isSea) {</span>
<span class="pc bpc" id="L2629" title="4 of 8 branches missed.">      if (m_canBlitz || m_isAir /* || m_isFactory */ || m_isStrategicBomber || m_carrierCost != -1</span>
<span class="pc bpc" id="L2630" title="5 of 10 branches missed.">          || m_transportCost != -1 || m_isMarine != 0 || m_isInfantry || m_isLandTransport || m_isAirTransportable</span>
<span class="pc bpc" id="L2631" title="2 of 4 branches missed.">          || m_isAirTransport || m_isKamikaze) {</span>
<span class="nc" id="L2632">        throw new GameParseException(&quot;sea units cannot have certain properties, &quot; + thisErrorMsg());</span>
      }
    } else
    // if land
    {
<span class="pc bpc" id="L2637" title="5 of 10 branches missed.">      if (m_canBombard || m_isStrategicBomber || m_isSub || m_carrierCapacity != -1 || m_bombard != -1</span>
<span class="pc bpc" id="L2638" title="4 of 8 branches missed.">          || m_transportCapacity != -1 || m_isAirTransport || m_isCombatTransport || m_isKamikaze) {</span>
<span class="nc" id="L2639">        throw new GameParseException(&quot;land units cannot have certain properties, &quot; + thisErrorMsg());</span>
      }
    }
<span class="pc bpc" id="L2642" title="1 of 2 branches missed.">    if (m_hitPoints &lt; 1) {</span>
<span class="nc" id="L2643">      throw new GameParseException(&quot;hitPoints cannot be zero or negative, &quot; + thisErrorMsg());</span>
    }
<span class="pc bpc" id="L2645" title="4 of 8 branches missed.">    if (m_attackAA &lt; 0 || m_attackAAmaxDieSides &lt; -1 || m_attackAAmaxDieSides &gt; 200 || m_offensiveAttackAA &lt; 0</span>
<span class="pc bpc" id="L2646" title="2 of 4 branches missed.">        || m_offensiveAttackAAmaxDieSides &lt; -1 || m_offensiveAttackAAmaxDieSides &gt; 200) {</span>
<span class="nc" id="L2647">      throw new GameParseException(</span>
<span class="nc" id="L2648">          &quot;attackAA or attackAAmaxDieSides or offensiveAttackAA or offensiveAttackAAmaxDieSides is wrong, &quot;</span>
<span class="nc" id="L2649">              + thisErrorMsg());</span>
    }
<span class="pc bpc" id="L2651" title="1 of 4 branches missed.">    if (m_carrierCapacity != -1 &amp;&amp; m_carrierCost != -1) {</span>
<span class="nc" id="L2652">      throw new GameParseException(&quot;carrierCost and carrierCapacity cannot be set at same time, &quot; + thisErrorMsg());</span>
    }
<span class="pc bpc" id="L2654" title="1 of 4 branches missed.">    if (m_transportCost != -1 &amp;&amp; m_transportCapacity != -1) {</span>
<span class="nc" id="L2655">      throw new GameParseException(</span>
<span class="nc" id="L2656">          &quot;transportCost and transportCapacity cannot be set at same time, &quot; + thisErrorMsg());</span>
    }
<span class="pc bpc" id="L2658" title="2 of 8 branches missed.">    if (((m_bombingBonus &gt;= 0 || m_bombingMaxDieSides &gt;= 0) &amp;&amp; !(m_isStrategicBomber || m_isRocket))</span>
<span class="pc bpc" id="L2659" title="2 of 4 branches missed.">        || (m_bombingBonus &lt; -1 || m_bombingMaxDieSides &lt; -1)</span>
<span class="pc bpc" id="L2660" title="2 of 4 branches missed.">        || (m_bombingBonus &gt; 10000 || m_bombingMaxDieSides &gt; 200)) {</span>
<span class="nc" id="L2661">      throw new GameParseException(&quot;something wrong with bombingBonus or bombingMaxDieSides, &quot; + thisErrorMsg());</span>
    }
<span class="pc bpc" id="L2663" title="1 of 2 branches missed.">    if (m_maxBuiltPerPlayer &lt; -1) {</span>
<span class="nc" id="L2664">      throw new GameParseException(&quot;maxBuiltPerPlayer cannot be negative, &quot; + thisErrorMsg());</span>
    }
<span class="pc bpc" id="L2666" title="1 of 4 branches missed.">    if (m_isCombatTransport &amp;&amp; m_transportCapacity &lt; 1) {</span>
<span class="nc" id="L2667">      throw new GameParseException(</span>
<span class="nc" id="L2668">          &quot;cannot have isCombatTransport on unit without transportCapacity, &quot; + thisErrorMsg());</span>
    }
<span class="fc bfc" id="L2670" title="All 6 branches covered.">    if (m_isSea &amp;&amp; m_transportCapacity != -1 &amp;&amp; Properties.getTransportCasualtiesRestricted(data)</span>
<span class="pc bpc" id="L2671" title="2 of 6 branches missed.">        &amp;&amp; (m_attack &gt; 0 || m_defense &gt; 0) &amp;&amp; !m_isCombatTransport) {</span>
<span class="nc" id="L2672">      throw new GameParseException(&quot;Restricted transports cannot have attack or defense, &quot; + thisErrorMsg());</span>
    }
<span class="fc bfc" id="L2674" title="All 2 branches covered.">    if (m_isConstruction</span>
<span class="pc bpc" id="L2675" title="3 of 6 branches missed.">        &amp;&amp; (m_constructionType == null || m_constructionType.equals(&quot;none&quot;) || m_constructionType.equals(&quot;&quot;)</span>
<span class="pc bpc" id="L2676" title="2 of 4 branches missed.">            || m_constructionsPerTerrPerTypePerTurn &lt; 0 || m_maxConstructionsPerTypePerTerr &lt; 0)) {</span>
<span class="nc" id="L2677">      throw new GameParseException(</span>
<span class="nc" id="L2678">          &quot;Constructions must have constructionType and positive constructionsPerTerrPerType and maxConstructionsPerType, &quot;</span>
<span class="nc" id="L2679">              + thisErrorMsg());</span>
    }
<span class="fc bfc" id="L2681" title="All 2 branches covered.">    if (!m_isConstruction</span>
<span class="pc bpc" id="L2682" title="4 of 6 branches missed.">        &amp;&amp; (!(m_constructionType == null || m_constructionType.equals(&quot;none&quot;) || m_constructionType.equals(&quot;&quot;))</span>
<span class="pc bpc" id="L2683" title="2 of 4 branches missed.">            || m_constructionsPerTerrPerTypePerTurn &gt;= 0 || m_maxConstructionsPerTypePerTerr &gt;= 0)) {</span>
<span class="nc" id="L2684">      throw new GameParseException(&quot;Constructions must have isConstruction true, &quot; + thisErrorMsg());</span>
    }
<span class="pc bpc" id="L2686" title="1 of 2 branches missed.">    if (m_constructionsPerTerrPerTypePerTurn &gt; m_maxConstructionsPerTypePerTerr) {</span>
<span class="nc" id="L2687">      throw new GameParseException(</span>
<span class="nc" id="L2688">          &quot;Constructions must have constructionsPerTerrPerTypePerTurn Less than maxConstructionsPerTypePerTerr, &quot;</span>
<span class="nc" id="L2689">              + thisErrorMsg());</span>
    }
<span class="fc bfc" id="L2691" title="All 2 branches covered.">    if (m_unitPlacementRestrictions != null) {</span>
<span class="fc" id="L2692">      getListedTerritories(m_unitPlacementRestrictions);</span>
    }
<span class="pc bpc" id="L2694" title="1 of 2 branches missed.">    if (m_requiresUnits != null) {</span>
<span class="fc bfc" id="L2695" title="All 2 branches covered.">      for (final String[] combo : m_requiresUnits) {</span>
<span class="fc" id="L2696">        getListedUnits(combo);</span>
      }
    }
<span class="pc bpc" id="L2699" title="2 of 8 branches missed.">    if ((m_canBeDamaged &amp;&amp; m_maxDamage &lt; 1) || (m_canDieFromReachingMaxDamage &amp;&amp; m_maxDamage &lt; 1)</span>
<span class="pc bpc" id="L2700" title="1 of 4 branches missed.">        || (!m_canBeDamaged &amp;&amp; m_canDieFromReachingMaxDamage)) {</span>
<span class="nc" id="L2701">      throw new GameParseException(</span>
<span class="nc" id="L2702">          &quot;something wrong with canBeDamaged or maxDamage or canDieFromReachingMaxDamage or isFactory, &quot;</span>
<span class="nc" id="L2703">              + thisErrorMsg());</span>
    }
<span class="pc bpc" id="L2705" title="1 of 4 branches missed.">    if (m_canInvadeOnlyFrom != null &amp;&amp; !m_canInvadeOnlyFrom[0].equals(&quot;all&quot;)</span>
<span class="pc bpc" id="L2706" title="1 of 2 branches missed.">        &amp;&amp; !m_canInvadeOnlyFrom[0].equals(&quot;none&quot;)) {</span>
<span class="fc bfc" id="L2707" title="All 2 branches covered.">      for (final String transport : m_canInvadeOnlyFrom) {</span>
<span class="fc" id="L2708">        final UnitType ut = getData().getUnitTypeList().getUnitType(transport);</span>
<span class="pc bpc" id="L2709" title="1 of 2 branches missed.">        if (ut == null) {</span>
<span class="nc" id="L2710">          throw new GameParseException(&quot;No unit called:&quot; + transport + thisErrorMsg());</span>
        }
<span class="pc bpc" id="L2712" title="2 of 4 branches missed.">        if (ut.getAttachments() == null || ut.getAttachments().isEmpty()) {</span>
<span class="nc" id="L2713">          throw new GameParseException(transport + &quot; has no attachments, please declare &quot; + transport</span>
<span class="nc" id="L2714">              + &quot; in the xml before using it as a transport&quot; + thisErrorMsg());</span>
          // Units may be considered transported if they are on a carrier, or if they are paratroopers, or if they are
          // mech infantry. The
          // &quot;transporter&quot; may not be an actual transport, so we should not check for that here.
        }
      }
    }
<span class="fc bfc" id="L2721" title="All 2 branches covered.">    if (!m_receivesAbilityWhenWith.isEmpty()) {</span>
<span class="fc bfc" id="L2722" title="All 2 branches covered.">      for (final String value : m_receivesAbilityWhenWith) {</span>
        // first is ability, second is unit that we get it from
<span class="fc" id="L2724">        final String[] s = value.split(&quot;:&quot;);</span>
<span class="pc bpc" id="L2725" title="1 of 2 branches missed.">        if (s.length != 2) {</span>
<span class="nc" id="L2726">          throw new GameParseException(&quot;receivesAbilityWhenWith must have 2 parts, 'ability:unit'&quot; + thisErrorMsg());</span>
        }
<span class="pc bpc" id="L2728" title="1 of 2 branches missed.">        if (getData().getUnitTypeList().getUnitType(s[1]) == null) {</span>
<span class="nc" id="L2729">          throw new GameParseException(&quot;receivesAbilityWhenWith, unit does not exist, name:&quot; + s[1] + thisErrorMsg());</span>
        }
        // currently only supports canBlitz (m_canBlitz)
<span class="pc bpc" id="L2732" title="1 of 2 branches missed.">        if (!s[0].equals(&quot;canBlitz&quot;)) {</span>
<span class="nc" id="L2733">          throw new GameParseException(&quot;receivesAbilityWhenWith so far only supports: canBlitz&quot; + thisErrorMsg());</span>
        }
      }
    }
<span class="fc bfc" id="L2737" title="All 2 branches covered.">    if (!m_whenCombatDamaged.isEmpty()) {</span>
<span class="fc bfc" id="L2738" title="All 2 branches covered.">      for (final Tuple&lt;Tuple&lt;Integer, Integer&gt;, Tuple&lt;String, String&gt;&gt; key : m_whenCombatDamaged) {</span>
<span class="fc" id="L2739">        final String obj = key.getSecond().getFirst();</span>
<span class="fc bfc" id="L2740" title="All 2 branches covered.">        if (obj.equals(UNITSMAYNOTLANDONCARRIER)) {</span>
<span class="fc" id="L2741">          continue;</span>
        }
<span class="pc bpc" id="L2743" title="1 of 2 branches missed.">        if (obj.equals(UNITSMAYNOTLEAVEALLIEDCARRIER)) {</span>
<span class="fc" id="L2744">          continue;</span>
        }
<span class="nc" id="L2746">        throw new GameParseException(&quot;m_whenCombatDamaged so far only supports: &quot; + UNITSMAYNOTLANDONCARRIER + &quot;, &quot;</span>
<span class="nc" id="L2747">            + UNITSMAYNOTLEAVEALLIEDCARRIER + thisErrorMsg());</span>
      }
    }
<span class="fc" id="L2750">  }</span>

  public Collection&lt;UnitType&gt; getListedUnits(final String[] list) {
<span class="fc" id="L2753">    final List&lt;UnitType&gt; rVal = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2754" title="All 2 branches covered.">    for (final String name : list) {</span>
      // Validate all units exist
<span class="fc" id="L2756">      final UnitType ut = getData().getUnitTypeList().getUnitType(name);</span>
<span class="pc bpc" id="L2757" title="1 of 2 branches missed.">      if (ut == null) {</span>
<span class="nc" id="L2758">        throw new IllegalStateException(&quot;No unit called: &quot; + name + thisErrorMsg());</span>
      }
<span class="fc" id="L2760">      rVal.add(ut);</span>
    }
<span class="fc" id="L2762">    return rVal;</span>
  }

  public Collection&lt;Territory&gt; getListedTerritories(final String[] list) throws GameParseException {
<span class="fc" id="L2766">    final List&lt;Territory&gt; rVal = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2767" title="All 2 branches covered.">    for (final String name : list) {</span>
      // Validate all territories exist
<span class="fc" id="L2769">      final Territory territory = getData().getMap().getTerritory(name);</span>
<span class="pc bpc" id="L2770" title="1 of 2 branches missed.">      if (territory == null) {</span>
<span class="nc" id="L2771">        throw new GameParseException(&quot;No territory called: &quot; + name + thisErrorMsg());</span>
      }
<span class="fc" id="L2773">      rVal.add(territory);</span>
    }
<span class="fc" id="L2775">    return rVal;</span>
  }

  private boolean playerHasRockets(final PlayerID player) {
<span class="nc" id="L2779">    final TechAttachment ta = (TechAttachment) player.getAttachment(Constants.TECH_ATTACHMENT_NAME);</span>
<span class="nc bnc" id="L2780" title="All 2 branches missed.">    if (ta == null) {</span>
<span class="nc" id="L2781">      return false;</span>
    }
<span class="nc" id="L2783">    return ta.getRocket();</span>
  }

  private boolean playerHasMechInf(final PlayerID player) {
<span class="nc" id="L2787">    final TechAttachment ta = (TechAttachment) player.getAttachment(Constants.TECH_ATTACHMENT_NAME);</span>
<span class="nc bnc" id="L2788" title="All 2 branches missed.">    if (ta == null) {</span>
<span class="nc" id="L2789">      return false;</span>
    }
<span class="nc" id="L2791">    return ta.getMechanizedInfantry();</span>
  }

  private boolean playerHasParatroopers(final PlayerID player) {
<span class="nc" id="L2795">    final TechAttachment ta = (TechAttachment) player.getAttachment(Constants.TECH_ATTACHMENT_NAME);</span>
<span class="nc bnc" id="L2796" title="All 2 branches missed.">    if (ta == null) {</span>
<span class="nc" id="L2797">      return false;</span>
    }
<span class="nc" id="L2799">    return ta.getParatroopers();</span>
  }

  @Override
  public String toString() {
    // Any overriding method for toString on an attachment needs to include at least the Class, m_attachedTo, and
    // m_name. Or call
    // super.toString()
<span class="nc" id="L2807">    return super.toString();</span>
  }

  public String allUnitStatsForExporter() {
    // should cover ALL fields stored in UnitAttachment
    // remember to test for null and fix arrays
    // the stats exporter relies on this toString having two spaces after each entry, so do not change this please,
    // except to add new
    // abilities onto the end
<span class="nc" id="L2816">    return this.getAttachedTo().toString().replaceFirst(&quot;games.strategy.engine.data.&quot;, &quot;&quot;) + &quot; with:&quot; + &quot;  isAir:&quot;</span>
<span class="nc" id="L2817">        + m_isAir + &quot;  isSea:&quot; + m_isSea + &quot;  movement:&quot; + m_movement + &quot;  attack:&quot; + m_attack + &quot;  defense:&quot;</span>
<span class="nc" id="L2818">        + m_defense + &quot;  hitPoints:&quot; + m_hitPoints</span>
        // + &quot; isFactory:&quot; + m_isFactory
<span class="nc" id="L2820">        + &quot;  canBlitz:&quot; + m_canBlitz + &quot;  artillerySupportable:&quot; + m_artillerySupportable + &quot;  artillery:&quot; + m_artillery</span>
<span class="nc" id="L2821">        + &quot;  unitSupportCount:&quot; + m_unitSupportCount + &quot;  attackRolls:&quot; + m_attackRolls + &quot;  defenseRolls:&quot;</span>
<span class="nc" id="L2822">        + m_defenseRolls + &quot;  chooseBestRoll:&quot; + m_chooseBestRoll + &quot;  isMarine:&quot; + m_isMarine + &quot;  isInfantry:&quot;</span>
<span class="nc" id="L2823">        + m_isInfantry + &quot;  isLandTransport:&quot; + m_isLandTransport + &quot;  isAirTransportable:&quot; + m_isAirTransportable</span>
<span class="nc" id="L2824">        + &quot;  isAirTransport:&quot; + m_isAirTransport + &quot;  isStrategicBomber:&quot; + m_isStrategicBomber + &quot;  transportCapacity:&quot;</span>
<span class="nc" id="L2825">        + m_transportCapacity + &quot;  transportCost:&quot; + m_transportCost + &quot;  carrierCapacity:&quot; + m_carrierCapacity</span>
<span class="nc" id="L2826">        + &quot;  carrierCost:&quot; + m_carrierCost + &quot;  isSub:&quot; + m_isSub + &quot;  isDestroyer:&quot; + m_isDestroyer + &quot;  canBombard:&quot;</span>
<span class="nc" id="L2827">        + m_canBombard + &quot;  bombard:&quot; + m_bombard + &quot;  isAAforCombatOnly:&quot; + m_isAAforCombatOnly</span>
<span class="nc" id="L2828">        + &quot;  isAAforBombingThisUnitOnly:&quot; + m_isAAforBombingThisUnitOnly + &quot;  isAAforFlyOverOnly:&quot;</span>
<span class="nc" id="L2829">        + m_isAAforFlyOverOnly + &quot;  attackAA:&quot; + m_attackAA + &quot;  offensiveAttackAA:&quot; + m_offensiveAttackAA</span>
<span class="nc" id="L2830">        + &quot;  attackAAmaxDieSides:&quot; + m_attackAAmaxDieSides + &quot;  offensiveAttackAAmaxDieSides:&quot;</span>
<span class="nc" id="L2831">        + m_offensiveAttackAAmaxDieSides + &quot;  maxAAattacks:&quot; + m_maxAAattacks + &quot;  maxRoundsAA:&quot; + m_maxRoundsAA</span>
<span class="nc" id="L2832">        + &quot;  mayOverStackAA:&quot; + m_mayOverStackAA + &quot;  damageableAA:&quot; + m_damageableAA + &quot;  typeAA:&quot; + m_typeAA</span>
<span class="nc" id="L2833">        + &quot;  targetsAA:&quot;</span>
<span class="nc bnc" id="L2834" title="All 4 branches missed.">        + (m_targetsAA != null ? (m_targetsAA.size() == 0 ? &quot;empty&quot; : m_targetsAA.toString()) : &quot;all air units&quot;)</span>
<span class="nc" id="L2835">        + &quot;  willNotFireIfPresent:&quot;</span>
<span class="nc bnc" id="L2836" title="All 2 branches missed.">        + (m_willNotFireIfPresent != null</span>
<span class="nc bnc" id="L2837" title="All 2 branches missed.">            ? (m_willNotFireIfPresent.size() == 0 ? &quot;empty&quot; : m_willNotFireIfPresent.toString()) : &quot;null&quot;)</span>
<span class="nc" id="L2838">        + &quot;  isRocket:&quot; + m_isRocket + &quot;  canProduceUnits:&quot; + m_canProduceUnits + &quot;  canProduceXUnits:&quot;</span>
<span class="nc" id="L2839">        + m_canProduceXUnits + &quot;  createsUnitsList:&quot;</span>
<span class="nc bnc" id="L2840" title="All 4 branches missed.">        + (m_createsUnitsList != null ? (m_createsUnitsList.size() == 0 ? &quot;empty&quot; : m_createsUnitsList.toString())</span>
<span class="nc" id="L2841">            : &quot;null&quot;)</span>
<span class="nc" id="L2842">        + &quot;  createsResourcesList:&quot;</span>
<span class="nc bnc" id="L2843" title="All 2 branches missed.">        + (m_createsResourcesList != null</span>
<span class="nc bnc" id="L2844" title="All 2 branches missed.">            ? (m_createsResourcesList.size() == 0 ? &quot;empty&quot; : m_createsResourcesList.toString()) : &quot;null&quot;)</span>
<span class="nc bnc" id="L2845" title="All 4 branches missed.">        + &quot;  fuelCost:&quot; + (m_fuelCost != null ? (m_fuelCost.size() == 0 ? &quot;empty&quot; : m_fuelCost.toString()) : &quot;null&quot;)</span>
<span class="nc" id="L2846">        + &quot;  isInfrastructure:&quot; + m_isInfrastructure + &quot;  isConstruction:&quot; + m_isConstruction + &quot;  constructionType:&quot;</span>
<span class="nc" id="L2847">        + m_constructionType + &quot;  constructionsPerTerrPerTypePerTurn:&quot; + m_constructionsPerTerrPerTypePerTurn</span>
<span class="nc" id="L2848">        + &quot;  maxConstructionsPerTypePerTerr:&quot; + m_maxConstructionsPerTypePerTerr + &quot;  destroyedWhenCapturedBy:&quot;</span>
<span class="nc bnc" id="L2849" title="All 2 branches missed.">        + (m_destroyedWhenCapturedBy != null</span>
<span class="nc bnc" id="L2850" title="All 2 branches missed.">            ? (m_destroyedWhenCapturedBy.size() == 0 ? &quot;empty&quot; : m_destroyedWhenCapturedBy.toString()) : &quot;null&quot;)</span>
<span class="nc" id="L2851">        + &quot;  canBeCapturedOnEnteringBy:&quot;</span>
<span class="nc bnc" id="L2852" title="All 2 branches missed.">        + (m_canBeCapturedOnEnteringBy != null</span>
<span class="nc bnc" id="L2853" title="All 2 branches missed.">            ? (m_canBeCapturedOnEnteringBy.size() == 0 ? &quot;empty&quot; : m_canBeCapturedOnEnteringBy.toString()) : &quot;null&quot;)</span>
<span class="nc" id="L2854">        + &quot;  canBeDamaged:&quot; + m_canBeDamaged + &quot;  canDieFromReachingMaxDamage:&quot; + m_canDieFromReachingMaxDamage</span>
<span class="nc" id="L2855">        + &quot;  maxOperationalDamage:&quot; + m_maxOperationalDamage + &quot;  maxDamage:&quot; + m_maxDamage</span>
<span class="nc" id="L2856">        + &quot;  unitPlacementRestrictions:&quot;</span>
<span class="nc bnc" id="L2857" title="All 2 branches missed.">        + (m_unitPlacementRestrictions != null</span>
<span class="nc bnc" id="L2858" title="All 2 branches missed.">            ? (m_unitPlacementRestrictions.length == 0 ? &quot;empty&quot; : Arrays.toString(m_unitPlacementRestrictions))</span>
<span class="nc" id="L2859">            : &quot;null&quot;)</span>
<span class="nc" id="L2860">        + &quot;  requiresUnits:&quot;</span>
<span class="nc bnc" id="L2861" title="All 2 branches missed.">        + (m_requiresUnits != null</span>
<span class="nc bnc" id="L2862" title="All 2 branches missed.">            ? (m_requiresUnits.size() == 0 ? &quot;empty&quot; : MyFormatter.listOfArraysToString(m_requiresUnits)) : &quot;null&quot;)</span>
<span class="nc" id="L2863">        + &quot;  consumesUnits:&quot;</span>
<span class="nc bnc" id="L2864" title="All 4 branches missed.">        + (m_consumesUnits != null ? (m_consumesUnits.size() == 0 ? &quot;empty&quot; : m_consumesUnits.toString()) : &quot;null&quot;)</span>
<span class="nc" id="L2865">        + &quot;  canOnlyBePlacedInTerritoryValuedAtX:&quot; + m_canOnlyBePlacedInTerritoryValuedAtX + &quot;  maxBuiltPerPlayer:&quot;</span>
<span class="nc" id="L2866">        + m_maxBuiltPerPlayer + &quot;  special:&quot;</span>
<span class="nc bnc" id="L2867" title="All 4 branches missed.">        + (m_special != null ? (m_special.size() == 0 ? &quot;empty&quot; : m_special.toString()) : &quot;null&quot;) + &quot;  isSuicide:&quot;</span>
<span class="nc" id="L2868">        + m_isSuicide + &quot;  isSuicide:&quot; + m_isSuicide + &quot;  isCombatTransport:&quot; + m_isCombatTransport</span>
<span class="nc" id="L2869">        + &quot;  canInvadeOnlyFrom:&quot;</span>
<span class="nc bnc" id="L2870" title="All 2 branches missed.">        + (m_canInvadeOnlyFrom != null</span>
<span class="nc bnc" id="L2871" title="All 2 branches missed.">            ? (m_canInvadeOnlyFrom.length == 0 ? &quot;empty&quot; : Arrays.toString(m_canInvadeOnlyFrom)) : &quot;null&quot;)</span>
<span class="nc" id="L2872">        + &quot;  canBeGivenByTerritoryTo:&quot;</span>
<span class="nc bnc" id="L2873" title="All 2 branches missed.">        + (m_canBeGivenByTerritoryTo != null</span>
<span class="nc bnc" id="L2874" title="All 2 branches missed.">            ? (m_canBeGivenByTerritoryTo.size() == 0 ? &quot;empty&quot; : m_canBeGivenByTerritoryTo.toString()) : &quot;null&quot;)</span>
<span class="nc" id="L2875">        + &quot;  receivesAbilityWhenWith:&quot;</span>
<span class="nc bnc" id="L2876" title="All 2 branches missed.">        + (m_receivesAbilityWhenWith != null</span>
<span class="nc bnc" id="L2877" title="All 2 branches missed.">            ? (m_receivesAbilityWhenWith.size() == 0 ? &quot;empty&quot; : m_receivesAbilityWhenWith.toString()) : &quot;null&quot;)</span>
<span class="nc" id="L2878">        + &quot;  whenCombatDamaged:&quot;</span>
<span class="nc bnc" id="L2879" title="All 4 branches missed.">        + (m_whenCombatDamaged != null ? (m_whenCombatDamaged.size() == 0 ? &quot;empty&quot; : m_whenCombatDamaged.toString())</span>
<span class="nc" id="L2880">            : &quot;null&quot;)</span>
<span class="nc" id="L2881">        + &quot;  blockade:&quot; + m_blockade + &quot;  bombingMaxDieSides:&quot; + m_bombingMaxDieSides + &quot;  bombingBonus:&quot;</span>
<span class="nc" id="L2882">        + m_bombingBonus + &quot;  bombingTargets:&quot; + m_bombingTargets + &quot;  givesMovement:&quot;</span>
<span class="nc bnc" id="L2883" title="All 4 branches missed.">        + (m_givesMovement != null ? (m_givesMovement.size() == 0 ? &quot;empty&quot; : m_givesMovement.toString()) : &quot;null&quot;)</span>
<span class="nc" id="L2884">        + &quot;  repairsUnits:&quot;</span>
<span class="nc bnc" id="L2885" title="All 4 branches missed.">        + (m_repairsUnits != null ? (m_repairsUnits.isEmpty() ? &quot;empty&quot; : m_repairsUnits.toString()) : &quot;null&quot;)</span>
<span class="nc" id="L2886">        + &quot;  canScramble:&quot; + m_canScramble + &quot;  maxScrambleDistance:&quot; + m_maxScrambleDistance + &quot;  isAirBase:&quot;</span>
<span class="nc" id="L2887">        + m_isAirBase + &quot;  maxScrambleCount:&quot; + m_maxScrambleCount + &quot;  whenCapturedChangesInto:&quot;</span>
<span class="nc bnc" id="L2888" title="All 2 branches missed.">        + (m_whenCapturedChangesInto != null</span>
<span class="nc bnc" id="L2889" title="All 2 branches missed.">            ? (m_whenCapturedChangesInto.size() == 0 ? &quot;empty&quot; : m_whenCapturedChangesInto.toString()) : &quot;null&quot;)</span>
<span class="nc" id="L2890">        + &quot;  canIntercept:&quot; + m_canIntercept + &quot;  canEscort:&quot; + m_canEscort + &quot;  canAirBattle:&quot; + m_canAirBattle</span>
<span class="nc" id="L2891">        + &quot;  airDefense:&quot; + m_airDefense + &quot;  airAttack:&quot; + m_airAttack + &quot;  canNotMoveDuringCombatMove:&quot;</span>
<span class="nc" id="L2892">        + m_canNotMoveDuringCombatMove + &quot;  movementLimit:&quot;</span>
<span class="nc bnc" id="L2893" title="All 2 branches missed.">        + (m_movementLimit != null ? m_movementLimit.toString() : &quot;null&quot;) + &quot;  attackingLimit:&quot;</span>
<span class="nc bnc" id="L2894" title="All 2 branches missed.">        + (m_attackingLimit != null ? m_attackingLimit.toString() : &quot;null&quot;) + &quot;  placementLimit:&quot;</span>
<span class="nc bnc" id="L2895" title="All 2 branches missed.">        + (m_placementLimit != null ? m_placementLimit.toString() : &quot;null&quot;);</span>
  }

  public String toStringShortAndOnlyImportantDifferences(final PlayerID player, final boolean useHTML,
      final boolean includeAttachedToName) {
    // displays everything in a very short form, in English rather than as xml stuff
    // shows all except for: m_constructionType, m_constructionsPerTerrPerTypePerTurn, m_maxConstructionsPerTypePerTerr,
    // m_canBeGivenByTerritoryTo, m_destroyedWhenCapturedBy, m_canBeCapturedOnEnteringBy
<span class="nc" id="L2903">    final StringBuilder stats = new StringBuilder();</span>
<span class="nc" id="L2904">    final UnitType unitType = (UnitType) this.getAttachedTo();</span>
<span class="nc bnc" id="L2905" title="All 4 branches missed.">    if (includeAttachedToName &amp;&amp; unitType != null) {</span>
<span class="nc" id="L2906">      stats.append(unitType.getName()).append(&quot;:  &quot;);</span>
    }
<span class="nc bnc" id="L2908" title="All 2 branches missed.">    if (getIsAir()) {</span>
<span class="nc" id="L2909">      stats.append(&quot;Air unit, &quot;);</span>
<span class="nc bnc" id="L2910" title="All 2 branches missed.">    } else if (getIsSea()) {</span>
<span class="nc" id="L2911">      stats.append(&quot;Sea unit, &quot;);</span>
<span class="nc" id="L2912">    } else {</span>
<span class="nc" id="L2913">      stats.append(&quot;Land unit, &quot;);</span>
    }
<span class="nc" id="L2915">    final int attackRolls = getAttackRolls(player);</span>
<span class="nc" id="L2916">    final int defenseRolls = getDefenseRolls(player);</span>
<span class="nc bnc" id="L2917" title="All 2 branches missed.">    if (getAttack(player) &gt; 0) {</span>
<span class="nc bnc" id="L2918" title="All 2 branches missed.">      stats.append(attackRolls &gt; 1 ? (attackRolls + &quot;x &quot;) : &quot;&quot;).append(getAttack(player)).append(&quot; Attack, &quot;);</span>
    }
<span class="nc bnc" id="L2920" title="All 2 branches missed.">    if (getDefense(player) &gt; 0) {</span>
<span class="nc bnc" id="L2921" title="All 2 branches missed.">      stats.append(defenseRolls &gt; 1 ? (defenseRolls + &quot;x &quot;) : &quot;&quot;).append(getDefense(player)).append(&quot; Defense, &quot;);</span>
    }
<span class="nc bnc" id="L2923" title="All 2 branches missed.">    if (getMovement(player) &gt; 0) {</span>
<span class="nc" id="L2924">      stats.append(getMovement(player)).append(&quot; Movement, &quot;);</span>
    }
<span class="nc bnc" id="L2926" title="All 2 branches missed.">    if (getHitPoints() &gt; 1) {</span>
<span class="nc" id="L2927">      stats.append(getHitPoints()).append(&quot; Hitpoints, &quot;);</span>
    }
<span class="nc bnc" id="L2929" title="All 4 branches missed.">    if (getCanProduceUnits() &amp;&amp; getCanProduceXUnits() &lt; 0) {</span>
<span class="nc" id="L2930">      stats.append(&quot;can Produce Units Up To Territory Value, &quot;);</span>
<span class="nc bnc" id="L2931" title="All 4 branches missed.">    } else if (getCanProduceUnits() &amp;&amp; getCanProduceXUnits() &gt; 0) {</span>
<span class="nc" id="L2932">      stats.append(&quot;can Produce &quot;).append(getCanProduceXUnits()).append(&quot; Units, &quot;);</span>
    }
<span class="nc bnc" id="L2934" title="All 4 branches missed.">    if (getCreatesUnitsList() != null &amp;&amp; getCreatesUnitsList().size() &gt; 0) {</span>
<span class="nc bnc" id="L2935" title="All 2 branches missed.">      if (getCreatesUnitsList().size() &gt; 4) {</span>
<span class="nc" id="L2936">        stats.append(&quot;Produces &quot;).append(getCreatesUnitsList().totalValues()).append(&quot; Units Each Turn, &quot;);</span>
<span class="nc" id="L2937">      } else {</span>
<span class="nc" id="L2938">        stats.append(&quot;Produces &quot;);</span>
<span class="nc bnc" id="L2939" title="All 2 branches missed.">        for (final Entry&lt;UnitType, Integer&gt; entry : getCreatesUnitsList().entrySet()) {</span>
<span class="nc" id="L2940">          stats.append(entry.getValue()).append(&quot;x&quot;).append(entry.getKey().getName()).append(&quot; &quot;);</span>
        }
<span class="nc" id="L2942">        stats.append(&quot;Each Turn, &quot;);</span>
      }
    }
<span class="nc bnc" id="L2945" title="All 4 branches missed.">    if (getCreatesResourcesList() != null &amp;&amp; getCreatesResourcesList().size() &gt; 0) {</span>
<span class="nc bnc" id="L2946" title="All 2 branches missed.">      if (getCreatesResourcesList().size() &gt; 4) {</span>
<span class="nc" id="L2947">        stats.append(&quot;Produces &quot;).append(getCreatesResourcesList().totalValues()).append(&quot; Resources Each Turn, &quot;);</span>
<span class="nc" id="L2948">      } else {</span>
<span class="nc" id="L2949">        stats.append(&quot;Produces &quot;);</span>
<span class="nc bnc" id="L2950" title="All 2 branches missed.">        for (final Entry&lt;Resource, Integer&gt; entry : getCreatesResourcesList().entrySet()) {</span>
<span class="nc" id="L2951">          stats.append(entry.getValue()).append(&quot;x&quot;).append(entry.getKey().getName()).append(&quot; &quot;);</span>
        }
<span class="nc" id="L2953">        stats.append(&quot;Each Turn, &quot;);</span>
      }
    }
<span class="nc bnc" id="L2956" title="All 4 branches missed.">    if (getFuelCost() != null &amp;&amp; getFuelCost().size() &gt; 0) {</span>
<span class="nc bnc" id="L2957" title="All 2 branches missed.">      if (getFuelCost().size() &gt; 4) {</span>
<span class="nc" id="L2958">        stats.append(&quot;Uses &quot;).append(m_fuelCost.totalValues()).append(&quot; Resources Each movement point, &quot;);</span>
<span class="nc" id="L2959">      } else {</span>
<span class="nc" id="L2960">        stats.append(&quot;Uses &quot;);</span>
<span class="nc bnc" id="L2961" title="All 2 branches missed.">        for (final Entry&lt;Resource, Integer&gt; entry : getFuelCost().entrySet()) {</span>
<span class="nc" id="L2962">          stats.append(entry.getValue()).append(&quot;x&quot;).append(entry.getKey().getName()).append(&quot; &quot;);</span>
        }
<span class="nc" id="L2964">        stats.append(&quot;Each movement point, &quot;);</span>
      }
    }
<span class="nc bnc" id="L2967" title="All 6 branches missed.">    if ((getIsAAforCombatOnly() || getIsAAforBombingThisUnitOnly() || getIsAAforFlyOverOnly())</span>
<span class="nc bnc" id="L2968" title="All 4 branches missed.">        &amp;&amp; (getAttackAA(player) &gt; 0 || getOffensiveAttackAA(player) &gt; 0)) {</span>
<span class="nc bnc" id="L2969" title="All 2 branches missed.">      if (getOffensiveAttackAA(player) &gt; 0) {</span>
<span class="nc" id="L2970">        stats.append(getOffensiveAttackAA(player)).append(&quot;/&quot;).append(</span>
<span class="nc bnc" id="L2971" title="All 2 branches missed.">            getOffensiveAttackAAmaxDieSides() != -1 ? getOffensiveAttackAAmaxDieSides() : getData().getDiceSides())</span>
<span class="nc" id="L2972">            .append(&quot; att &quot;);</span>
      }
<span class="nc bnc" id="L2974" title="All 2 branches missed.">      if (getAttackAA(player) &gt; 0) {</span>
<span class="nc" id="L2975">        stats.append(getAttackAA(player)).append(&quot;/&quot;)</span>
<span class="nc bnc" id="L2976" title="All 2 branches missed.">            .append(getAttackAAmaxDieSides() != -1 ? getAttackAAmaxDieSides() : getData().getDiceSides())</span>
<span class="nc" id="L2977">            .append(&quot; def &quot;);</span>
      }
<span class="nc bnc" id="L2979" title="All 6 branches missed.">      if (getIsAAforCombatOnly() &amp;&amp; getIsAAforBombingThisUnitOnly() &amp;&amp; getIsAAforFlyOverOnly()) {</span>
<span class="nc" id="L2980">        stats.append(getTypeAA()).append(&quot;, &quot;);</span>
<span class="nc bnc" id="L2981" title="All 4 branches missed.">      } else if (getIsAAforCombatOnly() &amp;&amp; getIsAAforFlyOverOnly()</span>
<span class="nc bnc" id="L2982" title="All 2 branches missed.">          &amp;&amp; !games.strategy.triplea.Properties.getAATerritoryRestricted(getData())) {</span>
<span class="nc" id="L2983">        stats.append(getTypeAA()).append(&quot; for Combat &amp; Move Through, &quot;);</span>
<span class="nc bnc" id="L2984" title="All 4 branches missed.">      } else if (getIsAAforBombingThisUnitOnly() &amp;&amp; getIsAAforFlyOverOnly()</span>
<span class="nc bnc" id="L2985" title="All 2 branches missed.">          &amp;&amp; !games.strategy.triplea.Properties.getAATerritoryRestricted(getData())) {</span>
<span class="nc" id="L2986">        stats.append(getTypeAA()).append(&quot; for Raids &amp; Move Through, &quot;);</span>
<span class="nc bnc" id="L2987" title="All 2 branches missed.">      } else if (getIsAAforCombatOnly()) {</span>
<span class="nc" id="L2988">        stats.append(getTypeAA()).append(&quot; for Combat, &quot;);</span>
<span class="nc bnc" id="L2989" title="All 2 branches missed.">      } else if (getIsAAforBombingThisUnitOnly()) {</span>
<span class="nc" id="L2990">        stats.append(getTypeAA()).append(&quot; for Raids, &quot;);</span>
<span class="nc bnc" id="L2991" title="All 2 branches missed.">      } else if (getIsAAforFlyOverOnly()) {</span>
<span class="nc" id="L2992">        stats.append(getTypeAA()).append(&quot; for Move Through, &quot;);</span>
      }
<span class="nc bnc" id="L2994" title="All 2 branches missed.">      if (getMaxAAattacks() &gt; -1) {</span>
<span class="nc" id="L2995">        stats.append(getMaxAAattacks()).append(&quot; &quot;).append(getTypeAA()).append(&quot; Attacks, &quot;);</span>
      }
    }
<span class="nc bnc" id="L2998" title="All 4 branches missed.">    if (getIsRocket() &amp;&amp; playerHasRockets(player)) {</span>
<span class="nc" id="L2999">      stats.append(&quot;can Rocket Attack, &quot;);</span>
<span class="nc" id="L3000">      final int bombingBonus = getBombingBonus();</span>
<span class="nc bnc" id="L3001" title="All 4 branches missed.">      if ((getBombingMaxDieSides() != -1 || bombingBonus != -1)</span>
<span class="nc bnc" id="L3002" title="All 2 branches missed.">          &amp;&amp; games.strategy.triplea.Properties.getUseBombingMaxDiceSidesAndBonus(getData())) {</span>
<span class="nc bnc" id="L3003" title="All 2 branches missed.">        stats.append(bombingBonus != -1 ? bombingBonus + 1 : 1).append(&quot;-&quot;)</span>
<span class="nc bnc" id="L3004" title="All 4 branches missed.">            .append(getBombingMaxDieSides() != -1 ? getBombingMaxDieSides() + (bombingBonus != -1 ? bombingBonus : 0)</span>
<span class="nc bnc" id="L3005" title="All 2 branches missed.">                : getData().getDiceSides() + (bombingBonus != -1 ? bombingBonus : 0))</span>
<span class="nc" id="L3006">            .append(&quot; Rocket Damage, &quot;);</span>
<span class="nc" id="L3007">      } else {</span>
<span class="nc" id="L3008">        stats.append(&quot;1-&quot;).append(getData().getDiceSides()).append(&quot; Rocket Damage, &quot;);</span>
      }
    }
    // line break
<span class="nc bnc" id="L3012" title="All 2 branches missed.">    if (useHTML) {</span>
<span class="nc" id="L3013">      stats.append(&quot;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &quot;);</span>
    }
<span class="nc bnc" id="L3015" title="All 2 branches missed.">    if (getIsInfrastructure()) {</span>
<span class="nc" id="L3016">      stats.append(&quot;can be Captured, &quot;);</span>
    }
<span class="nc bnc" id="L3018" title="All 2 branches missed.">    if (getIsConstruction()) {</span>
<span class="nc" id="L3019">      stats.append(&quot;can be Placed Without Factory, &quot;);</span>
    }
<span class="nc bnc" id="L3021" title="All 2 branches missed.">    if ((getCanBeDamaged())</span>
<span class="nc bnc" id="L3022" title="All 2 branches missed.">        &amp;&amp; games.strategy.triplea.Properties.getDamageFromBombingDoneToUnitsInsteadOfTerritories(getData())) {</span>
<span class="nc" id="L3023">      stats.append(&quot;can be Damaged By Raids, &quot;);</span>
<span class="nc bnc" id="L3024" title="All 2 branches missed.">      if (getMaxOperationalDamage() &gt; -1) {</span>
<span class="nc" id="L3025">        stats.append(getMaxOperationalDamage()).append(&quot; Max Operational Damage, &quot;);</span>
      }
<span class="nc bnc" id="L3027" title="All 4 branches missed.">      if ((getCanProduceUnits()) &amp;&amp; getCanProduceXUnits() &lt; 0) {</span>
<span class="nc bnc" id="L3028" title="All 2 branches missed.">        stats.append(&quot;Total Damage up to &quot;).append(getMaxDamage() &gt; -1 ? getMaxDamage() : 2)</span>
<span class="nc" id="L3029">            .append(&quot;x Territory Value, &quot;);</span>
<span class="nc bnc" id="L3030" title="All 2 branches missed.">      } else if (getMaxDamage() &gt; -1) {</span>
<span class="nc" id="L3031">        stats.append(getMaxDamage()).append(&quot; Max Total Damage, &quot;);</span>
      }
<span class="nc bnc" id="L3033" title="All 2 branches missed.">      if (getCanDieFromReachingMaxDamage()) {</span>
<span class="nc" id="L3034">        stats.append(&quot;will Die If Max Damage Reached, &quot;);</span>
      }
<span class="nc bnc" id="L3036" title="All 2 branches missed.">    } else if (getCanBeDamaged()) {</span>
<span class="nc" id="L3037">      stats.append(&quot;can be Attacked By Raids, &quot;);</span>
    }
<span class="nc bnc" id="L3039" title="All 4 branches missed.">    if (getIsAirBase() &amp;&amp; games.strategy.triplea.Properties.getScramble_Rules_In_Effect(getData())) {</span>
<span class="nc" id="L3040">      stats.append(&quot;can Allow Scrambling, &quot;);</span>
    }
<span class="nc bnc" id="L3042" title="All 4 branches missed.">    if (getCanScramble() &amp;&amp; games.strategy.triplea.Properties.getScramble_Rules_In_Effect(getData())) {</span>
<span class="nc bnc" id="L3043" title="All 2 branches missed.">      stats.append(&quot;can Scramble &quot;).append(getMaxScrambleDistance() &gt; 0 ? getMaxScrambleDistance() : 1)</span>
<span class="nc" id="L3044">          .append(&quot; Distance, &quot;);</span>
    }
<span class="nc bnc" id="L3046" title="All 2 branches missed.">    if (getArtillery()) {</span>
<span class="nc" id="L3047">      stats.append(&quot;can Give Attack Bonus To Other Units, &quot;);</span>
<span class="nc" id="L3048">    } else {</span>
<span class="nc" id="L3049">      final List&lt;UnitSupportAttachment&gt; supports =</span>
<span class="nc" id="L3050">          Match.getMatches(UnitSupportAttachment.get(unitType), Matches.UnitSupportAttachmentCanBeUsedByPlayer(player));</span>
<span class="nc bnc" id="L3051" title="All 2 branches missed.">      if (supports.size() &gt; 0) {</span>
<span class="nc bnc" id="L3052" title="All 2 branches missed.">        if (supports.size() &gt; 2) {</span>
<span class="nc" id="L3053">          stats.append(&quot;can Modify Power Of Other Units, &quot;);</span>
<span class="nc" id="L3054">        } else {</span>
<span class="nc bnc" id="L3055" title="All 2 branches missed.">          for (final UnitSupportAttachment support : supports) {</span>
<span class="nc bnc" id="L3056" title="All 4 branches missed.">            if (support.getUnitType() == null || support.getUnitType().isEmpty()) {</span>
<span class="nc" id="L3057">              continue;</span>
            }
<span class="nc" id="L3059">            stats.append(&quot;gives &quot;).append(support.getBonus())</span>
<span class="nc bnc" id="L3060" title="All 4 branches missed.">                .append(support.getStrength() &amp;&amp; support.getRoll() ? &quot; Power&amp;Rolls&quot;</span>
<span class="nc bnc" id="L3061" title="All 2 branches missed.">                    : (support.getStrength() ? &quot; Power&quot; : &quot; Rolls&quot;))</span>
<span class="nc" id="L3062">                .append(&quot; to &quot;).append(support.getNumber())</span>
<span class="nc bnc" id="L3063" title="All 4 branches missed.">                .append(support.getAllied() &amp;&amp; support.getEnemy() ? &quot; Allied&amp;Enemy &quot;</span>
<span class="nc bnc" id="L3064" title="All 2 branches missed.">                    : (support.getAllied() ? &quot; Allied &quot; : &quot; Enemy &quot;))</span>
<span class="nc bnc" id="L3065" title="All 2 branches missed.">                .append(support.getUnitType().size() &gt; 4 ? &quot;Units&quot;</span>
<span class="nc" id="L3066">                    : MyFormatter.defaultNamedToTextList(support.getUnitType(), &quot;/&quot;, false))</span>
<span class="nc" id="L3067">                .append(&quot; when &quot;)</span>
<span class="nc bnc" id="L3068" title="All 4 branches missed.">                .append(support.getOffence() &amp;&amp; support.getDefence() ? &quot;Att/Def&quot;</span>
<span class="nc bnc" id="L3069" title="All 2 branches missed.">                    : (support.getOffence() ? &quot;Attacking&quot; : &quot;Defending&quot;))</span>
<span class="nc" id="L3070">                .append(&quot;, &quot;);</span>
          }
        }
      }
    }
<span class="nc bnc" id="L3075" title="All 2 branches missed.">    if (getArtillerySupportable()) {</span>
<span class="nc" id="L3076">      stats.append(&quot;can Receive Attack Bonus From Other Units, &quot;);</span>
    }
<span class="nc bnc" id="L3078" title="All 2 branches missed.">    if (getIsMarine() != 0) {</span>
<span class="nc" id="L3079">      stats.append(getIsMarine()).append(&quot; Amphibious Attack Modifier, &quot;);</span>
    }
<span class="nc bnc" id="L3081" title="All 2 branches missed.">    if (getCanBlitz(player)) {</span>
<span class="nc" id="L3082">      stats.append(&quot;can Blitz, &quot;);</span>
    }
<span class="nc bnc" id="L3084" title="All 2 branches missed.">    if (!getReceivesAbilityWhenWith().isEmpty()) {</span>
<span class="nc bnc" id="L3085" title="All 2 branches missed.">      if (getReceivesAbilityWhenWith().size() &lt;= 2) {</span>
<span class="nc bnc" id="L3086" title="All 2 branches missed.">        for (final String ability : getReceivesAbilityWhenWith()) {</span>
<span class="nc" id="L3087">          stats.append(&quot;receives &quot;).append(ability.split(&quot;:&quot;)[0]).append(&quot; when paired with &quot;)</span>
<span class="nc" id="L3088">              .append(ability.split(&quot;:&quot;)[1]).append(&quot;, &quot;);</span>
        }
<span class="nc" id="L3090">      } else {</span>
<span class="nc" id="L3091">        stats.append(&quot;receives Abilities When Paired with Other Units, &quot;);</span>
      }
    }
<span class="nc bnc" id="L3094" title="All 2 branches missed.">    if (getIsStrategicBomber()) {</span>
<span class="nc" id="L3095">      stats.append(&quot;can Perform Raids, &quot;);</span>
<span class="nc" id="L3096">      final int bombingBonus = getBombingBonus();</span>
<span class="nc bnc" id="L3097" title="All 4 branches missed.">      if ((getBombingMaxDieSides() != -1 || bombingBonus != -1)</span>
<span class="nc bnc" id="L3098" title="All 2 branches missed.">          &amp;&amp; games.strategy.triplea.Properties.getUseBombingMaxDiceSidesAndBonus(getData())) {</span>
<span class="nc bnc" id="L3099" title="All 2 branches missed.">        stats.append(bombingBonus != -1 ? bombingBonus + 1 : 1).append(&quot;-&quot;)</span>
<span class="nc bnc" id="L3100" title="All 4 branches missed.">            .append(getBombingMaxDieSides() != -1 ? getBombingMaxDieSides() + (bombingBonus != -1 ? bombingBonus : 0)</span>
<span class="nc bnc" id="L3101" title="All 2 branches missed.">                : getData().getDiceSides() + (bombingBonus != -1 ? bombingBonus : 0))</span>
<span class="nc" id="L3102">            .append(&quot; Raid Damage, &quot;);</span>
<span class="nc" id="L3103">      } else {</span>
<span class="nc" id="L3104">        stats.append(&quot;1-&quot;).append(getData().getDiceSides()).append(&quot; Raid Damage, &quot;);</span>
      }
    }
<span class="nc" id="L3107">    final int airAttack = getAirAttack(player);</span>
<span class="nc" id="L3108">    final int airDefense = getAirDefense(player);</span>
<span class="nc bnc" id="L3109" title="All 8 branches missed.">    if (airAttack &gt; 0 &amp;&amp; (getIsStrategicBomber() || getCanEscort() || getCanAirBattle())) {</span>
<span class="nc bnc" id="L3110" title="All 2 branches missed.">      stats.append(attackRolls &gt; 1 ? (attackRolls + &quot;x &quot;) : &quot;&quot;).append(airAttack).append(&quot; Air Attack, &quot;);</span>
    }
<span class="nc bnc" id="L3112" title="All 6 branches missed.">    if (airDefense &gt; 0 &amp;&amp; (getCanIntercept() || getCanAirBattle())) {</span>
<span class="nc bnc" id="L3113" title="All 2 branches missed.">      stats.append(defenseRolls &gt; 1 ? (defenseRolls + &quot;x &quot;) : &quot;&quot;).append(airAttack).append(&quot; Air Defense, &quot;);</span>
    }
<span class="nc bnc" id="L3115" title="All 2 branches missed.">    if (getIsSub()) {</span>
<span class="nc" id="L3116">      stats.append(&quot;is Stealth, &quot;);</span>
    }
<span class="nc bnc" id="L3118" title="All 2 branches missed.">    if (getIsDestroyer()) {</span>
<span class="nc" id="L3119">      stats.append(&quot;is Anti-Stealth, &quot;);</span>
    }
<span class="nc bnc" id="L3121" title="All 4 branches missed.">    if (getCanBombard(player) &amp;&amp; getBombard(player) &gt; 0) {</span>
<span class="nc" id="L3122">      stats.append(getBombard(player)).append(&quot; Bombard, &quot;);</span>
    }
<span class="nc bnc" id="L3124" title="All 2 branches missed.">    if (getBlockade() &gt; 0) {</span>
<span class="nc" id="L3125">      stats.append(getBlockade()).append(&quot; Blockade Loss, &quot;);</span>
    }
<span class="nc bnc" id="L3127" title="All 2 branches missed.">    if (getIsSuicide()) {</span>
<span class="nc" id="L3128">      stats.append(&quot;Suicide/Munition Unit, &quot;);</span>
    }
<span class="nc bnc" id="L3130" title="All 6 branches missed.">    if (getIsAir() &amp;&amp; (getIsKamikaze() || games.strategy.triplea.Properties.getKamikaze_Airplanes(getData()))) {</span>
<span class="nc" id="L3131">      stats.append(&quot;can use All Movement To Attack Target, &quot;);</span>
    }
<span class="nc bnc" id="L3133" title="All 4 branches missed.">    if (getIsInfantry() &amp;&amp; playerHasMechInf(player)) {</span>
<span class="nc" id="L3134">      stats.append(&quot;can be Transported By Land, &quot;);</span>
    }
<span class="nc bnc" id="L3136" title="All 4 branches missed.">    if (getIsLandTransport() &amp;&amp; playerHasMechInf(player)) {</span>
<span class="nc" id="L3137">      stats.append(&quot;is a Land Transport, &quot;);</span>
    }
<span class="nc bnc" id="L3139" title="All 4 branches missed.">    if (getIsAirTransportable() &amp;&amp; playerHasParatroopers(player)) {</span>
<span class="nc" id="L3140">      stats.append(&quot;can be Transported By Air, &quot;);</span>
    }
<span class="nc bnc" id="L3142" title="All 4 branches missed.">    if (getIsAirTransport() &amp;&amp; playerHasParatroopers(player)) {</span>
<span class="nc" id="L3143">      stats.append(&quot;is an Air Transport, &quot;);</span>
    }
<span class="nc bnc" id="L3145" title="All 4 branches missed.">    if (getIsCombatTransport() &amp;&amp; getTransportCapacity() &gt; 0) {</span>
<span class="nc" id="L3146">      stats.append(&quot;is a Combat Transport, &quot;);</span>
<span class="nc bnc" id="L3147" title="All 4 branches missed.">    } else if (getTransportCapacity() &gt; 0 &amp;&amp; getIsSea()) {</span>
<span class="nc" id="L3148">      stats.append(&quot;is a Sea Transport, &quot;);</span>
    }
<span class="nc bnc" id="L3150" title="All 2 branches missed.">    if (getTransportCost() &gt; -1) {</span>
<span class="nc" id="L3151">      stats.append(getTransportCost()).append(&quot; Transporting Cost, &quot;);</span>
    }
<span class="nc bnc" id="L3153" title="All 4 branches missed.">    if (getTransportCapacity() &gt; 0 &amp;&amp; getIsSea()) {</span>
<span class="nc" id="L3154">      stats.append(getTransportCapacity()).append(&quot; Transporting Capacity, &quot;);</span>
<span class="nc bnc" id="L3155" title="All 6 branches missed.">    } else if (getTransportCapacity() &gt; 0 &amp;&amp; getIsAir() &amp;&amp; playerHasParatroopers(player)) {</span>
<span class="nc" id="L3156">      stats.append(getTransportCapacity()).append(&quot; Transporting Capacity, &quot;);</span>
<span class="nc bnc" id="L3157" title="All 8 branches missed.">    } else if (getTransportCapacity() &gt; 0 &amp;&amp; playerHasMechInf(player) &amp;&amp; !getIsSea() &amp;&amp; !getIsAir()) {</span>
<span class="nc" id="L3158">      stats.append(getTransportCapacity()).append(&quot; Transporting Capacity, &quot;);</span>
    }
<span class="nc bnc" id="L3160" title="All 2 branches missed.">    if (getCarrierCost() &gt; -1) {</span>
<span class="nc" id="L3161">      stats.append(getCarrierCost()).append(&quot; Carrier Cost, &quot;);</span>
    }
<span class="nc bnc" id="L3163" title="All 2 branches missed.">    if (getCarrierCapacity() &gt; 0) {</span>
<span class="nc" id="L3164">      stats.append(getCarrierCapacity()).append(&quot; Carrier Capacity, &quot;);</span>
    }
<span class="nc bnc" id="L3166" title="All 2 branches missed.">    if (!getWhenCombatDamaged().isEmpty()) {</span>
<span class="nc" id="L3167">      stats.append(&quot;when hit this unit loses certain abilities, &quot;);</span>
    }
    // line break
<span class="nc bnc" id="L3170" title="All 2 branches missed.">    if (useHTML) {</span>
<span class="nc" id="L3171">      stats.append(&quot;&lt;br /&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &quot;);</span>
    }
<span class="nc bnc" id="L3173" title="All 2 branches missed.">    if (getMaxBuiltPerPlayer() &gt; -1) {</span>
<span class="nc" id="L3174">      stats.append(getMaxBuiltPerPlayer()).append(&quot; Max Built Allowed, &quot;);</span>
    }
<span class="nc bnc" id="L3176" title="All 4 branches missed.">    if (getRepairsUnits() != null &amp;&amp; !getRepairsUnits().isEmpty()</span>
<span class="nc bnc" id="L3177" title="All 2 branches missed.">        &amp;&amp; games.strategy.triplea.Properties.getTwoHitPointUnitsRequireRepairFacilities(getData())</span>
<span class="nc bnc" id="L3178" title="All 2 branches missed.">        &amp;&amp; (games.strategy.triplea.Properties.getBattleshipsRepairAtBeginningOfRound(getData())</span>
<span class="nc bnc" id="L3179" title="All 2 branches missed.">            || games.strategy.triplea.Properties.getBattleshipsRepairAtEndOfRound(getData()))) {</span>
<span class="nc bnc" id="L3180" title="All 2 branches missed.">      if (getRepairsUnits().size() &lt;= 4) {</span>
<span class="nc" id="L3181">        stats.append(&quot;can Repair: &quot;)</span>
<span class="nc" id="L3182">            .append(MyFormatter.integerDefaultNamedMapToString(getRepairsUnits(), &quot; &quot;, &quot;=&quot;, false)).append(&quot;, &quot;);</span>
<span class="nc" id="L3183">      } else {</span>
<span class="nc" id="L3184">        stats.append(&quot;can Repair Some Units, &quot;);</span>
      }
    }
<span class="nc bnc" id="L3187" title="All 4 branches missed.">    if (getGivesMovement() != null &amp;&amp; getGivesMovement().totalValues() &gt; 0</span>
<span class="nc bnc" id="L3188" title="All 2 branches missed.">        &amp;&amp; games.strategy.triplea.Properties.getUnitsMayGiveBonusMovement(getData())) {</span>
<span class="nc bnc" id="L3189" title="All 2 branches missed.">      if (getGivesMovement().size() &lt;= 4) {</span>
<span class="nc" id="L3190">        stats.append(&quot;can Modify Unit Movement: &quot;)</span>
<span class="nc" id="L3191">            .append(MyFormatter.integerDefaultNamedMapToString(getGivesMovement(), &quot; &quot;, &quot;=&quot;, false)).append(&quot;, &quot;);</span>
<span class="nc" id="L3192">      } else {</span>
<span class="nc" id="L3193">        stats.append(&quot;can Modify Unit Movement, &quot;);</span>
      }
    }
<span class="nc bnc" id="L3196" title="All 4 branches missed.">    if (getConsumesUnits() != null &amp;&amp; getConsumesUnits().totalValues() == 1) {</span>
<span class="nc" id="L3197">      stats.append(&quot;unit is an Upgrade Of &quot;).append(getConsumesUnits().keySet().iterator().next().getName())</span>
<span class="nc" id="L3198">          .append(&quot;, &quot;);</span>
<span class="nc bnc" id="L3199" title="All 4 branches missed.">    } else if (getConsumesUnits() != null &amp;&amp; getConsumesUnits().totalValues() &gt; 0) {</span>
<span class="nc bnc" id="L3200" title="All 2 branches missed.">      if (getConsumesUnits().size() &lt;= 4) {</span>
<span class="nc" id="L3201">        stats.append(&quot;unit Consumes On Placement: &quot;)</span>
<span class="nc" id="L3202">            .append(MyFormatter.integerDefaultNamedMapToString(getConsumesUnits(), &quot; &quot;, &quot;x&quot;, true)).append(&quot;, &quot;);</span>
<span class="nc" id="L3203">      } else {</span>
<span class="nc" id="L3204">        stats.append(&quot;unit Consumes Other Units On Placement, &quot;);</span>
      }
    }
<span class="nc bnc" id="L3207" title="All 4 branches missed.">    if (getRequiresUnits() != null &amp;&amp; getRequiresUnits().size() &gt; 0</span>
<span class="nc bnc" id="L3208" title="All 2 branches missed.">        &amp;&amp; games.strategy.triplea.Properties.getUnitPlacementRestrictions(getData())) {</span>
<span class="nc" id="L3209">      final List&lt;String&gt; totalUnitsListed = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L3210" title="All 2 branches missed.">      for (final String[] list : getRequiresUnits()) {</span>
<span class="nc" id="L3211">        totalUnitsListed.addAll(Arrays.asList(list));</span>
      }
<span class="nc bnc" id="L3213" title="All 2 branches missed.">      if (totalUnitsListed.size() &gt; 4) {</span>
<span class="nc" id="L3214">        stats.append(&quot;unit Requires Other Units Present To Be Placed, &quot;);</span>
<span class="nc" id="L3215">      } else {</span>
<span class="nc" id="L3216">        stats.append(&quot;unit can only be Placed Where There Is: &quot;);</span>
<span class="nc" id="L3217">        final Iterator&lt;String[]&gt; requiredIter = getRequiresUnits().iterator();</span>
<span class="nc bnc" id="L3218" title="All 2 branches missed.">        while (requiredIter.hasNext()) {</span>
<span class="nc" id="L3219">          final String[] required = requiredIter.next();</span>
<span class="nc bnc" id="L3220" title="All 2 branches missed.">          if (required.length == 1) {</span>
<span class="nc" id="L3221">            stats.append(required[0]);</span>
<span class="nc" id="L3222">          } else {</span>
<span class="nc" id="L3223">            stats.append(Arrays.toString(required));</span>
          }
<span class="nc bnc" id="L3225" title="All 2 branches missed.">          if (requiredIter.hasNext()) {</span>
<span class="nc" id="L3226">            stats.append(&quot; Or &quot;);</span>
          }
        }
<span class="nc" id="L3229">        stats.append(&quot;, &quot;);</span>
      }
    }
<span class="nc bnc" id="L3232" title="All 2 branches missed.">    if (getUnitPlacementRestrictions() != null</span>
<span class="nc bnc" id="L3233" title="All 2 branches missed.">        &amp;&amp; games.strategy.triplea.Properties.getUnitPlacementRestrictions(getData())) {</span>
<span class="nc" id="L3234">      stats.append(&quot;has Placement Restrictions, &quot;);</span>
    }
<span class="nc bnc" id="L3236" title="All 2 branches missed.">    if (getCanOnlyBePlacedInTerritoryValuedAtX() &gt; 0</span>
<span class="nc bnc" id="L3237" title="All 2 branches missed.">        &amp;&amp; games.strategy.triplea.Properties.getUnitPlacementRestrictions(getData())) {</span>
<span class="nc" id="L3238">      stats.append(&quot;must be Placed In Territory Valued &gt;=&quot;).append(getCanOnlyBePlacedInTerritoryValuedAtX())</span>
<span class="nc" id="L3239">          .append(&quot;, &quot;);</span>
    }
<span class="nc bnc" id="L3241" title="All 2 branches missed.">    if (getCanNotMoveDuringCombatMove()) {</span>
<span class="nc" id="L3242">      stats.append(&quot;cannot Combat Move, &quot;);</span>
    }
<span class="nc bnc" id="L3244" title="All 2 branches missed.">    if (getMovementLimit() != null) {</span>
<span class="nc bnc" id="L3245" title="All 2 branches missed.">      if (getMovementLimit().getFirst() == Integer.MAX_VALUE</span>
<span class="nc bnc" id="L3246" title="All 4 branches missed.">          &amp;&amp; (getIsAAforBombingThisUnitOnly() || getIsAAforCombatOnly())</span>
<span class="nc bnc" id="L3247" title="All 2 branches missed.">          &amp;&amp; !(games.strategy.triplea.Properties.getWW2V2(getData())</span>
<span class="nc bnc" id="L3248" title="All 2 branches missed.">              || games.strategy.triplea.Properties.getWW2V3(getData())</span>
<span class="nc bnc" id="L3249" title="All 2 branches missed.">              || games.strategy.triplea.Properties.getMultipleAAPerTerritory(getData()))) {</span>
<span class="nc" id="L3250">        stats.append(&quot;max of 1 &quot;).append(getMovementLimit().getSecond()).append(&quot; moving per territory, &quot;);</span>
<span class="nc bnc" id="L3251" title="All 2 branches missed.">      } else if (getMovementLimit().getFirst() &lt; 10000) {</span>
<span class="nc" id="L3252">        stats.append(&quot;max of &quot;).append(getMovementLimit().getFirst()).append(&quot; &quot;).append(getMovementLimit().getSecond())</span>
<span class="nc" id="L3253">            .append(&quot; moving per territory, &quot;);</span>
      }
    }
<span class="nc bnc" id="L3256" title="All 2 branches missed.">    if (getAttackingLimit() != null) {</span>
<span class="nc bnc" id="L3257" title="All 2 branches missed.">      if (getAttackingLimit().getFirst() == Integer.MAX_VALUE</span>
<span class="nc bnc" id="L3258" title="All 4 branches missed.">          &amp;&amp; (getIsAAforBombingThisUnitOnly() || getIsAAforCombatOnly())</span>
<span class="nc bnc" id="L3259" title="All 2 branches missed.">          &amp;&amp; !(games.strategy.triplea.Properties.getWW2V2(getData())</span>
<span class="nc bnc" id="L3260" title="All 2 branches missed.">              || games.strategy.triplea.Properties.getWW2V3(getData())</span>
<span class="nc bnc" id="L3261" title="All 2 branches missed.">              || games.strategy.triplea.Properties.getMultipleAAPerTerritory(getData()))) {</span>
<span class="nc" id="L3262">        stats.append(&quot;max of 1 &quot;).append(getAttackingLimit().getSecond()).append(&quot; attacking per territory, &quot;);</span>
<span class="nc bnc" id="L3263" title="All 2 branches missed.">      } else if (getAttackingLimit().getFirst() &lt; 10000) {</span>
<span class="nc" id="L3264">        stats.append(&quot;max of &quot;).append(getAttackingLimit().getFirst()).append(&quot; &quot;)</span>
<span class="nc" id="L3265">            .append(getAttackingLimit().getSecond()).append(&quot; attacking per territory, &quot;);</span>
      }
    }
<span class="nc bnc" id="L3268" title="All 2 branches missed.">    if (getPlacementLimit() != null) {</span>
<span class="nc bnc" id="L3269" title="All 2 branches missed.">      if (getPlacementLimit().getFirst() == Integer.MAX_VALUE</span>
<span class="nc bnc" id="L3270" title="All 4 branches missed.">          &amp;&amp; (getIsAAforBombingThisUnitOnly() || getIsAAforCombatOnly())</span>
<span class="nc bnc" id="L3271" title="All 2 branches missed.">          &amp;&amp; !(games.strategy.triplea.Properties.getWW2V2(getData())</span>
<span class="nc bnc" id="L3272" title="All 2 branches missed.">              || games.strategy.triplea.Properties.getWW2V3(getData())</span>
<span class="nc bnc" id="L3273" title="All 2 branches missed.">              || games.strategy.triplea.Properties.getMultipleAAPerTerritory(getData()))) {</span>
<span class="nc" id="L3274">        stats.append(&quot;max of 1 &quot;).append(getPlacementLimit().getSecond()).append(&quot; placed per territory, &quot;);</span>
<span class="nc bnc" id="L3275" title="All 2 branches missed.">      } else if (getPlacementLimit().getFirst() &lt; 10000) {</span>
<span class="nc" id="L3276">        stats.append(&quot;max of &quot;).append(getPlacementLimit().getFirst()).append(&quot; &quot;)</span>
<span class="nc" id="L3277">            .append(getPlacementLimit().getSecond()).append(&quot; placed per territory, &quot;);</span>
      }
    }
<span class="nc bnc" id="L3280" title="All 2 branches missed.">    if (stats.indexOf(&quot;, &quot;) &gt; -1) {</span>
<span class="nc" id="L3281">      stats.delete(stats.lastIndexOf(&quot;, &quot;), stats.length() - 1);</span>
    }
<span class="nc" id="L3283">    return stats.toString();</span>
  }

  /** @deprecated does nothing, kept to avoid breaking maps, do not remove */
  @Deprecated
  @GameProperty(xmlProperty = true, gameProperty = false, adds = false)
<span class="nc" id="L3289">  public void setIsParatroop(final String s) {}</span>

  /** @deprecated does nothing, used to keep compatibility with older xml files, do not remove */
  @Deprecated
  @GameProperty(xmlProperty = true, gameProperty = false, adds = false)
<span class="nc" id="L3294">  public void setIsMechanized(final String s) {}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>test (25/nov/2016 10:16:58)</div></body></html>