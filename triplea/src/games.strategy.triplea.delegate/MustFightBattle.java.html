<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>MustFightBattle.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">test (25/nov/2016 10:16:58)</a> &gt; <a href="../../index.html" class="el_group">triplea</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">games.strategy.triplea.delegate</a> &gt; <span class="el_source">MustFightBattle.java</span></div><h1>MustFightBattle.java</h1><pre class="source lang-java linenums"><span class="pc" id="L1">package games.strategy.triplea.delegate;</span>

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import games.strategy.engine.data.Change;
import games.strategy.engine.data.CompositeChange;
import games.strategy.engine.data.GameData;
import games.strategy.engine.data.PlayerID;
import games.strategy.engine.data.Route;
import games.strategy.engine.data.Territory;
import games.strategy.engine.data.TerritoryEffect;
import games.strategy.engine.data.Unit;
import games.strategy.engine.data.UnitType;
import games.strategy.engine.data.changefactory.ChangeFactory;
import games.strategy.engine.delegate.IDelegateBridge;
import games.strategy.engine.message.ConnectionLostException;
import games.strategy.sound.SoundPath;
import games.strategy.triplea.TripleAUnit;
import games.strategy.triplea.attachments.TechAbilityAttachment;
import games.strategy.triplea.attachments.TechAttachment;
import games.strategy.triplea.attachments.UnitAttachment;
import games.strategy.triplea.delegate.dataObjects.BattleRecord;
import games.strategy.triplea.delegate.dataObjects.CasualtyDetails;
import games.strategy.triplea.formatter.MyFormatter;
import games.strategy.triplea.oddsCalculator.ta.BattleResults;
import games.strategy.triplea.ui.display.ITripleADisplay;
import games.strategy.triplea.util.TransportUtils;
import games.strategy.triplea.util.UnitSeperator;
import games.strategy.util.CompositeMatch;
import games.strategy.util.CompositeMatchAnd;
import games.strategy.util.CompositeMatchOr;
import games.strategy.util.IntegerMap;
import games.strategy.util.InverseMatch;
import games.strategy.util.Match;
import games.strategy.util.Util;

/**
 * Handles logic for battles in which fighting actually occurs.
 */
public class MustFightBattle extends AbstractBattle implements BattleStepStrings {
<span class="fc" id="L51">  public static enum ReturnFire {</span>
<span class="fc" id="L52">    ALL, SUBS, NONE</span>
  }
<span class="fc" id="L54">  public static enum RetreatType {</span>
<span class="fc" id="L55">    DEFAULT, SUBS, PLANES, PARTIAL_AMPHIB</span>
  }
  // these class exist for testing
<span class="fc" id="L58">  public static abstract class AttackSubs implements IExecutable {</span>
    private static final long serialVersionUID = 4872551667582174716L;
  }
<span class="fc" id="L61">  public static abstract class DefendSubs implements IExecutable {</span>
    private static final long serialVersionUID = 3768066729336520095L;
  }

  private static final long serialVersionUID = 5879502298361231540L;
  // maps Territory-&gt; units (stores a collection of who is attacking from where, needed for undoing moves)
<span class="fc" id="L67">  private Map&lt;Territory, Collection&lt;Unit&gt;&gt; m_attackingFromMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L68">  private final Collection&lt;Unit&gt; m_attackingWaitingToDie = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L69">  private Set&lt;Territory&gt; m_attackingFrom = new HashSet&lt;&gt;();</span>
<span class="fc" id="L70">  private final Collection&lt;Territory&gt; m_amphibiousAttackFrom = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L71">  private final Collection&lt;Unit&gt; m_defendingWaitingToDie = new ArrayList&lt;&gt;();</span>
  // keep track of all the units that die in the battle to show in the history window
<span class="fc" id="L73">  private final Collection&lt;Unit&gt; m_killed = new ArrayList&lt;&gt;();</span>
  /**
   * Our current execution state, we keep a stack of executables, this allows us to save our state and resume while in
   * the middle of a
   * battle.
   */
<span class="fc" id="L79">  private final ExecutionStack m_stack = new ExecutionStack();</span>
  private List&lt;String&gt; m_stepStrings;
  protected List&lt;Unit&gt; m_defendingAA;
  protected List&lt;Unit&gt; m_offensiveAA;
  protected List&lt;String&gt; m_defendingAAtypes;
  protected List&lt;String&gt; m_offensiveAAtypes;
<span class="fc" id="L85">  private final List&lt;Unit&gt; m_attackingUnitsRetreated = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L86">  private final List&lt;Unit&gt; m_defendingUnitsRetreated = new ArrayList&lt;&gt;();</span>
  // -1 would mean forever until one side is eliminated (the default is infinite)
  private final int m_maxRounds;

  public MustFightBattle(final Territory battleSite, final PlayerID attacker, final GameData data,
      final BattleTracker battleTracker) {
<span class="fc" id="L92">    super(battleSite, attacker, battleTracker, false, BattleType.NORMAL, data);</span>
<span class="fc" id="L93">    m_defendingUnits.addAll(m_battleSite.getUnits().getMatches(Matches.enemyUnit(attacker, data)));</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">    if (battleSite.isWater()) {</span>
<span class="fc" id="L95">      m_maxRounds = games.strategy.triplea.Properties.getSeaBattleRounds(data);</span>
<span class="fc" id="L96">    } else {</span>
<span class="fc" id="L97">      m_maxRounds = games.strategy.triplea.Properties.getLandBattleRounds(data);</span>
    }
<span class="fc" id="L99">  }</span>

  public void resetDefendingUnits(final PlayerID attacker, final GameData data) {
<span class="nc" id="L102">    m_defendingUnits.clear();</span>
<span class="nc" id="L103">    m_defendingUnits.addAll(m_battleSite.getUnits().getMatches(Matches.enemyUnit(attacker, data)));</span>
<span class="nc" id="L104">  }</span>

  /**
   * Used for head-less battles
   *
   * @param defending
   *        - defending units
   * @param attacking
   *        - attacking units
   * @param bombarding
   *        - bombarding units
   * @param defender
   *        - defender PlayerID
   */
  public void setUnits(final Collection&lt;Unit&gt; defending, final Collection&lt;Unit&gt; attacking,
      final Collection&lt;Unit&gt; bombarding, final Collection&lt;Unit&gt; amphibious, final PlayerID defender,
      final Collection&lt;TerritoryEffect&gt; territoryEffects) {
<span class="fc" id="L121">    m_defendingUnits = new ArrayList&lt;&gt;(defending);</span>
<span class="fc" id="L122">    m_attackingUnits = new ArrayList&lt;&gt;(attacking);</span>
<span class="fc" id="L123">    m_bombardingUnits = new ArrayList&lt;&gt;(bombarding);</span>
<span class="fc" id="L124">    m_amphibiousLandAttackers = new ArrayList&lt;&gt;(amphibious);</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">    m_isAmphibious = m_amphibiousLandAttackers.size() &gt; 0;</span>
<span class="fc" id="L126">    m_defender = defender;</span>
<span class="fc" id="L127">    m_territoryEffects = territoryEffects;</span>
<span class="fc" id="L128">  }</span>

  public boolean shouldEndBattleDueToMaxRounds() {
<span class="pc bpc" id="L131" title="3 of 4 branches missed.">    return m_maxRounds &gt; 0 &amp;&amp; m_maxRounds &lt;= m_round;</span>
  }

  private boolean canSubsSubmerge() {
<span class="fc" id="L135">    return games.strategy.triplea.Properties.getSubmersible_Subs(m_data);</span>
  }

  @Override
  public void removeAttack(final Route route, final Collection&lt;Unit&gt; units) {
<span class="fc" id="L140">    m_attackingUnits.removeAll(units);</span>
    // the route could be null, in the case of a unit in a territory where a sub is submerged.
<span class="fc bfc" id="L142" title="All 2 branches covered.">    if (route == null) {</span>
<span class="fc" id="L143">      return;</span>
    }
<span class="fc" id="L145">    final Territory attackingFrom = route.getTerritoryBeforeEnd();</span>
<span class="fc" id="L146">    Collection&lt;Unit&gt; attackingFromMapUnits = m_attackingFromMap.get(attackingFrom);</span>
    // handle possible null pointer
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">    if (attackingFromMapUnits == null) {</span>
<span class="nc" id="L149">      attackingFromMapUnits = new ArrayList&lt;&gt;();</span>
    }
<span class="fc" id="L151">    attackingFromMapUnits.removeAll(units);</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">    if (attackingFromMapUnits.isEmpty()) {</span>
<span class="fc" id="L153">      m_attackingFrom.remove(attackingFrom);</span>
    }
    // deal with amphibious assaults
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">    if (attackingFrom.isWater()) {</span>
<span class="pc bpc" id="L157" title="2 of 6 branches missed.">      if (route.getEnd() != null &amp;&amp; !route.getEnd().isWater() &amp;&amp; Match.someMatch(units, Matches.UnitIsLand)) {</span>
<span class="fc" id="L158">        m_amphibiousLandAttackers.removeAll(Match.getMatches(units, Matches.UnitIsLand));</span>
      }
      // if none of the units is a land unit, the attack from
      // that territory is no longer an amphibious assault
<span class="fc bfc" id="L162" title="All 2 branches covered.">      if (Match.noneMatch(attackingFromMapUnits, Matches.UnitIsLand)) {</span>
<span class="fc" id="L163">        m_amphibiousAttackFrom.remove(attackingFrom);</span>
        // do we have any amphibious attacks left?
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        m_isAmphibious = !m_amphibiousAttackFrom.isEmpty();</span>
      }
    }
<span class="fc" id="L168">    final Iterator&lt;Unit&gt; dependentHolders = m_dependentUnits.keySet().iterator();</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">    while (dependentHolders.hasNext()) {</span>
<span class="fc" id="L170">      final Unit holder = dependentHolders.next();</span>
<span class="fc" id="L171">      final Collection&lt;Unit&gt; dependents = m_dependentUnits.get(holder);</span>
<span class="fc" id="L172">      dependents.removeAll(units);</span>
    }
<span class="fc" id="L174">  }</span>

  @Override
  public boolean isEmpty() {
<span class="fc bfc" id="L178" title="All 4 branches covered.">    return m_attackingUnits.isEmpty() &amp;&amp; m_attackingWaitingToDie.isEmpty();</span>
  }

  @Override
  public Change addAttackChange(final Route route, final Collection&lt;Unit&gt; units,
      final HashMap&lt;Unit, HashSet&lt;Unit&gt;&gt; targets) {
<span class="fc" id="L184">    final CompositeChange change = new CompositeChange();</span>
    // Filter out allied units if WW2V2
<span class="fc" id="L186">    final Match&lt;Unit&gt; ownedBy = Matches.unitIsOwnedBy(m_attacker);</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">    final Collection&lt;Unit&gt; attackingUnits = isWW2V2() ? Match.getMatches(units, ownedBy) : units;</span>
<span class="fc" id="L188">    final Territory attackingFrom = route.getTerritoryBeforeEnd();</span>
<span class="fc" id="L189">    m_attackingFrom.add(attackingFrom);</span>
<span class="fc" id="L190">    m_attackingUnits.addAll(attackingUnits);</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">    if (m_attackingFromMap.get(attackingFrom) == null) {</span>
<span class="fc" id="L192">      m_attackingFromMap.put(attackingFrom, new ArrayList&lt;&gt;());</span>
    }
<span class="fc" id="L194">    final Collection&lt;Unit&gt; attackingFromMapUnits = m_attackingFromMap.get(attackingFrom);</span>
<span class="fc" id="L195">    attackingFromMapUnits.addAll(attackingUnits);</span>
    // are we amphibious
<span class="pc bpc" id="L197" title="1 of 6 branches missed.">    if (route.getStart().isWater() &amp;&amp; route.getEnd() != null &amp;&amp; !route.getEnd().isWater()</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">        &amp;&amp; Match.someMatch(attackingUnits, Matches.UnitIsLand)) {</span>
<span class="fc" id="L199">      m_amphibiousAttackFrom.add(route.getTerritoryBeforeEnd());</span>
<span class="fc" id="L200">      m_amphibiousLandAttackers.addAll(Match.getMatches(attackingUnits, Matches.UnitIsLand));</span>
<span class="fc" id="L201">      m_isAmphibious = true;</span>
    }
<span class="fc" id="L203">    final Map&lt;Unit, Collection&lt;Unit&gt;&gt; dependencies = transporting(units);</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">    if (!isAlliedAirIndependent()) {</span>
<span class="fc" id="L205">      dependencies.putAll(MoveValidator.carrierMustMoveWith(units, units, m_data, m_attacker));</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">      for (final Unit carrier : dependencies.keySet()) {</span>
<span class="fc" id="L207">        final UnitAttachment ua = UnitAttachment.get(carrier.getUnitType());</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        if (ua.getCarrierCapacity() == -1) {</span>
<span class="fc" id="L209">          continue;</span>
        }
<span class="nc" id="L211">        final Collection&lt;Unit&gt; fighters = dependencies.get(carrier);</span>
        // Dependencies count both land and air units. Land units could be allied or owned, while air is just allied
        // since owned already
        // launched at beginning of turn
<span class="nc" id="L215">        fighters.retainAll(Match.getMatches(fighters, Matches.UnitIsAir));</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        for (final Unit fighter : fighters) {</span>
          // Set transportedBy for fighter
<span class="nc" id="L218">          change.add(ChangeFactory.unitPropertyChange(fighter, carrier, TripleAUnit.TRANSPORTED_BY));</span>
        }
        // remove transported fighters from battle display
<span class="nc" id="L221">        m_attackingUnits.removeAll(fighters);</span>
      }
    }
    // Set the dependent paratroopers so they die if the bomber dies.
    // TODO: this might be legacy code that can be deleted since we now keep paratrooper dependencies til they land (but
    // need to double
    // check)
<span class="fc bfc" id="L228" title="All 2 branches covered.">    if (TechAttachment.isAirTransportable(m_attacker)) {</span>
<span class="fc" id="L229">      final Collection&lt;Unit&gt; airTransports = Match.getMatches(units, Matches.UnitIsAirTransport);</span>
<span class="fc" id="L230">      final Collection&lt;Unit&gt; paratroops = Match.getMatches(units, Matches.UnitIsAirTransportable);</span>
<span class="pc bpc" id="L231" title="1 of 4 branches missed.">      if (!airTransports.isEmpty() &amp;&amp; !paratroops.isEmpty()) {</span>
        // Load capable bombers by default&gt;
<span class="fc" id="L233">        final Map&lt;Unit, Unit&gt; unitsToCapableAirTransports =</span>
<span class="fc" id="L234">            TransportUtils.mapTransportsToLoad(paratroops, airTransports);</span>
<span class="fc" id="L235">        final HashMap&lt;Unit, Collection&lt;Unit&gt;&gt; dependentUnits = new HashMap&lt;&gt;();</span>
<span class="fc" id="L236">        final Collection&lt;Unit&gt; singleCollection = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        for (final Unit unit : unitsToCapableAirTransports.keySet()) {</span>
<span class="nc" id="L238">          final Collection&lt;Unit&gt; unitList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L239">          unitList.add(unit);</span>
<span class="nc" id="L240">          final Unit bomber = unitsToCapableAirTransports.get(unit);</span>
<span class="nc" id="L241">          singleCollection.add(unit);</span>
          // Set transportedBy for paratrooper
<span class="nc" id="L243">          change.add(ChangeFactory.unitPropertyChange(unit, bomber, TripleAUnit.TRANSPORTED_BY));</span>
          // Set the dependents
<span class="nc bnc" id="L245" title="All 2 branches missed.">          if (dependentUnits.get(bomber) != null) {</span>
<span class="nc" id="L246">            dependentUnits.get(bomber).addAll(unitList);</span>
<span class="nc" id="L247">          } else {</span>
<span class="nc" id="L248">            dependentUnits.put(bomber, unitList);</span>
          }
        }
<span class="fc" id="L251">        dependencies.putAll(dependentUnits);</span>
<span class="fc" id="L252">        UnitSeperator.categorize(airTransports, dependentUnits, false, false);</span>
      }
    }
<span class="fc" id="L255">    addDependentUnits(dependencies);</span>
    // mark units with no movement
    // for all but air
<span class="fc" id="L258">    Collection&lt;Unit&gt; nonAir = Match.getMatches(attackingUnits, Matches.UnitIsNotAir);</span>
    // we dont want to change the movement of transported land units if this is a sea battle
    // so restrict non air to remove land units
<span class="fc bfc" id="L261" title="All 2 branches covered.">    if (m_battleSite.isWater()) {</span>
<span class="fc" id="L262">      nonAir = Match.getMatches(nonAir, Matches.UnitIsNotLand);</span>
    }
    // TODO This checks for ignored sub/trns and skips the set of the attackers to 0 movement left
    // If attacker stops in an occupied territory, movement stops (battle is optional)
<span class="fc bfc" id="L266" title="All 2 branches covered.">    if (MoveValidator.onlyIgnoredUnitsOnPath(route, m_attacker, m_data, false)) {</span>
<span class="fc" id="L267">      return change;</span>
    }
<span class="fc" id="L269">    change.add(ChangeFactory.markNoMovementChange(nonAir));</span>
<span class="fc" id="L270">    return change;</span>
  }

  public void addDependentUnits(final Map&lt;Unit, Collection&lt;Unit&gt;&gt; dependencies) {
<span class="fc bfc" id="L274" title="All 2 branches covered.">    for (final Unit holder : dependencies.keySet()) {</span>
<span class="fc" id="L275">      final Collection&lt;Unit&gt; transporting = dependencies.get(holder);</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">      if (m_dependentUnits.get(holder) != null) {</span>
<span class="fc" id="L277">        m_dependentUnits.get(holder).addAll(transporting);</span>
<span class="fc" id="L278">      } else {</span>
<span class="fc" id="L279">        m_dependentUnits.put(holder, new LinkedHashSet&lt;&gt;(transporting));</span>
      }
    }
<span class="fc" id="L282">  }</span>

  private String getBattleTitle() {
<span class="fc" id="L285">    return m_attacker.getName() + &quot; attack &quot; + m_defender.getName() + &quot; in &quot; + m_battleSite.getName();</span>
  }

  public void updateDefendingAAUnits() {
<span class="fc" id="L289">    final Collection&lt;Unit&gt; canFire = new ArrayList&lt;&gt;(m_defendingUnits.size() + m_defendingWaitingToDie.size());</span>
<span class="fc" id="L290">    canFire.addAll(m_defendingUnits);</span>
<span class="fc" id="L291">    canFire.addAll(m_defendingWaitingToDie);</span>
<span class="fc" id="L292">    final HashMap&lt;String, HashSet&lt;UnitType&gt;&gt; airborneTechTargetsAllowed =</span>
<span class="fc" id="L293">        TechAbilityAttachment.getAirborneTargettedByAA(m_attacker, m_data);</span>
<span class="fc" id="L294">    m_defendingAA = Match.getMatches(canFire, Matches.UnitIsAAthatCanFire(m_attackingUnits, airborneTechTargetsAllowed,</span>
<span class="fc" id="L295">        m_attacker, Matches.UnitIsAAforCombatOnly, m_round, true, m_data));</span>
    // comes ordered alphabetically
<span class="fc" id="L297">    m_defendingAAtypes = UnitAttachment.getAllOfTypeAAs(m_defendingAA);</span>
    // stacks are backwards
<span class="fc" id="L299">    Collections.reverse(m_defendingAAtypes);</span>
<span class="fc" id="L300">  }</span>

  public void updateOffensiveAAUnits() {
<span class="fc" id="L303">    final Collection&lt;Unit&gt; canFire = new ArrayList&lt;&gt;(m_attackingUnits.size() + m_attackingWaitingToDie.size());</span>
<span class="fc" id="L304">    canFire.addAll(m_attackingUnits);</span>
<span class="fc" id="L305">    canFire.addAll(m_attackingWaitingToDie);</span>
    // no airborne targets for offensive aa
<span class="fc" id="L307">    m_offensiveAA = Match.getMatches(canFire, Matches.UnitIsAAthatCanFire(m_defendingUnits,</span>
<span class="fc" id="L308">        new HashMap&lt;&gt;(), m_defender, Matches.UnitIsAAforCombatOnly, m_round, false, m_data));</span>
    // comes ordered alphabetically
<span class="fc" id="L310">    m_offensiveAAtypes = UnitAttachment.getAllOfTypeAAs(m_offensiveAA);</span>
    // stacks are backwards
<span class="fc" id="L312">    Collections.reverse(m_offensiveAAtypes);</span>
<span class="fc" id="L313">  }</span>

  @Override
  public void fight(final IDelegateBridge bridge) {
    // remove units that may already be dead due to a previous event (like they died from a strategic bombing raid,
    // rocket attack, etc)
<span class="fc" id="L319">    removeUnitsThatNoLongerExist();</span>
    // we have already started
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">    if (m_stack.isExecuting()) {</span>
<span class="nc" id="L322">      final ITripleADisplay display = getDisplay(bridge);</span>
<span class="nc" id="L323">      display.showBattle(m_battleID, m_battleSite, getBattleTitle(),</span>
<span class="nc" id="L324">          removeNonCombatants(m_attackingUnits, true, m_attacker, false, false, false),</span>
<span class="nc" id="L325">          removeNonCombatants(m_defendingUnits, false, m_defender, false, false, false), m_killed,</span>
<span class="nc" id="L326">          m_attackingWaitingToDie, m_defendingWaitingToDie, m_dependentUnits, m_attacker, m_defender, isAmphibious(),</span>
<span class="nc" id="L327">          getBattleType(), m_amphibiousLandAttackers);</span>
<span class="nc" id="L328">      display.listBattleSteps(m_battleID, m_stepStrings);</span>
<span class="nc" id="L329">      m_stack.execute(bridge);</span>
<span class="nc" id="L330">      return;</span>
    }
<span class="fc" id="L332">    bridge.getHistoryWriter().startEvent(&quot;Battle in &quot; + m_battleSite, m_battleSite);</span>
<span class="fc" id="L333">    removeAirNoLongerInTerritory();</span>
<span class="fc" id="L334">    writeUnitsToHistory(bridge);</span>
    // it is possible that no attacking units are present, if so end now
    // changed to only look at units that can be destroyed in combat, and therefore not include factories, aaguns, and
    // infrastructure.
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">    if (Match.getMatches(m_attackingUnits, Matches.UnitIsNotInfrastructure).size() == 0) {</span>
<span class="nc" id="L339">      endBattle(bridge);</span>
<span class="nc" id="L340">      defenderWins(bridge);</span>
<span class="nc" id="L341">      return;</span>
    }
    // it is possible that no defending units exist
    // changed to only look at units that can be destroyed in combat, and therefore not include factories, aaguns, and
    // infrastructure.
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">    if (Match.getMatches(m_defendingUnits, Matches.UnitIsNotInfrastructure).size() == 0) {</span>
<span class="nc" id="L347">      endBattle(bridge);</span>
<span class="nc" id="L348">      attackerWins(bridge);</span>
<span class="nc" id="L349">      return;</span>
    }
<span class="fc" id="L351">    addDependentUnits(transporting(m_defendingUnits));</span>
<span class="fc" id="L352">    addDependentUnits(transporting(m_attackingUnits));</span>
    // determine any AA
<span class="fc" id="L354">    updateOffensiveAAUnits();</span>
<span class="fc" id="L355">    updateDefendingAAUnits();</span>
    // list the steps
<span class="fc" id="L357">    m_stepStrings = determineStepStrings(true, bridge);</span>
<span class="fc" id="L358">    final ITripleADisplay display = getDisplay(bridge);</span>
<span class="fc" id="L359">    display.showBattle(m_battleID, m_battleSite, getBattleTitle(),</span>
<span class="fc" id="L360">        removeNonCombatants(m_attackingUnits, true, m_attacker, false, false, false),</span>
<span class="fc" id="L361">        removeNonCombatants(m_defendingUnits, false, m_defender, false, false, false), m_killed,</span>
<span class="fc" id="L362">        m_attackingWaitingToDie, m_defendingWaitingToDie, m_dependentUnits, m_attacker, m_defender, isAmphibious(),</span>
<span class="fc" id="L363">        getBattleType(), m_amphibiousLandAttackers);</span>
<span class="fc" id="L364">    display.listBattleSteps(m_battleID, m_stepStrings);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">    if (!m_headless) {</span>
      // take the casualties with least movement first
<span class="fc bfc" id="L367" title="All 2 branches covered.">      if (isAmphibious()) {</span>
<span class="fc" id="L368">        sortAmphib(m_attackingUnits, m_data);</span>
<span class="fc" id="L369">      } else {</span>
<span class="fc" id="L370">        BattleCalculator.sortPreBattle(m_attackingUnits);</span>
      }
<span class="fc" id="L372">      BattleCalculator.sortPreBattle(m_defendingUnits);</span>
      // play a sound
<span class="fc bfc" id="L374" title="All 2 branches covered.">      if (Match.someMatch(m_attackingUnits, Matches.UnitIsSea)</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">          || Match.someMatch(m_defendingUnits, Matches.UnitIsSea)) {</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (Match.allMatch(m_attackingUnits, Matches.UnitIsSub)</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">            || (Match.someMatch(m_attackingUnits, Matches.UnitIsSub)</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">                &amp;&amp; Match.someMatch(m_defendingUnits, Matches.UnitIsSub))) {</span>
<span class="fc" id="L379">          bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_SEA_SUBS, m_attacker);</span>
<span class="fc" id="L380">        } else {</span>
<span class="fc" id="L381">          bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_SEA_NORMAL, m_attacker);</span>
        }
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">      } else if (Match.allMatch(m_attackingUnits, Matches.UnitIsAir)</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">          &amp;&amp; Match.allMatch(m_defendingUnits, Matches.UnitIsAir)) {</span>
<span class="nc" id="L385">        bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_AIR, m_attacker);</span>
<span class="nc" id="L386">      } else {</span>
<span class="fc" id="L387">        bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_LAND, m_attacker);</span>
      }
    }
    // push on stack in opposite order of execution
<span class="fc" id="L391">    pushFightLoopOnStack(true, bridge);</span>
<span class="fc" id="L392">    m_stack.execute(bridge);</span>
<span class="fc" id="L393">  }</span>

  private void writeUnitsToHistory(final IDelegateBridge bridge) {
<span class="fc bfc" id="L396" title="All 2 branches covered.">    if (m_headless) {</span>
<span class="fc" id="L397">      return;</span>
    }
<span class="fc" id="L399">    final Set&lt;PlayerID&gt; playerSet = m_battleSite.getUnits().getPlayersWithUnits();</span>
    String transcriptText;
    // find all attacking players (unsorted)
<span class="fc" id="L402">    final Collection&lt;PlayerID&gt; attackers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L403">    final Collection&lt;Unit&gt; allAttackingUnits = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L404">    transcriptText = &quot;&quot;;</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">    for (final PlayerID current : playerSet) {</span>
<span class="pc bpc" id="L406" title="1 of 4 branches missed.">      if (m_data.getRelationshipTracker().isAllied(m_attacker, current) || current.equals(m_attacker)) {</span>
<span class="fc" id="L407">        attackers.add(current);</span>
      }
    }
    // find all attacking units (unsorted)
<span class="fc bfc" id="L411" title="All 2 branches covered.">    for (final Iterator&lt;PlayerID&gt; attackersIter = attackers.iterator(); attackersIter.hasNext();) {</span>
<span class="fc" id="L412">      final PlayerID current = attackersIter.next();</span>
      String delim;
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">      if (attackersIter.hasNext()) {</span>
<span class="nc" id="L415">        delim = &quot;; &quot;;</span>
<span class="nc" id="L416">      } else {</span>
<span class="fc" id="L417">        delim = &quot;&quot;;</span>
      }
<span class="fc" id="L419">      final Collection&lt;Unit&gt; attackingUnits = Match.getMatches(m_attackingUnits, Matches.unitIsOwnedBy(current));</span>
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">      final String verb = current.equals(m_attacker) ? &quot;attack&quot; : &quot;loiter and taunt&quot;;</span>
<span class="fc" id="L421">      transcriptText += current.getName() + &quot; &quot; + verb</span>
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">          + (attackingUnits.isEmpty() ? &quot;&quot; : &quot; with &quot; + MyFormatter.unitsToTextNoOwner(attackingUnits)) + delim;</span>
<span class="fc" id="L423">      allAttackingUnits.addAll(attackingUnits);</span>
      // If any attacking transports are in the battle, set their status to later restrict load/unload
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">      if (current.equals(m_attacker)) {</span>
<span class="fc" id="L426">        final CompositeChange change = new CompositeChange();</span>
<span class="fc" id="L427">        final Collection&lt;Unit&gt; transports = Match.getMatches(attackingUnits, Matches.UnitCanTransport);</span>
<span class="fc" id="L428">        final Iterator&lt;Unit&gt; attackTranIter = transports.iterator();</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">        while (attackTranIter.hasNext()) {</span>
<span class="fc" id="L430">          change.add(ChangeFactory.unitPropertyChange(attackTranIter.next(), true, TripleAUnit.WAS_IN_COMBAT));</span>
        }
<span class="fc" id="L432">        bridge.addChange(change);</span>
      }
    }
    // write attacking units to history
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">    if (m_attackingUnits.size() &gt; 0) {</span>
<span class="fc" id="L437">      bridge.getHistoryWriter().addChildToEvent(transcriptText, allAttackingUnits);</span>
    }
    // find all defending players (unsorted)
<span class="fc" id="L440">    final Collection&lt;PlayerID&gt; defenders = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L441">    final Collection&lt;Unit&gt; allDefendingUnits = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L442">    transcriptText = &quot;&quot;;</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">    for (final PlayerID current : playerSet) {</span>
<span class="pc bpc" id="L444" title="1 of 4 branches missed.">      if (m_data.getRelationshipTracker().isAllied(m_defender, current) || current.equals(m_defender)) {</span>
<span class="fc" id="L445">        defenders.add(current);</span>
      }
    }
    // find all defending units (unsorted)
<span class="fc bfc" id="L449" title="All 2 branches covered.">    for (final Iterator&lt;PlayerID&gt; defendersIter = defenders.iterator(); defendersIter.hasNext();) {</span>
<span class="fc" id="L450">      final PlayerID current = defendersIter.next();</span>
      Collection&lt;Unit&gt; defendingUnits;
      String delim;
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">      if (defendersIter.hasNext()) {</span>
<span class="nc" id="L454">        delim = &quot;; &quot;;</span>
<span class="nc" id="L455">      } else {</span>
<span class="fc" id="L456">        delim = &quot;&quot;;</span>
      }
<span class="fc" id="L458">      defendingUnits = Match.getMatches(m_defendingUnits, Matches.unitIsOwnedBy(current));</span>
<span class="fc" id="L459">      transcriptText += current.getName() + &quot; defend with &quot; + MyFormatter.unitsToTextNoOwner(defendingUnits) + delim;</span>
<span class="fc" id="L460">      allDefendingUnits.addAll(defendingUnits);</span>
    }
    // write defending units to history
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">    if (m_defendingUnits.size() &gt; 0) {</span>
<span class="fc" id="L464">      bridge.getHistoryWriter().addChildToEvent(transcriptText, allDefendingUnits);</span>
    }
<span class="fc" id="L466">  }</span>

  private void removeAirNoLongerInTerritory() {
<span class="fc bfc" id="L469" title="All 2 branches covered.">    if (m_headless) {</span>
<span class="fc" id="L470">      return;</span>
    }
    // remove any air units that were once in this attack, but have now
    // moved out of the territory
    // this is an ilegant way to handle this bug
<span class="fc" id="L475">    final CompositeMatch&lt;Unit&gt; airNotInTerritory = new CompositeMatchAnd&lt;&gt;();</span>
<span class="fc" id="L476">    airNotInTerritory.add(new InverseMatch&lt;&gt;(Matches.unitIsInTerritory(m_battleSite)));</span>
<span class="fc" id="L477">    m_attackingUnits.removeAll(Match.getMatches(m_attackingUnits, airNotInTerritory));</span>
<span class="fc" id="L478">  }</span>

  public List&lt;String&gt; determineStepStrings(final boolean showFirstRun, final IDelegateBridge bridge) {
<span class="fc" id="L481">    final List&lt;String&gt; steps = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">    if (canFireOffensiveAA()) {</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">      for (final String typeAA : UnitAttachment.getAllOfTypeAAs(m_offensiveAA)) {</span>
<span class="nc" id="L484">        steps.add(m_attacker.getName() + &quot; &quot; + typeAA + AA_GUNS_FIRE_SUFFIX);</span>
<span class="nc" id="L485">        steps.add(m_defender.getName() + SELECT_PREFIX + typeAA + CASUALTIES_SUFFIX);</span>
<span class="nc" id="L486">        steps.add(m_defender.getName() + REMOVE_PREFIX + typeAA + CASUALTIES_SUFFIX);</span>
      }
    }
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">    if (canFireDefendingAA()) {</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">      for (final String typeAA : UnitAttachment.getAllOfTypeAAs(m_defendingAA)) {</span>
<span class="nc" id="L491">        steps.add(m_defender.getName() + &quot; &quot; + typeAA + AA_GUNS_FIRE_SUFFIX);</span>
<span class="nc" id="L492">        steps.add(m_attacker.getName() + SELECT_PREFIX + typeAA + CASUALTIES_SUFFIX);</span>
<span class="nc" id="L493">        steps.add(m_attacker.getName() + REMOVE_PREFIX + typeAA + CASUALTIES_SUFFIX);</span>
      }
    }
<span class="fc bfc" id="L496" title="All 2 branches covered.">    if (showFirstRun) {</span>
<span class="fc bfc" id="L497" title="All 4 branches covered.">      if (!m_battleSite.isWater() &amp;&amp; !getBombardingUnits().isEmpty()) {</span>
<span class="fc" id="L498">        steps.add(NAVAL_BOMBARDMENT);</span>
<span class="fc" id="L499">        steps.add(SELECT_NAVAL_BOMBARDMENT_CASUALTIES);</span>
      }
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">      if (Match.someMatch(m_attackingUnits, Matches.UnitIsSuicide)) {</span>
<span class="nc" id="L502">        steps.add(SUICIDE_ATTACK);</span>
<span class="nc" id="L503">        steps.add(m_defender.getName() + SELECT_CASUALTIES_SUICIDE);</span>
      }
<span class="pc bpc" id="L505" title="3 of 4 branches missed.">      if (Match.someMatch(m_defendingUnits, Matches.UnitIsSuicide) &amp;&amp; !isDefendingSuicideAndMunitionUnitsDoNotFire()) {</span>
<span class="nc" id="L506">        steps.add(SUICIDE_DEFEND);</span>
<span class="nc" id="L507">        steps.add(m_attacker.getName() + SELECT_CASUALTIES_SUICIDE);</span>
      }
<span class="pc bpc" id="L509" title="1 of 4 branches missed.">      if (!m_battleSite.isWater() &amp;&amp; TechAttachment.isAirTransportable(m_attacker)) {</span>
<span class="nc" id="L510">        final Collection&lt;Unit&gt; bombers =</span>
<span class="nc" id="L511">            Match.getMatches(m_battleSite.getUnits().getUnits(), Matches.UnitIsAirTransport);</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">        if (!bombers.isEmpty()) {</span>
<span class="nc" id="L513">          final Collection&lt;Unit&gt; dependents = getDependentUnits(bombers);</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">          if (!dependents.isEmpty()) {</span>
<span class="nc" id="L515">            steps.add(LAND_PARATROOPS);</span>
          }
        }
      }
    }
    // Check if defending subs can submerge before battle
<span class="fc bfc" id="L521" title="All 2 branches covered.">    if (isSubRetreatBeforeBattle()) {</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">      if (!Match.someMatch(m_defendingUnits, Matches.UnitIsDestroyer)</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">          &amp;&amp; Match.someMatch(m_attackingUnits, Matches.UnitIsSub)) {</span>
<span class="fc" id="L524">        steps.add(m_attacker.getName() + SUBS_SUBMERGE);</span>
      }
<span class="fc bfc" id="L526" title="All 2 branches covered.">      if (!Match.someMatch(m_attackingUnits, Matches.UnitIsDestroyer)</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">          &amp;&amp; Match.someMatch(m_defendingUnits, Matches.UnitIsSub)) {</span>
<span class="fc" id="L528">        steps.add(m_defender.getName() + SUBS_SUBMERGE);</span>
      }
    }
    // See if there any unescorted trns
<span class="fc bfc" id="L532" title="All 4 branches covered.">    if (m_battleSite.isWater() &amp;&amp; isTransportCasualtiesRestricted()) {</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">      if (Match.someMatch(m_attackingUnits, Matches.UnitIsTransport)</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">          || Match.someMatch(m_defendingUnits, Matches.UnitIsTransport)) {</span>
<span class="fc" id="L535">        steps.add(REMOVE_UNESCORTED_TRANSPORTS);</span>
      }
    }
    // if attacker has no sneak attack subs, then defendering sneak attack subs fire first and remove casualties
<span class="fc" id="L539">    final boolean defenderSubsFireFirst = defenderSubsFireFirst();</span>
<span class="pc bpc" id="L540" title="1 of 4 branches missed.">    if (defenderSubsFireFirst &amp;&amp; Match.someMatch(m_defendingUnits, Matches.UnitIsSub)) {</span>
<span class="fc" id="L541">      steps.add(m_defender.getName() + SUBS_FIRE);</span>
<span class="fc" id="L542">      steps.add(m_attacker.getName() + SELECT_SUB_CASUALTIES);</span>
<span class="fc" id="L543">      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);</span>
    }
<span class="fc bfc" id="L545" title="All 2 branches covered.">    final boolean onlyAttackerSneakAttack = !defenderSubsFireFirst</span>
<span class="pc bpc" id="L546" title="1 of 4 branches missed.">        &amp;&amp; returnFireAgainstAttackingSubs() == ReturnFire.NONE &amp;&amp; returnFireAgainstDefendingSubs() == ReturnFire.ALL;</span>
    // attacker subs sneak attack
    // Attacking subs have no sneak attack if Destroyers are present
<span class="fc bfc" id="L549" title="All 2 branches covered.">    if (m_battleSite.isWater()) {</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">      if (Match.someMatch(m_attackingUnits, Matches.UnitIsSub)) {</span>
<span class="fc" id="L551">        steps.add(m_attacker.getName() + SUBS_FIRE);</span>
<span class="fc" id="L552">        steps.add(m_defender.getName() + SELECT_SUB_CASUALTIES);</span>
      }
<span class="fc bfc" id="L554" title="All 2 branches covered.">      if (onlyAttackerSneakAttack) {</span>
<span class="fc" id="L555">        steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);</span>
      }
    }
    // ww2v2 rules, all subs fire FIRST in combat, regardless of presence of destroyers.
<span class="fc bfc" id="L559" title="All 2 branches covered.">    final boolean defendingSubsFireWithAllDefenders = !defenderSubsFireFirst</span>
<span class="fc bfc" id="L560" title="All 4 branches covered.">        &amp;&amp; !games.strategy.triplea.Properties.getWW2V2(m_data) &amp;&amp; returnFireAgainstDefendingSubs() == ReturnFire.ALL;</span>
    // defender subs sneak attack
    // Defending subs have no sneak attack in Pacific/Europe Theaters or if Destroyers are present
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">    final boolean defendingSubsFireWithAllDefendersAlways = !defendingSubsSneakAttack3();</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">    if (m_battleSite.isWater()) {</span>
<span class="pc bpc" id="L565" title="1 of 6 branches missed.">      if (!defendingSubsFireWithAllDefendersAlways &amp;&amp; !defendingSubsFireWithAllDefenders &amp;&amp; !defenderSubsFireFirst</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">          &amp;&amp; Match.someMatch(m_defendingUnits, Matches.UnitIsSub)) {</span>
<span class="fc" id="L567">        steps.add(m_defender.getName() + SUBS_FIRE);</span>
<span class="fc" id="L568">        steps.add(m_attacker.getName() + SELECT_SUB_CASUALTIES);</span>
      }
    }
<span class="fc bfc" id="L571" title="All 6 branches covered.">    if (m_battleSite.isWater() &amp;&amp; !defenderSubsFireFirst &amp;&amp; !onlyAttackerSneakAttack</span>
<span class="fc bfc" id="L572" title="All 4 branches covered.">        &amp;&amp; (returnFireAgainstDefendingSubs() != ReturnFire.ALL || returnFireAgainstAttackingSubs() != ReturnFire.ALL)) {</span>
<span class="fc" id="L573">      steps.add(REMOVE_SNEAK_ATTACK_CASUALTIES);</span>
    }
    // Air only Units can't attack subs without Destroyers present
<span class="fc bfc" id="L576" title="All 2 branches covered.">    if (isAirAttackSubRestricted()) {</span>
<span class="fc" id="L577">      final Collection&lt;Unit&gt; units = new ArrayList&lt;&gt;(m_attackingUnits.size() + m_attackingWaitingToDie.size());</span>
<span class="fc" id="L578">      units.addAll(m_attackingUnits);</span>
      // if(!Match.someMatch(m_attackingUnits, Matches.UnitIsDestroyer) &amp;&amp; Match.allMatch(m_attackingUnits,
      // Matches.UnitIsAir))
<span class="pc bpc" id="L581" title="1 of 4 branches missed.">      if (Match.someMatch(m_attackingUnits, Matches.UnitIsAir) &amp;&amp; !canAirAttackSubs(m_defendingUnits, units)) {</span>
<span class="nc" id="L582">        steps.add(SUBMERGE_SUBS_VS_AIR_ONLY);</span>
      }
    }
    // Air Units can't attack subs without Destroyers present
<span class="fc bfc" id="L586" title="All 4 branches covered.">    if (m_battleSite.isWater() &amp;&amp; isAirAttackSubRestricted()) {</span>
<span class="fc" id="L587">      final Collection&lt;Unit&gt; units = new ArrayList&lt;&gt;(m_attackingUnits.size() + m_attackingWaitingToDie.size());</span>
<span class="fc" id="L588">      units.addAll(m_attackingUnits);</span>
      // if(!Match.someMatch(m_attackingUnits, Matches.UnitIsDestroyer) &amp;&amp; Match.someMatch(m_attackingUnits,
      // Matches.UnitIsAir) &amp;&amp;
      // Match.someMatch(m_defendingUnits, Matches.UnitIsSub))
<span class="pc bpc" id="L592" title="1 of 4 branches missed.">      if (Match.someMatch(m_attackingUnits, Matches.UnitIsAir) &amp;&amp; !canAirAttackSubs(m_defendingUnits, units)) {</span>
<span class="nc" id="L593">        steps.add(AIR_ATTACK_NON_SUBS);</span>
      }
    }
<span class="fc bfc" id="L596" title="All 2 branches covered.">    if (Match.someMatch(m_attackingUnits, Matches.UnitIsNotSub)) {</span>
<span class="fc" id="L597">      steps.add(m_attacker.getName() + FIRE);</span>
<span class="fc" id="L598">      steps.add(m_defender.getName() + SELECT_CASUALTIES);</span>
    }
    // classic rules, subs fire with all defenders
    // also, ww2v3/global rules, defending subs without sneak attack fire with all defenders
<span class="fc bfc" id="L602" title="All 2 branches covered.">    if (m_battleSite.isWater()) {</span>
<span class="fc" id="L603">      final Collection&lt;Unit&gt; units = new ArrayList&lt;&gt;(m_defendingUnits.size() + m_defendingWaitingToDie.size());</span>
<span class="fc" id="L604">      units.addAll(m_defendingUnits);</span>
<span class="fc" id="L605">      units.addAll(m_defendingWaitingToDie);</span>
<span class="fc bfc" id="L606" title="All 4 branches covered.">      if (Match.someMatch(units, Matches.UnitIsSub) &amp;&amp; !defenderSubsFireFirst</span>
<span class="pc bpc" id="L607" title="1 of 4 branches missed.">          &amp;&amp; (defendingSubsFireWithAllDefenders || defendingSubsFireWithAllDefendersAlways)) {</span>
<span class="fc" id="L608">        steps.add(m_defender.getName() + SUBS_FIRE);</span>
<span class="fc" id="L609">        steps.add(m_attacker.getName() + SELECT_SUB_CASUALTIES);</span>
      }
    }
    // Air Units can't attack subs without Destroyers present
<span class="fc bfc" id="L613" title="All 4 branches covered.">    if (m_battleSite.isWater() &amp;&amp; isAirAttackSubRestricted()) {</span>
<span class="fc" id="L614">      final Collection&lt;Unit&gt; units = new ArrayList&lt;&gt;(m_defendingUnits.size() + m_defendingWaitingToDie.size());</span>
<span class="fc" id="L615">      units.addAll(m_defendingUnits);</span>
<span class="fc" id="L616">      units.addAll(m_defendingWaitingToDie);</span>
      // if(!Match.someMatch(m_defendingUnits, Matches.UnitIsDestroyer) &amp;&amp; Match.someMatch(m_defendingUnits,
      // Matches.UnitIsAir) &amp;&amp;
      // Match.someMatch(m_attackingUnits, Matches.UnitIsSub))
<span class="pc bpc" id="L620" title="3 of 4 branches missed.">      if (Match.someMatch(m_defendingUnits, Matches.UnitIsAir) &amp;&amp; !canAirAttackSubs(m_attackingUnits, units)) {</span>
<span class="nc" id="L621">        steps.add(AIR_DEFEND_NON_SUBS);</span>
      }
    }
<span class="fc bfc" id="L624" title="All 2 branches covered.">    if (Match.someMatch(m_defendingUnits, Matches.UnitIsNotSub)) {</span>
<span class="fc" id="L625">      steps.add(m_defender.getName() + FIRE);</span>
<span class="fc" id="L626">      steps.add(m_attacker.getName() + SELECT_CASUALTIES);</span>
    }
    // remove casualties
<span class="fc" id="L629">    steps.add(REMOVE_CASUALTIES);</span>
    // retreat subs
<span class="fc bfc" id="L631" title="All 2 branches covered.">    if (m_battleSite.isWater()) {</span>
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">      if (canSubsSubmerge()) {</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">        if (!isSubRetreatBeforeBattle()) {</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">          if (Match.someMatch(m_attackingUnits, Matches.UnitIsSub)) {</span>
<span class="fc" id="L635">            steps.add(m_attacker.getName() + SUBS_SUBMERGE);</span>
          }
<span class="fc bfc" id="L637" title="All 2 branches covered.">          if (Match.someMatch(m_defendingUnits, Matches.UnitIsSub)) {</span>
<span class="fc" id="L638">            steps.add(m_defender.getName() + SUBS_SUBMERGE);</span>
          }
        }
<span class="fc" id="L641">      } else {</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">        if (canAttackerRetreatSubs()) {</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">          if (Match.someMatch(m_attackingUnits, Matches.UnitIsSub)) {</span>
<span class="nc" id="L644">            steps.add(m_attacker.getName() + SUBS_WITHDRAW);</span>
          }
        }
<span class="nc bnc" id="L647" title="All 2 branches missed.">        if (canDefenderRetreatSubs()) {</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">          if (Match.someMatch(m_defendingUnits, Matches.UnitIsSub)) {</span>
<span class="nc" id="L649">            steps.add(m_defender.getName() + SUBS_WITHDRAW);</span>
          }
        }
      }
    }
    // if we are a sea zone, then we may not be able to retreat
    // (ie a sub travelled under another unit to get to the battle site)
    // or an enemy sub retreated to our sea zone
    // however, if all our sea units die, then
    // the air units can still retreat, so if we have any air units attacking in
    // a sea zone, we always have to have the retreat
    // option shown
    // later, if our sea units die, we may ask the user to retreat
<span class="fc bfc" id="L662" title="All 4 branches covered.">    final boolean someAirAtSea = m_battleSite.isWater() &amp;&amp; Match.someMatch(m_attackingUnits, Matches.UnitIsAir);</span>
<span class="fc bfc" id="L663" title="All 4 branches covered.">    if (canAttackerRetreat() || someAirAtSea) {</span>
<span class="fc" id="L664">      steps.add(m_attacker.getName() + ATTACKER_WITHDRAW);</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">    } else if (canAttackerRetreatPartialAmphib()) {</span>
<span class="fc" id="L666">      steps.add(m_attacker.getName() + NONAMPHIB_WITHDRAW);</span>
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">    } else if (canAttackerRetreatPlanes()) {</span>
<span class="nc" id="L668">      steps.add(m_attacker.getName() + PLANES_WITHDRAW);</span>
    }
<span class="fc" id="L670">    return steps;</span>
  }

  private boolean defenderSubsFireFirst() {
<span class="fc bfc" id="L674" title="All 4 branches covered.">    return returnFireAgainstAttackingSubs() == ReturnFire.ALL &amp;&amp; returnFireAgainstDefendingSubs() == ReturnFire.NONE;</span>
  }

  private void addFightStartToStack(final boolean firstRun, final List&lt;IExecutable&gt; steps) {
<span class="fc" id="L678">    final boolean offensiveAA = canFireOffensiveAA();</span>
<span class="fc" id="L679">    final boolean defendingAA = canFireDefendingAA();</span>
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">    if (offensiveAA) {</span>
<span class="nc" id="L681">      steps.add(new IExecutable() {</span>
        private static final long serialVersionUID = 3802352588499530533L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="nc" id="L686">          fireOffensiveAAGuns(bridge);</span>
<span class="nc" id="L687">        }</span>
      });
    }
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">    if (defendingAA) {</span>
<span class="nc" id="L691">      steps.add(new IExecutable() {</span>
        private static final long serialVersionUID = -1370090785540214199L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="nc" id="L696">          fireDefensiveAAGuns(bridge);</span>
<span class="nc" id="L697">        }</span>
      });
    }
<span class="pc bpc" id="L700" title="2 of 4 branches missed.">    if (offensiveAA || defendingAA) {</span>
<span class="nc" id="L701">      steps.add(new IExecutable() {</span>
        private static final long serialVersionUID = 8762796262264296436L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="nc" id="L706">          clearWaitingToDie(bridge);</span>
<span class="nc" id="L707">        }</span>
      });
    }
<span class="fc bfc" id="L710" title="All 2 branches covered.">    if (m_round &gt; 1) {</span>
<span class="fc" id="L711">      steps.add(new IExecutable() {</span>
        private static final long serialVersionUID = 2781652892457063082L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L716">          removeNonCombatants(bridge, false, false, true);</span>
<span class="fc" id="L717">        }</span>
      });
    }
<span class="fc bfc" id="L720" title="All 2 branches covered.">    if (firstRun) {</span>
<span class="fc" id="L721">      steps.add(new IExecutable() {</span>
        private static final long serialVersionUID = -2255284529092427441L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L726">          fireNavalBombardment(bridge);</span>
<span class="fc" id="L727">        }</span>
      });
<span class="fc" id="L729">      steps.add(new IExecutable() {</span>
        private static final long serialVersionUID = 6578267830066963474L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L734">          fireSuicideUnitsAttack(bridge);</span>
<span class="fc" id="L735">        }</span>
      });
<span class="fc" id="L737">      steps.add(new IExecutable() {</span>
        private static final long serialVersionUID = 2731652892447063082L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L742">          fireSuicideUnitsDefend(bridge);</span>
<span class="fc" id="L743">        }</span>
      });
<span class="fc" id="L745">      steps.add(new IExecutable() {</span>
        private static final long serialVersionUID = 3389635558184415797L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L750">          removeNonCombatants(bridge, false, false, true);</span>
<span class="fc" id="L751">        }</span>
      });
<span class="fc" id="L753">      steps.add(new IExecutable() {</span>
        private static final long serialVersionUID = 7193353768857658286L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L758">          landParatroops(bridge);</span>
<span class="fc" id="L759">        }</span>
      });
<span class="fc" id="L761">      steps.add(new IExecutable() {</span>
        private static final long serialVersionUID = -6676316363537467594L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L766">          markNoMovementLeft(bridge);</span>
<span class="fc" id="L767">        }</span>
      });
    }
<span class="fc" id="L770">  }</span>

  private void pushFightLoopOnStack(final boolean firstRun, final IDelegateBridge bridge) {
<span class="pc bpc" id="L773" title="1 of 2 branches missed.">    if (m_isOver) {</span>
<span class="nc" id="L774">      return;</span>
    }
<span class="fc" id="L776">    final List&lt;IExecutable&gt; steps = getBattleExecutables(firstRun);</span>
    // add in the reverse order we create them
<span class="fc" id="L778">    Collections.reverse(steps);</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">    for (final IExecutable step : steps) {</span>
<span class="fc" id="L780">      m_stack.push(step);</span>
    }
<span class="fc" id="L782">    return;</span>
  }

  List&lt;IExecutable&gt; getBattleExecutables(final boolean firstRun) {
    // the code here is a bit odd to read
    // basically, we need to break the code into seperate atomic pieces.
    // If there is a network error, or some other unfortunate event,
    // then we need to keep track of what pieces we have executed, and what is left
    // to do
    // each atomic step is in its own IExecutable
    // the definition of atomic is that either
    // 1) the code does not call to an IDisplay,IPlayer, or IRandomSource
    // 2) if the code calls to an IDisplay, IPlayer, IRandomSource, and an exception is
    // called from one of those methods, the exception will be propogated out of execute(),
    // and the execute method can be called again
    // it is allowed for an iexecutable to add other iexecutables to the stack
    // if you read the code in linear order, ignore wrapping stuff in annonymous iexecutables, then the code
    // can be read as it will execute
    // store the steps in a list
    // we need to push them in reverse order that we
    // create them, and its easier to track if we just add them
    // to a list while creating. then reverse the list and add
    // to the stack at the end
<span class="fc" id="L805">    final List&lt;IExecutable&gt; steps = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L806">    addFightStartToStack(firstRun, steps);</span>
<span class="fc" id="L807">    addFightStepsNonEditMode(steps);</span>
    /*
     * FYI: according to the rules that I know, you can submerge subs the same turn you kill the last destroyer
     * // we must grab these here, when we clear waiting to die, we might remove
     * // all the opposing destroyers, and this would change the canRetreatSubs rVal
     * final boolean canAttackerRetreatSubs = canAttackerRetreatSubs();
     * final boolean canDefenderRetreatSubs = canDefenderRetreatSubs();
     */
<span class="fc" id="L815">    steps.add(new IExecutable() {</span>
      // compatible with 0.9.0.2 saved games
      private static final long serialVersionUID = 8611067962952500496L;

      @Override
      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L821">        clearWaitingToDie(bridge);</span>
<span class="fc" id="L822">      }</span>
    });
<span class="fc" id="L824">    steps.add(new IExecutable() {</span>
      // not compatible with 0.9.0.2 saved games. this is new for 1.2.6.0
      private static final long serialVersionUID = 6387198382888361848L;

      @Override
      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L830">        checkSuicideUnits(bridge);</span>
<span class="fc" id="L831">      }</span>
    });
<span class="fc" id="L833">    steps.add(new IExecutable() {</span>
      // compatible with 0.9.0.2 saved games
      private static final long serialVersionUID = 5259103822937067667L;

      @Override
      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
        // changed to only look at units that can be destroyed in combat, and therefore not include factories, aaguns,
        // and infrastructure.
<span class="fc bfc" id="L841" title="All 2 branches covered.">        if (Match.getMatches(m_attackingUnits, Matches.UnitIsNotInfrastructure).size() == 0) {</span>
<span class="fc bfc" id="L842" title="All 2 branches covered.">          if (!isTransportCasualtiesRestricted()) {</span>
<span class="fc" id="L843">            endBattle(bridge);</span>
<span class="fc" id="L844">            defenderWins(bridge);</span>
<span class="fc" id="L845">          } else {</span>
            // Get all allied transports in the territory
<span class="fc" id="L847">            final CompositeMatch&lt;Unit&gt; matchAllied = new CompositeMatchAnd&lt;&gt;();</span>
<span class="fc" id="L848">            matchAllied.add(Matches.UnitIsTransport);</span>
<span class="fc" id="L849">            matchAllied.add(Matches.UnitIsNotCombatTransport);</span>
<span class="fc" id="L850">            matchAllied.add(Matches.isUnitAllied(m_attacker, m_data));</span>
<span class="fc" id="L851">            final List&lt;Unit&gt; alliedTransports = Match.getMatches(m_battleSite.getUnits().getUnits(), matchAllied);</span>
            // If no transports, just end the battle
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">            if (alliedTransports.isEmpty()) {</span>
<span class="fc" id="L854">              endBattle(bridge);</span>
<span class="fc" id="L855">              defenderWins(bridge);</span>
<span class="pc bnc" id="L856" title="All 2 branches missed.">            } else if (m_round &lt;= 1) {</span>
              // TODO Need to determine how combined forces on attack work- trn left in terr by prev player, ally moves
              // in and attacks
              // add back in the non-combat units (Trns)
<span class="nc" id="L860">              m_attackingUnits =</span>
<span class="nc" id="L861">                  Match.getMatches(m_battleSite.getUnits().getUnits(), Matches.unitIsOwnedBy(m_attacker));</span>
<span class="nc" id="L862">            } else {</span>
<span class="nc" id="L863">              endBattle(bridge);</span>
<span class="nc" id="L864">              defenderWins(bridge);</span>
            }
          }
<span class="nc" id="L867">        }</span>
        // changed to only look at units that can be destroyed in combat, and therefore not include factories, aaguns,
        // and infrastructure.
<span class="fc bfc" id="L870" title="All 2 branches covered.">        else if (Match.getMatches(m_defendingUnits, Matches.UnitIsNotInfrastructure).size() == 0) {</span>
<span class="fc bfc" id="L871" title="All 2 branches covered.">          if (isTransportCasualtiesRestricted()) {</span>
            // If there are undefended attacking transports, determine if they automatically die
<span class="fc" id="L873">            checkUndefendedTransports(bridge, m_defender);</span>
          }
<span class="fc" id="L875">          checkForUnitsThatCanRollLeft(bridge, false);</span>
<span class="fc" id="L876">          endBattle(bridge);</span>
<span class="fc" id="L877">          attackerWins(bridge);</span>
<span class="pc bpc" id="L878" title="1 of 2 branches missed.">        } else if (shouldEndBattleDueToMaxRounds()</span>
<span class="fc bfc" id="L879" title="All 2 branches covered.">            || (Match.allMatch(m_attackingUnits, Matches.unitHasAttackValueOfAtLeast(1).invert())</span>
<span class="pc bpc" id="L880" title="1 of 2 branches missed.">                &amp;&amp; Match.allMatch(m_defendingUnits, Matches.unitHasDefendValueOfAtLeast(1).invert()))) {</span>
<span class="nc" id="L881">          endBattle(bridge);</span>
<span class="nc" id="L882">          nobodyWins(bridge);</span>
        }
<span class="fc" id="L884">      }</span>
    });
<span class="fc" id="L886">    steps.add(new IExecutable() {</span>
      // compatible with 0.9.0.2 saved games
      private static final long serialVersionUID = 6775880082912594489L;

      @Override
      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc bfc" id="L892" title="All 6 branches covered.">        if (!m_isOver &amp;&amp; canAttackerRetreatSubs() &amp;&amp; !isSubRetreatBeforeBattle()) {</span>
<span class="fc" id="L893">          attackerRetreatSubs(bridge);</span>
        }
<span class="fc" id="L895">      }</span>
    });
<span class="fc" id="L897">    steps.add(new IExecutable() {</span>
      // compatible with 0.9.0.2 saved games
      private static final long serialVersionUID = -1544916305666912480L;

      @Override
      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc bfc" id="L903" title="All 2 branches covered.">        if (!m_isOver) {</span>
<span class="pc bpc" id="L904" title="1 of 4 branches missed.">          if (canDefenderRetreatSubs() &amp;&amp; !isSubRetreatBeforeBattle()) {</span>
<span class="fc" id="L905">            defenderRetreatSubs(bridge);</span>
          }
          // Here we test if there are any defenders left. If no defenders, then battle is over.
          // The reason we test a &quot;second&quot; time here, is because otherwise the attackers can retreat even though the
          // battle is over
          // (illegal).
<span class="pc bpc" id="L911" title="1 of 2 branches missed.">          if (m_defendingUnits.isEmpty()) {</span>
<span class="nc" id="L912">            endBattle(bridge);</span>
<span class="nc" id="L913">            attackerWins(bridge);</span>
          }
        }
<span class="fc" id="L916">      }</span>
    });
<span class="fc" id="L918">    steps.add(new IExecutable() {</span>
      // compatible with 0.9.0.2 saved games
      private static final long serialVersionUID = -1150863964807721395L;

      @Override
      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="pc bpc" id="L924" title="1 of 6 branches missed.">        if (!m_isOver &amp;&amp; canAttackerRetreatPlanes() &amp;&amp; !canAttackerRetreatPartialAmphib()) {</span>
<span class="nc" id="L925">          attackerRetreatPlanes(bridge);</span>
        }
<span class="fc" id="L927">      }</span>
    });
<span class="fc" id="L929">    steps.add(new IExecutable() {</span>
      // compatible with 0.9.0.2 saved games
      private static final long serialVersionUID = -1150863964807721395L;

      @Override
      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc bfc" id="L935" title="All 4 branches covered.">        if (!m_isOver &amp;&amp; canAttackerRetreatPartialAmphib()) {</span>
<span class="fc" id="L936">          attackerRetreatNonAmphibUnits(bridge);</span>
        }
<span class="fc" id="L938">      }</span>
    });
<span class="fc" id="L940">    steps.add(new IExecutable() {</span>
      // compatible with 0.9.0.2 saved games
      private static final long serialVersionUID = 669349383898975048L;

      @Override
      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc bfc" id="L946" title="All 2 branches covered.">        if (!m_isOver) {</span>
<span class="fc" id="L947">          attackerRetreat(bridge);</span>
        }
<span class="fc" id="L949">      }</span>
    });
<span class="fc" id="L951">    final IExecutable loop = new IExecutable() {</span>
      // compatible with 0.9.0.2 saved games
      private static final long serialVersionUID = 3118458517320468680L;

      @Override
      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L957">        pushFightLoopOnStack(false, bridge);</span>
<span class="fc" id="L958">      }</span>
    };
<span class="fc" id="L960">    steps.add(new IExecutable() {</span>
      // compatible with 0.9.0.2 saved games
      private static final long serialVersionUID = -3993599528368570254L;

      @Override
      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc bfc" id="L966" title="All 2 branches covered.">        if (!m_isOver) {</span>
<span class="fc" id="L967">          m_round++;</span>
          // determine any AA
<span class="fc" id="L969">          updateOffensiveAAUnits();</span>
<span class="fc" id="L970">          updateDefendingAAUnits();</span>
<span class="fc" id="L971">          m_stepStrings = determineStepStrings(false, bridge);</span>
<span class="fc" id="L972">          final ITripleADisplay display = getDisplay(bridge);</span>
<span class="fc" id="L973">          display.listBattleSteps(m_battleID, m_stepStrings);</span>
          // continue fighting
          // the recursive step
          // this should always be the base of the stack
          // when we execute the loop, it will populate the stack with the battle steps
<span class="pc bpc" id="L978" title="1 of 2 branches missed.">          if (!m_stack.isEmpty()) {</span>
<span class="nc" id="L979">            throw new IllegalStateException(&quot;Stack not empty:&quot; + m_stack);</span>
          }
<span class="fc" id="L981">          m_stack.push(loop);</span>
        }
<span class="fc" id="L983">      }</span>
    });
<span class="fc" id="L985">    return steps;</span>
  }

  private void addFightStepsNonEditMode(final List&lt;IExecutable&gt; steps) {
    /** Ask to retreat defending subs before battle */
<span class="fc bfc" id="L990" title="All 2 branches covered.">    if (isSubRetreatBeforeBattle()) {</span>
<span class="fc" id="L991">      steps.add(new IExecutable() {</span>
        // compatible with 0.9.0.2 saved games
        private static final long serialVersionUID = 6775880082912594489L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="pc bpc" id="L997" title="1 of 2 branches missed.">          if (!m_isOver) {</span>
<span class="fc" id="L998">            attackerRetreatSubs(bridge);</span>
          }
<span class="fc" id="L1000">        }</span>
      });
<span class="fc" id="L1002">      steps.add(new IExecutable() {</span>
        // compatible with 0.9.0.2 saved games
        private static final long serialVersionUID = 7056448091800764539L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">          if (!m_isOver) {</span>
<span class="fc" id="L1009">            defenderRetreatSubs(bridge);</span>
          }
<span class="fc" id="L1011">        }</span>
      });
    }
    /** Remove Suicide Units */
<span class="fc" id="L1015">    steps.add(new IExecutable() {</span>
      private static final long serialVersionUID = 99988L;

      @Override
      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L1020">        checkSuicideUnits(bridge);</span>
<span class="fc" id="L1021">      }</span>
    });
    /** Remove undefended trns */
<span class="fc bfc" id="L1024" title="All 2 branches covered.">    if (isTransportCasualtiesRestricted()) {</span>
<span class="fc" id="L1025">      steps.add(new IExecutable() {</span>
        private static final long serialVersionUID = 99989L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L1030">          checkUndefendedTransports(bridge, m_defender);</span>
<span class="fc" id="L1031">          checkUndefendedTransports(bridge, m_attacker);</span>
<span class="fc" id="L1032">          checkForUnitsThatCanRollLeft(bridge, true);</span>
<span class="fc" id="L1033">          checkForUnitsThatCanRollLeft(bridge, false);</span>
<span class="fc" id="L1034">        }</span>
      });
    }
    /** Submerge subs if -vs air only &amp; air restricted from attacking subs */
<span class="fc bfc" id="L1038" title="All 2 branches covered.">    if (isAirAttackSubRestricted()) {</span>
<span class="fc" id="L1039">      steps.add(new IExecutable() {</span>
        private static final long serialVersionUID = 99990L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L1044">          submergeSubsVsOnlyAir(bridge);</span>
<span class="fc" id="L1045">        }</span>
      });
    }
<span class="fc" id="L1048">    final ReturnFire returnFireAgainstAttackingSubs = returnFireAgainstAttackingSubs();</span>
<span class="fc" id="L1049">    final ReturnFire returnFireAgainstDefendingSubs = returnFireAgainstDefendingSubs();</span>
<span class="fc bfc" id="L1050" title="All 2 branches covered.">    if (defenderSubsFireFirst()) {</span>
<span class="fc" id="L1051">      steps.add(new DefendSubs() {</span>
        // compatible with 0.9.0.2 saved games
        private static final long serialVersionUID = 99992L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L1057">          defendSubs(bridge, returnFireAgainstDefendingSubs);</span>
<span class="fc" id="L1058">        }</span>
      });
    }
<span class="fc" id="L1061">    steps.add(new AttackSubs() {</span>
      private static final long serialVersionUID = 99991L;

      @Override
      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L1066">        attackSubs(bridge, returnFireAgainstAttackingSubs);</span>
<span class="fc" id="L1067">      }</span>
    });
<span class="fc bfc" id="L1069" title="All 2 branches covered.">    final boolean defendingSubsFireWithAllDefenders = !defenderSubsFireFirst()</span>
<span class="fc bfc" id="L1070" title="All 4 branches covered.">        &amp;&amp; !games.strategy.triplea.Properties.getWW2V2(m_data) &amp;&amp; returnFireAgainstDefendingSubs() == ReturnFire.ALL;</span>
<span class="pc bpc" id="L1071" title="1 of 6 branches missed.">    if (defendingSubsSneakAttack3() &amp;&amp; !defenderSubsFireFirst() &amp;&amp; !defendingSubsFireWithAllDefenders) {</span>
<span class="fc" id="L1072">      steps.add(new DefendSubs() {</span>
        // compatible with 0.9.0.2 saved games
        private static final long serialVersionUID = 99992L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L1078">          defendSubs(bridge, returnFireAgainstDefendingSubs);</span>
<span class="fc" id="L1079">        }</span>
      });
    }
    /** Attacker air fire on NON subs */
<span class="fc bfc" id="L1083" title="All 2 branches covered.">    if (isAirAttackSubRestricted()) {</span>
<span class="fc" id="L1084">      steps.add(new IExecutable() {</span>
        // compatible with 0.9.0.2 saved games
        private static final long serialVersionUID = 99993L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L1090">          attackAirOnNonSubs(bridge);</span>
<span class="fc" id="L1091">        }</span>
      });
    }
    /** Attacker fire remaining units */
<span class="fc" id="L1095">    steps.add(new IExecutable() {</span>
      // compatible with 0.9.0.2 saved games
      private static final long serialVersionUID = 99994L;

      @Override
      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L1101">        attackNonSubs(bridge);</span>
<span class="fc" id="L1102">      }</span>
    });
<span class="pc bpc" id="L1104" title="1 of 6 branches missed.">    if (!defenderSubsFireFirst() &amp;&amp; (!defendingSubsSneakAttack3() || defendingSubsFireWithAllDefenders)) {</span>
<span class="fc" id="L1105">      steps.add(new DefendSubs() {</span>
        private static final long serialVersionUID = 999921L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L1110">          defendSubs(bridge, returnFireAgainstDefendingSubs);</span>
<span class="fc" id="L1111">        }</span>
      });
    }
    /** Defender air fire on NON subs */
<span class="fc bfc" id="L1115" title="All 2 branches covered.">    if (isAirAttackSubRestricted()) {</span>
<span class="fc" id="L1116">      steps.add(new IExecutable() {</span>
        // compatible with 0.9.0.2 saved games
        private static final long serialVersionUID = 1560702114917865123L;

        @Override
        public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L1122">          defendAirOnNonSubs(bridge);</span>
<span class="fc" id="L1123">        }</span>
      });
    }
<span class="fc" id="L1126">    steps.add(new IExecutable() {</span>
      // compatible with 0.9.0.2 saved games
      private static final long serialVersionUID = 1560702114917865290L;

      @Override
      public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="fc" id="L1132">        defendNonSubs(bridge);</span>
<span class="fc" id="L1133">      }</span>
    });
<span class="fc" id="L1135">  }</span>

  private ReturnFire returnFireAgainstAttackingSubs() {
<span class="fc bfc" id="L1138" title="All 2 branches covered.">    final boolean attackingSubsSneakAttack = !Match.someMatch(m_defendingUnits, Matches.UnitIsDestroyer);</span>
<span class="fc" id="L1139">    final boolean defendingSubsSneakAttack = defendingSubsSneakAttack2();</span>
    final ReturnFire returnFireAgainstAttackingSubs;
<span class="fc bfc" id="L1141" title="All 2 branches covered.">    if (!attackingSubsSneakAttack) {</span>
<span class="fc" id="L1142">      returnFireAgainstAttackingSubs = ReturnFire.ALL;</span>
<span class="fc bfc" id="L1143" title="All 4 branches covered.">    } else if (defendingSubsSneakAttack || isWW2V2()) {</span>
<span class="fc" id="L1144">      returnFireAgainstAttackingSubs = ReturnFire.SUBS;</span>
<span class="fc" id="L1145">    } else {</span>
<span class="fc" id="L1146">      returnFireAgainstAttackingSubs = ReturnFire.NONE;</span>
    }
<span class="fc" id="L1148">    return returnFireAgainstAttackingSubs;</span>
  }

  private ReturnFire returnFireAgainstDefendingSubs() {
    /** Attacker subs fire */
    /*
     * calculate here, this holds for the fight round, but can't be computed later
     * since destroyers may die
     */
<span class="fc bfc" id="L1157" title="All 2 branches covered.">    final boolean attackingSubsSneakAttack = !Match.someMatch(m_defendingUnits, Matches.UnitIsDestroyer);</span>
<span class="fc" id="L1158">    final boolean defendingSubsSneakAttack = defendingSubsSneakAttack2();</span>
    final ReturnFire returnFireAgainstDefendingSubs;
<span class="fc bfc" id="L1160" title="All 2 branches covered.">    if (!defendingSubsSneakAttack) {</span>
<span class="fc" id="L1161">      returnFireAgainstDefendingSubs = ReturnFire.ALL;</span>
<span class="fc bfc" id="L1162" title="All 4 branches covered.">    } else if (attackingSubsSneakAttack || isWW2V2()) {</span>
<span class="fc" id="L1163">      returnFireAgainstDefendingSubs = ReturnFire.SUBS;</span>
<span class="fc" id="L1164">    } else {</span>
<span class="fc" id="L1165">      returnFireAgainstDefendingSubs = ReturnFire.NONE;</span>
    }
<span class="fc" id="L1167">    return returnFireAgainstDefendingSubs;</span>
  }

  private boolean defendingSubsSneakAttack2() {
<span class="pc bpc" id="L1171" title="1 of 4 branches missed.">    return !Match.someMatch(m_attackingUnits, Matches.UnitIsDestroyer) &amp;&amp; defendingSubsSneakAttack3();</span>
  }

  private boolean defendingSubsSneakAttack3() {
<span class="pc bpc" id="L1175" title="1 of 4 branches missed.">    return isWW2V2() || isDefendingSubsSneakAttack();</span>
  }

  private boolean canAttackerRetreatPlanes() {
<span class="pc bpc" id="L1179" title="2 of 8 branches missed.">    return (isWW2V2() || isAttackerRetreatPlanes() || isPartialAmphibiousRetreat()) &amp;&amp; m_isAmphibious</span>
<span class="fc bfc" id="L1180" title="All 2 branches covered.">        &amp;&amp; Match.someMatch(m_attackingUnits, Matches.UnitIsAir);</span>
  }

  private boolean canAttackerRetreatPartialAmphib() {
<span class="pc bpc" id="L1184" title="1 of 4 branches missed.">    if (m_isAmphibious &amp;&amp; isPartialAmphibiousRetreat()) {</span>
      // Only include land units when checking for allow amphibious retreat
<span class="fc" id="L1186">      final List&lt;Unit&gt; landUnits = Match.getMatches(m_attackingUnits, Matches.UnitIsLand);</span>
<span class="fc bfc" id="L1187" title="All 2 branches covered.">      for (final Unit unit : landUnits) {</span>
<span class="fc" id="L1188">        final TripleAUnit taUnit = (TripleAUnit) unit;</span>
<span class="fc bfc" id="L1189" title="All 2 branches covered.">        if (!taUnit.getWasAmphibious()) {</span>
<span class="fc" id="L1190">          return true;</span>
        }
      }
    }
<span class="fc" id="L1194">    return false;</span>
  }

  Collection&lt;Territory&gt; getAttackerRetreatTerritories() {
    // TODO: when attacking with paratroopers (air + carried land), there are several bugs in retreating.
    // TODO: air should always be able to retreat. paratrooped land units can only retreat if there are other
    // non-paratrooper non-amphibious
    // land units.
    // If attacker is all planes, just return collection of current territory
<span class="fc bfc" id="L1203" title="All 4 branches covered.">    if (m_headless || Match.allMatch(m_attackingUnits, Matches.UnitIsAir)</span>
<span class="pc bpc" id="L1204" title="1 of 2 branches missed.">        || games.strategy.triplea.Properties.getRetreatingUnitsRemainInPlace(m_data)) {</span>
<span class="fc" id="L1205">      final Collection&lt;Territory&gt; oneTerritory = new ArrayList&lt;&gt;(2);</span>
<span class="fc" id="L1206">      oneTerritory.add(m_battleSite);</span>
<span class="fc" id="L1207">      return oneTerritory;</span>
    }
    // its possible that a sub retreated to a territory we came from, if so we can no longer retreat there
    // or if we are moving out of a territory containing enemy units, we cannot retreat back there
<span class="fc" id="L1211">    final CompositeMatchAnd&lt;Unit&gt; enemyUnitsThatPreventRetreat =</span>
<span class="fc" id="L1212">        new CompositeMatchAnd&lt;&gt;(Matches.enemyUnit(m_attacker, m_data), Matches.UnitIsNotInfrastructure,</span>
<span class="fc" id="L1213">            Matches.unitIsBeingTransported().invert(), Matches.unitIsNotSubmerged(m_data));</span>
<span class="fc bfc" id="L1214" title="All 2 branches covered.">    if (games.strategy.triplea.Properties.getIgnoreSubInMovement(m_data)) {</span>
<span class="fc" id="L1215">      enemyUnitsThatPreventRetreat.add(Matches.UnitIsNotSub);</span>
    }
<span class="fc bfc" id="L1217" title="All 2 branches covered.">    if (games.strategy.triplea.Properties.getIgnoreTransportInMovement(m_data)) {</span>
<span class="fc" id="L1218">      enemyUnitsThatPreventRetreat.add(Matches.UnitIsNotTransportButCouldBeCombatTransport);</span>
    }
<span class="fc" id="L1220">    Collection&lt;Territory&gt; possible =</span>
<span class="fc" id="L1221">        Match.getMatches(m_attackingFrom, Matches.territoryHasUnitsThatMatch(enemyUnitsThatPreventRetreat).invert());</span>
    // In WW2V2 and WW2V3 we need to filter out territories where only planes
    // came from since planes cannot define retreat paths
<span class="pc bpc" id="L1224" title="1 of 4 branches missed.">    if (isWW2V2() || isWW2V3()) {</span>
<span class="fc" id="L1225">      possible = Match.getMatches(possible, new Match&lt;Territory&gt;() {</span>
        @Override
        public boolean match(final Territory t) {
<span class="fc" id="L1228">          final Collection&lt;Unit&gt; units = m_attackingFromMap.get(t);</span>
<span class="fc bfc" id="L1229" title="All 2 branches covered.">          return !Match.allMatch(units, Matches.UnitIsAir);</span>
        }
      });
    }

    // the air unit may have come from a conquered or enemy territory, don't allow retreating
<span class="fc" id="L1235">    final Match&lt;Territory&gt; conqueuredOrEnemy = new CompositeMatchOr&lt;&gt;(</span>
<span class="fc" id="L1236">        Matches.isTerritoryEnemyAndNotUnownedWaterOrImpassableOrRestricted(m_attacker, m_data),</span>
<span class="fc" id="L1237">        new CompositeMatchAnd&lt;Territory&gt;(</span>
            // Matches.TerritoryIsLand,
<span class="fc" id="L1239">            Matches.TerritoryIsWater, Matches.territoryWasFoughOver(m_battleTracker)));</span>
<span class="fc" id="L1240">    possible.removeAll(Match.getMatches(possible, conqueuredOrEnemy));</span>

    // the battle site is in the attacking from
    // if sea units are fighting a submerged sub
<span class="fc" id="L1244">    possible.remove(m_battleSite);</span>
<span class="fc bfc" id="L1245" title="All 4 branches covered.">    if (Match.someMatch(m_attackingUnits, Matches.UnitIsLand) &amp;&amp; !m_battleSite.isWater()) {</span>
<span class="fc" id="L1246">      possible = Match.getMatches(possible, Matches.TerritoryIsLand);</span>
    }
<span class="fc bfc" id="L1248" title="All 2 branches covered.">    if (Match.someMatch(m_attackingUnits, Matches.UnitIsSea)) {</span>
<span class="fc" id="L1249">      possible = Match.getMatches(possible, Matches.TerritoryIsWater);</span>
    }
<span class="fc" id="L1251">    return possible;</span>
  }

  private boolean canAttackerRetreat() {
<span class="fc bfc" id="L1255" title="All 2 branches covered.">    if (onlyDefenselessDefendingTransportsLeft()) {</span>
<span class="fc" id="L1256">      return false;</span>
    }
<span class="fc bfc" id="L1258" title="All 2 branches covered.">    if (m_isAmphibious) {</span>
<span class="fc" id="L1259">      return false;</span>
    }
<span class="fc" id="L1261">    final Collection&lt;Territory&gt; options = getAttackerRetreatTerritories();</span>
<span class="pc bpc" id="L1262" title="1 of 2 branches missed.">    return options.size() != 0;</span>
  }

  private boolean onlyDefenselessDefendingTransportsLeft() {
<span class="fc bfc" id="L1266" title="All 2 branches covered.">    if (!isTransportCasualtiesRestricted()) {</span>
<span class="fc" id="L1267">      return false;</span>
    }
<span class="fc" id="L1269">    return Match.allMatch(m_defendingUnits, Matches.UnitIsTransportButNotCombatTransport);</span>
  }

  private boolean canAttackerRetreatSubs() {
<span class="fc bfc" id="L1273" title="All 2 branches covered.">    if (Match.someMatch(m_defendingUnits, Matches.UnitIsDestroyer)) {</span>
<span class="fc" id="L1274">      return false;</span>
    }
<span class="pc bpc" id="L1276" title="1 of 2 branches missed.">    if (Match.someMatch(m_defendingWaitingToDie, Matches.UnitIsDestroyer)) {</span>
<span class="nc" id="L1277">      return false;</span>
    }
<span class="pc bpc" id="L1279" title="1 of 4 branches missed.">    return canAttackerRetreat() || canSubsSubmerge();</span>
  }

  // Added for test case calls
  void externalRetreat(final Collection&lt;Unit&gt; retreaters, final Territory retreatTo, final boolean defender,
      final IDelegateBridge bridge) {
<span class="fc" id="L1285">    m_isOver = true;</span>
<span class="fc" id="L1286">    retreatUnits(retreaters, retreatTo, defender, bridge);</span>
<span class="fc" id="L1287">  }</span>

  private void attackerRetreat(final IDelegateBridge bridge) {
<span class="fc bfc" id="L1290" title="All 2 branches covered.">    if (!canAttackerRetreat()) {</span>
<span class="fc" id="L1291">      return;</span>
    }
<span class="fc" id="L1293">    final Collection&lt;Territory&gt; possible = getAttackerRetreatTerritories();</span>
<span class="pc bpc" id="L1294" title="1 of 2 branches missed.">    if (!m_isOver) {</span>
<span class="pc bpc" id="L1295" title="1 of 2 branches missed.">      if (m_isAmphibious) {</span>
<span class="nc" id="L1296">        queryRetreat(false, RetreatType.PARTIAL_AMPHIB, bridge, possible);</span>
<span class="nc" id="L1297">      } else {</span>
<span class="fc" id="L1298">        queryRetreat(false, RetreatType.DEFAULT, bridge, possible);</span>
      }
    }
<span class="fc" id="L1301">  }</span>

  private void attackerRetreatPlanes(final IDelegateBridge bridge) {
    // planes retreat to the same square the battle is in, and then should
    // move during non combat to their landing site, or be scrapped if they
    // can't find one.
<span class="nc" id="L1307">    final Collection&lt;Territory&gt; possible = new ArrayList&lt;&gt;(2);</span>
<span class="nc" id="L1308">    possible.add(m_battleSite);</span>
    // retreat planes
<span class="nc bnc" id="L1310" title="All 2 branches missed.">    if (Match.someMatch(m_attackingUnits, Matches.UnitIsAir)) {</span>
<span class="nc" id="L1311">      queryRetreat(false, RetreatType.PLANES, bridge, possible);</span>
    }
<span class="nc" id="L1313">  }</span>

  private void attackerRetreatNonAmphibUnits(final IDelegateBridge bridge) {
<span class="fc" id="L1316">    final Collection&lt;Territory&gt; possible = getAttackerRetreatTerritories();</span>
<span class="fc" id="L1317">    queryRetreat(false, RetreatType.PARTIAL_AMPHIB, bridge, possible);</span>
<span class="fc" id="L1318">  }</span>

  private boolean canDefenderRetreatSubs() {
<span class="fc bfc" id="L1321" title="All 2 branches covered.">    if (Match.someMatch(m_attackingUnits, Matches.UnitIsDestroyer)) {</span>
<span class="fc" id="L1322">      return false;</span>
    }
<span class="pc bpc" id="L1324" title="1 of 2 branches missed.">    if (Match.someMatch(m_attackingWaitingToDie, Matches.UnitIsDestroyer)) {</span>
<span class="nc" id="L1325">      return false;</span>
    }
<span class="pc bfc" id="L1327" title="All 2 branches covered.">    return getEmptyOrFriendlySeaNeighbors(m_defender, Match.getMatches(m_defendingUnits, Matches.UnitIsSub)).size() != 0</span>
<span class="pc bpc" id="L1328" title="1 of 2 branches missed.">        || canSubsSubmerge();</span>
  }

  private void attackerRetreatSubs(final IDelegateBridge bridge) {
<span class="fc bfc" id="L1332" title="All 2 branches covered.">    if (!canAttackerRetreatSubs()) {</span>
<span class="fc" id="L1333">      return;</span>
    }
<span class="fc bfc" id="L1335" title="All 2 branches covered.">    if (Match.someMatch(m_attackingUnits, Matches.UnitIsSub)) {</span>
<span class="fc" id="L1336">      queryRetreat(false, RetreatType.SUBS, bridge, getAttackerRetreatTerritories());</span>
    }
<span class="fc" id="L1338">  }</span>

  private void defenderRetreatSubs(final IDelegateBridge bridge) {
<span class="fc bfc" id="L1341" title="All 2 branches covered.">    if (!canDefenderRetreatSubs()) {</span>
<span class="fc" id="L1342">      return;</span>
    }
<span class="pc bpc" id="L1344" title="1 of 4 branches missed.">    if (!m_isOver &amp;&amp; Match.someMatch(m_defendingUnits, Matches.UnitIsSub)) {</span>
<span class="fc" id="L1345">      queryRetreat(true, RetreatType.SUBS, bridge,</span>
<span class="fc" id="L1346">          getEmptyOrFriendlySeaNeighbors(m_defender, Match.getMatches(m_defendingUnits, Matches.UnitIsSub)));</span>
    }
<span class="fc" id="L1348">  }</span>

  private Collection&lt;Territory&gt; getEmptyOrFriendlySeaNeighbors(final PlayerID player,
      final Collection&lt;Unit&gt; unitsToRetreat) {
<span class="fc" id="L1352">    Collection&lt;Territory&gt; possible = m_data.getMap().getNeighbors(m_battleSite);</span>
<span class="fc bfc" id="L1353" title="All 2 branches covered.">    if (m_headless) {</span>
<span class="fc" id="L1354">      return possible;</span>
    }
<span class="fc" id="L1356">    final CompositeMatch&lt;Territory&gt; match =</span>
<span class="fc" id="L1357">        new CompositeMatchAnd&lt;&gt;(Matches.TerritoryIsWater, Matches.territoryHasNoEnemyUnits(player, m_data));</span>
    // make sure we can move through the any canals
<span class="fc" id="L1359">    final Match&lt;Territory&gt; canalMatch = new Match&lt;Territory&gt;() {</span>
      @Override
      public boolean match(final Territory t) {
<span class="fc" id="L1362">        final Route r = new Route();</span>
<span class="fc" id="L1363">        r.setStart(m_battleSite);</span>
<span class="fc" id="L1364">        r.add(t);</span>
<span class="pc bpc" id="L1365" title="1 of 2 branches missed.">        return MoveValidator.validateCanal(r, unitsToRetreat, m_defender, m_data) == null;</span>
      }
    };
<span class="fc" id="L1368">    match.add(canalMatch);</span>
<span class="fc" id="L1369">    possible = Match.getMatches(possible, match);</span>
<span class="fc" id="L1370">    return possible;</span>
  }

  private void queryRetreat(final boolean defender, final RetreatType retreatType, final IDelegateBridge bridge,
      Collection&lt;Territory&gt; availableTerritories) {
    boolean subs;
    boolean planes;
    boolean partialAmphib;
<span class="pc bpc" id="L1378" title="1 of 2 branches missed.">    planes = retreatType == RetreatType.PLANES;</span>
<span class="fc bfc" id="L1379" title="All 2 branches covered.">    subs = retreatType == RetreatType.SUBS;</span>
<span class="fc" id="L1380">    final boolean canSubsSubmerge = canSubsSubmerge();</span>
<span class="pc bpc" id="L1381" title="1 of 4 branches missed.">    final boolean submerge = subs &amp;&amp; canSubsSubmerge;</span>
<span class="pc" id="L1382">    final boolean canDefendingSubsSubmergeOrRetreat =</span>
<span class="pc bpc" id="L1383" title="1 of 6 branches missed.">        subs &amp;&amp; defender &amp;&amp; games.strategy.triplea.Properties.getSubmarinesDefendingMaySubmergeOrRetreat(m_data);</span>
<span class="fc bfc" id="L1384" title="All 2 branches covered.">    partialAmphib = retreatType == RetreatType.PARTIAL_AMPHIB;</span>
<span class="pc bpc" id="L1385" title="5 of 6 branches missed.">    if (availableTerritories.isEmpty() &amp;&amp; !(submerge || canDefendingSubsSubmergeOrRetreat)) {</span>
<span class="nc" id="L1386">      return;</span>
    }
<span class="fc bfc" id="L1388" title="All 2 branches covered.">    Collection&lt;Unit&gt; units = defender ? m_defendingUnits : m_attackingUnits;</span>
<span class="fc bfc" id="L1389" title="All 2 branches covered.">    if (subs) {</span>
<span class="fc" id="L1390">      units = Match.getMatches(units, Matches.UnitIsSub);</span>
<span class="pc bpc" id="L1391" title="1 of 2 branches missed.">    } else if (planes) {</span>
<span class="nc" id="L1392">      units = Match.getMatches(units, Matches.UnitIsAir);</span>
<span class="pc bfc" id="L1393" title="All 2 branches covered.">    } else if (partialAmphib) {</span>
<span class="fc" id="L1394">      units = Match.getMatches(units, Matches.UnitWasNotAmphibious);</span>
    }
<span class="fc bfc" id="L1396" title="All 2 branches covered.">    if (Match.someMatch(units, Matches.UnitIsSea)) {</span>
<span class="fc" id="L1397">      availableTerritories = Match.getMatches(availableTerritories, Matches.TerritoryIsWater);</span>
    }
<span class="pc bpc" id="L1399" title="1 of 2 branches missed.">    if (canDefendingSubsSubmergeOrRetreat) {</span>
<span class="nc" id="L1400">      availableTerritories.add(m_battleSite);</span>
<span class="pc bfc" id="L1401" title="All 2 branches covered.">    } else if (submerge) {</span>
<span class="fc" id="L1402">      availableTerritories.clear();</span>
<span class="fc" id="L1403">      availableTerritories.add(m_battleSite);</span>
    }
<span class="pc bpc" id="L1405" title="1 of 2 branches missed.">    if (planes) {</span>
<span class="nc" id="L1406">      availableTerritories.clear();</span>
<span class="nc" id="L1407">      availableTerritories.add(m_battleSite);</span>
    }
<span class="pc bpc" id="L1409" title="1 of 2 branches missed.">    if (units.size() == 0) {</span>
<span class="nc" id="L1410">      return;</span>
    }
<span class="fc bfc" id="L1412" title="All 2 branches covered.">    final PlayerID retreatingPlayer = defender ? m_defender : m_attacker;</span>
    String text;
<span class="fc bfc" id="L1414" title="All 2 branches covered.">    if (subs) {</span>
<span class="fc" id="L1415">      text = retreatingPlayer.getName() + &quot; retreat subs?&quot;;</span>
<span class="pc bpc" id="L1416" title="1 of 2 branches missed.">    } else if (planes) {</span>
<span class="nc" id="L1417">      text = retreatingPlayer.getName() + RETREAT_PLANES;</span>
<span class="pc bfc" id="L1418" title="All 2 branches covered.">    } else if (partialAmphib) {</span>
<span class="fc" id="L1419">      text = retreatingPlayer.getName() + &quot; retreat non-amphibious units?&quot;;</span>
<span class="fc" id="L1420">    } else {</span>
<span class="fc" id="L1421">      text = retreatingPlayer.getName() + &quot; retreat?&quot;;</span>
    }
    String step;
<span class="fc bfc" id="L1424" title="All 2 branches covered.">    if (defender) {</span>
<span class="pc bpc" id="L1425" title="1 of 2 branches missed.">      step = m_defender.getName() + (canSubsSubmerge ? SUBS_SUBMERGE : SUBS_WITHDRAW);</span>
<span class="fc" id="L1426">    } else {</span>
<span class="fc bfc" id="L1427" title="All 2 branches covered.">      if (subs) {</span>
<span class="pc bpc" id="L1428" title="1 of 2 branches missed.">        step = m_attacker.getName() + (canSubsSubmerge ? SUBS_SUBMERGE : SUBS_WITHDRAW);</span>
<span class="pc bpc" id="L1429" title="1 of 2 branches missed.">      } else if (planes) {</span>
<span class="nc" id="L1430">        step = m_attacker.getName() + PLANES_WITHDRAW;</span>
<span class="pc bfc" id="L1431" title="All 2 branches covered.">      } else if (partialAmphib) {</span>
<span class="fc" id="L1432">        step = m_attacker.getName() + NONAMPHIB_WITHDRAW;</span>
<span class="fc" id="L1433">      } else {</span>
<span class="fc" id="L1434">        step = m_attacker.getName() + ATTACKER_WITHDRAW;</span>
      }
    }
<span class="fc" id="L1437">    getDisplay(bridge).gotoBattleStep(m_battleID, step);</span>
<span class="fc" id="L1438">    final Territory retreatTo = getRemote(retreatingPlayer, bridge).retreatQuery(m_battleID,</span>
<span class="pc bpc" id="L1439" title="1 of 4 branches missed.">        (submerge || canDefendingSubsSubmergeOrRetreat), m_battleSite, availableTerritories, text);</span>
<span class="pc bpc" id="L1440" title="5 of 6 branches missed.">    if (retreatTo != null &amp;&amp; !availableTerritories.contains(retreatTo) &amp;&amp; !subs) {</span>
<span class="nc" id="L1441">      System.err.println(&quot;Invalid retreat selection :&quot; + retreatTo + &quot; not in &quot;</span>
<span class="nc" id="L1442">          + MyFormatter.defaultNamedToTextList(availableTerritories));</span>
<span class="nc" id="L1443">      Thread.dumpStack();</span>
<span class="nc" id="L1444">      return;</span>
    }
<span class="pc bpc" id="L1446" title="1 of 2 branches missed.">    if (retreatTo != null) {</span>
      // if attacker retreating non subs then its all over
<span class="nc bnc" id="L1448" title="All 8 branches missed.">      if (!defender &amp;&amp; !subs &amp;&amp; !planes &amp;&amp; !partialAmphib) {</span>
        // this is illegal in ww2v2 revised and beyond (the fighters should die). still checking if illegal in classic.
        // ensureAttackingAirCanRetreat(bridge);
<span class="nc" id="L1451">        m_isOver = true;</span>
      }
<span class="nc bnc" id="L1453" title="All 8 branches missed.">      if (subs &amp;&amp; m_battleSite.equals(retreatTo) &amp;&amp; (submerge || canDefendingSubsSubmergeOrRetreat)) {</span>
<span class="nc bnc" id="L1454" title="All 2 branches missed.">        if (!m_headless) {</span>
<span class="nc" id="L1455">          bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_RETREAT_SUBMERGE, m_attacker);</span>
        }
<span class="nc" id="L1457">        submergeUnits(units, defender, bridge);</span>
<span class="nc" id="L1458">        final String messageShort = retreatingPlayer.getName() + &quot; submerges subs&quot;;</span>
<span class="nc" id="L1459">        getDisplay(bridge).notifyRetreat(messageShort, messageShort, step, retreatingPlayer);</span>
<span class="nc bnc" id="L1460" title="All 2 branches missed.">      } else if (planes) {</span>
<span class="nc bnc" id="L1461" title="All 2 branches missed.">        if (!m_headless) {</span>
<span class="nc" id="L1462">          bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_RETREAT_AIR, m_attacker);</span>
        }
<span class="nc" id="L1464">        retreatPlanes(units, defender, bridge);</span>
<span class="nc" id="L1465">        final String messageShort = retreatingPlayer.getName() + &quot; retreats planes&quot;;</span>
<span class="nc" id="L1466">        getDisplay(bridge).notifyRetreat(messageShort, messageShort, step, retreatingPlayer);</span>
<span class="nc bnc" id="L1467" title="All 2 branches missed.">      } else if (partialAmphib) {</span>
<span class="nc bnc" id="L1468" title="All 2 branches missed.">        if (!m_headless) {</span>
<span class="nc bnc" id="L1469" title="All 2 branches missed.">          if (Match.someMatch(units, Matches.UnitIsSea)) {</span>
<span class="nc" id="L1470">            bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_RETREAT_SEA, m_attacker);</span>
<span class="nc bnc" id="L1471" title="All 2 branches missed.">          } else if (Match.someMatch(units, Matches.UnitIsLand)) {</span>
<span class="nc" id="L1472">            bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_RETREAT_LAND, m_attacker);</span>
<span class="nc" id="L1473">          } else {</span>
<span class="nc" id="L1474">            bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_RETREAT_AIR, m_attacker);</span>
          }
        }
        // remove amphib units from those retreating
<span class="nc" id="L1478">        units = Match.getMatches(units, Matches.UnitWasNotAmphibious);</span>
<span class="nc" id="L1479">        retreatUnitsAndPlanes(units, retreatTo, defender, bridge);</span>
<span class="nc" id="L1480">        final String messageShort = retreatingPlayer.getName() + &quot; retreats non-amphibious units&quot;;</span>
<span class="nc" id="L1481">        getDisplay(bridge).notifyRetreat(messageShort, messageShort, step, retreatingPlayer);</span>
<span class="nc" id="L1482">      } else {</span>
<span class="nc bnc" id="L1483" title="All 2 branches missed.">        if (!m_headless) {</span>
<span class="nc bnc" id="L1484" title="All 2 branches missed.">          if (Match.someMatch(units, Matches.UnitIsSea)) {</span>
<span class="nc" id="L1485">            bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_RETREAT_SEA, m_attacker);</span>
<span class="nc bnc" id="L1486" title="All 2 branches missed.">          } else if (Match.someMatch(units, Matches.UnitIsLand)) {</span>
<span class="nc" id="L1487">            bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_RETREAT_LAND, m_attacker);</span>
<span class="nc" id="L1488">          } else {</span>
<span class="nc" id="L1489">            bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_RETREAT_AIR, m_attacker);</span>
          }
        }
<span class="nc" id="L1492">        retreatUnits(units, retreatTo, defender, bridge);</span>
<span class="nc" id="L1493">        final String messageShort = retreatingPlayer.getName() + &quot; retreats&quot;;</span>
        String messageLong;
<span class="nc bnc" id="L1495" title="All 2 branches missed.">        if (subs) {</span>
<span class="nc" id="L1496">          messageLong = retreatingPlayer.getName() + &quot; retreats subs to &quot; + retreatTo.getName();</span>
<span class="nc bnc" id="L1497" title="All 2 branches missed.">        } else if (planes) {</span>
<span class="nc" id="L1498">          messageLong = retreatingPlayer.getName() + &quot; retreats planes to &quot; + retreatTo.getName();</span>
<span class="nc bnc" id="L1499" title="All 2 branches missed.">        } else if (partialAmphib) {</span>
<span class="nc" id="L1500">          messageLong = retreatingPlayer.getName() + &quot; retreats non-amphibious units to &quot; + retreatTo.getName();</span>
<span class="nc" id="L1501">        } else {</span>
<span class="nc" id="L1502">          messageLong = retreatingPlayer.getName() + &quot; retreats all units to &quot; + retreatTo.getName();</span>
        }
<span class="nc" id="L1504">        getDisplay(bridge).notifyRetreat(messageShort, messageLong, step, retreatingPlayer);</span>
      }
    }
<span class="fc" id="L1507">  }</span>

  @Override
  public List&lt;Unit&gt; getRemainingAttackingUnits() {
<span class="fc" id="L1511">    final ArrayList&lt;Unit&gt; remaining = new ArrayList&lt;&gt;(m_attackingUnits);</span>
<span class="fc" id="L1512">    remaining.addAll(m_attackingUnitsRetreated);</span>
<span class="fc" id="L1513">    return remaining;</span>
  }

  @Override
  public List&lt;Unit&gt; getRemainingDefendingUnits() {
<span class="fc" id="L1518">    final ArrayList&lt;Unit&gt; remaining = new ArrayList&lt;&gt;(m_defendingUnits);</span>
<span class="fc" id="L1519">    remaining.addAll(m_defendingUnitsRetreated);</span>
<span class="fc" id="L1520">    return remaining;</span>
  }

  private Change retreatFromDependents(final Collection&lt;Unit&gt; units, final IDelegateBridge bridge,
      final Territory retreatTo, final Collection&lt;IBattle&gt; dependentBattles) {
<span class="fc" id="L1525">    final CompositeChange change = new CompositeChange();</span>
<span class="fc bfc" id="L1526" title="All 2 branches covered.">    for (final IBattle dependent : dependentBattles) {</span>
<span class="fc" id="L1527">      final Route route = new Route();</span>
<span class="fc" id="L1528">      route.setStart(m_battleSite);</span>
<span class="fc" id="L1529">      route.add(dependent.getTerritory());</span>
<span class="fc" id="L1530">      final Collection&lt;Unit&gt; retreatedUnits = dependent.getDependentUnits(units);</span>
<span class="fc" id="L1531">      dependent.removeAttack(route, retreatedUnits);</span>
<span class="fc" id="L1532">      reLoadTransports(units, change);</span>
<span class="fc" id="L1533">      change.add(ChangeFactory.moveUnits(dependent.getTerritory(), retreatTo, retreatedUnits));</span>
    }
<span class="fc" id="L1535">    return change;</span>
  }

  // Retreat landed units from allied territory when their transport retreats
  private Change retreatFromNonCombat(Collection&lt;Unit&gt; units, final IDelegateBridge bridge, final Territory retreatTo) {
<span class="nc" id="L1540">    final CompositeChange change = new CompositeChange();</span>
<span class="nc" id="L1541">    units = Match.getMatches(units, Matches.UnitIsTransport);</span>
<span class="nc" id="L1542">    final Collection&lt;Unit&gt; retreated = getTransportDependents(units, m_data);</span>
<span class="nc bnc" id="L1543" title="All 2 branches missed.">    if (!retreated.isEmpty()) {</span>
<span class="nc" id="L1544">      Territory retreatedFrom = null;</span>
<span class="nc bnc" id="L1545" title="All 2 branches missed.">      for (final Unit unit : units) {</span>
<span class="nc" id="L1546">        retreatedFrom = TransportTracker.getTerritoryTransportHasUnloadedTo(unit);</span>
<span class="nc bnc" id="L1547" title="All 2 branches missed.">        if (retreatedFrom != null) {</span>
<span class="nc" id="L1548">          reLoadTransports(units, change);</span>
<span class="nc" id="L1549">          change.add(ChangeFactory.moveUnits(retreatedFrom, retreatTo, retreated));</span>
        }
      }
    }
<span class="nc" id="L1553">    return change;</span>
  }

  public void reLoadTransports(final Collection&lt;Unit&gt; units, final CompositeChange change) {
<span class="fc" id="L1557">    final Collection&lt;Unit&gt; transports = Match.getMatches(units, Matches.UnitCanTransport);</span>
    // Put units back on their transports
<span class="fc bfc" id="L1559" title="All 2 branches covered.">    for (final Unit transport : transports) {</span>
<span class="fc" id="L1560">      final Collection&lt;Unit&gt; unloaded = TransportTracker.unloaded(transport);</span>
<span class="fc bfc" id="L1561" title="All 2 branches covered.">      for (final Unit load : unloaded) {</span>
<span class="fc" id="L1562">        final Change loadChange = TransportTracker.loadTransportChange((TripleAUnit) transport, load);</span>
<span class="fc" id="L1563">        change.add(loadChange);</span>
      }
    }
<span class="fc" id="L1566">  }</span>

  private void retreatPlanes(final Collection&lt;Unit&gt; retreating, final boolean defender, final IDelegateBridge bridge) {
<span class="nc" id="L1569">    final String transcriptText = MyFormatter.unitsToText(retreating) + &quot; retreated&quot;;</span>
<span class="nc bnc" id="L1570" title="All 2 branches missed.">    final Collection&lt;Unit&gt; units = defender ? m_defendingUnits : m_attackingUnits;</span>
<span class="nc bnc" id="L1571" title="All 2 branches missed.">    final Collection&lt;Unit&gt; unitsRetreated = defender ? m_defendingUnitsRetreated : m_attackingUnitsRetreated;</span>
    /**
     * @todo Does this need to happen with planes retreating too?
     */
<span class="nc" id="L1575">    units.removeAll(retreating);</span>
<span class="nc" id="L1576">    unitsRetreated.removeAll(retreating);</span>
<span class="nc bnc" id="L1577" title="All 4 branches missed.">    if (units.isEmpty() || m_isOver) {</span>
<span class="nc" id="L1578">      endBattle(bridge);</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">      if (defender) {</span>
<span class="nc" id="L1580">        attackerWins(bridge);</span>
<span class="nc" id="L1581">      } else {</span>
<span class="nc" id="L1582">        defenderWins(bridge);</span>
      }
<span class="nc" id="L1584">    } else {</span>
<span class="nc" id="L1585">      getDisplay(bridge).notifyRetreat(m_battleID, retreating);</span>
    }
<span class="nc" id="L1587">    bridge.getHistoryWriter().addChildToEvent(transcriptText, new ArrayList&lt;&gt;(retreating));</span>
<span class="nc" id="L1588">  }</span>

  private void submergeUnits(final Collection&lt;Unit&gt; submerging, final boolean defender, final IDelegateBridge bridge) {
<span class="nc" id="L1591">    final String transcriptText = MyFormatter.unitsToText(submerging) + &quot; Submerged&quot;;</span>
<span class="nc bnc" id="L1592" title="All 2 branches missed.">    final Collection&lt;Unit&gt; units = defender ? m_defendingUnits : m_attackingUnits;</span>
<span class="nc bnc" id="L1593" title="All 2 branches missed.">    final Collection&lt;Unit&gt; unitsRetreated = defender ? m_defendingUnitsRetreated : m_attackingUnitsRetreated;</span>
<span class="nc" id="L1594">    final CompositeChange change = new CompositeChange();</span>
<span class="nc bnc" id="L1595" title="All 2 branches missed.">    for (final Unit u : submerging) {</span>
<span class="nc" id="L1596">      change.add(ChangeFactory.unitPropertyChange(u, true, TripleAUnit.SUBMERGED));</span>
    }
<span class="nc" id="L1598">    bridge.addChange(change);</span>
<span class="nc" id="L1599">    units.removeAll(submerging);</span>
<span class="nc" id="L1600">    unitsRetreated.addAll(submerging);</span>
<span class="nc bnc" id="L1601" title="All 4 branches missed.">    if (!units.isEmpty() &amp;&amp; !m_isOver) {</span>
<span class="nc" id="L1602">      getDisplay(bridge).notifyRetreat(m_battleID, submerging);</span>
    }
<span class="nc" id="L1604">    bridge.getHistoryWriter().addChildToEvent(transcriptText, new ArrayList&lt;&gt;(submerging));</span>
<span class="nc" id="L1605">  }</span>

  private void retreatUnits(Collection&lt;Unit&gt; retreating, final Territory to, final boolean defender,
      final IDelegateBridge bridge) {
<span class="fc" id="L1609">    retreating.addAll(getDependentUnits(retreating));</span>
    // our own air units dont retreat with land units
<span class="fc" id="L1611">    final Match&lt;Unit&gt; notMyAir =</span>
<span class="fc" id="L1612">        new CompositeMatchOr&lt;&gt;(Matches.UnitIsNotAir, new InverseMatch&lt;&gt;(Matches.unitIsOwnedBy(m_attacker)));</span>
<span class="fc" id="L1613">    retreating = Match.getMatches(retreating, notMyAir);</span>
    String transcriptText;
    // in WW2V1, defending subs can retreat so show owner
<span class="pc bpc" id="L1616" title="1 of 2 branches missed.">    if (isWW2V2()) {</span>
<span class="nc" id="L1617">      transcriptText = MyFormatter.unitsToTextNoOwner(retreating) + &quot; retreated to &quot; + to.getName();</span>
<span class="nc" id="L1618">    } else {</span>
<span class="fc" id="L1619">      transcriptText = MyFormatter.unitsToText(retreating) + &quot; retreated to &quot; + to.getName();</span>
    }
<span class="fc" id="L1621">    bridge.getHistoryWriter().addChildToEvent(transcriptText, new ArrayList&lt;&gt;(retreating));</span>
<span class="fc" id="L1622">    final CompositeChange change = new CompositeChange();</span>
<span class="fc" id="L1623">    change.add(ChangeFactory.moveUnits(m_battleSite, to, retreating));</span>
<span class="pc bpc" id="L1624" title="1 of 2 branches missed.">    if (m_isOver) {</span>
<span class="fc" id="L1625">      final Collection&lt;IBattle&gt; dependentBattles = m_battleTracker.getBlocked(this);</span>
      // If there are no dependent battles, check landings in allied territories
<span class="pc bpc" id="L1627" title="1 of 2 branches missed.">      if (dependentBattles.isEmpty()) {</span>
<span class="nc" id="L1628">        change.add(retreatFromNonCombat(retreating, bridge, to));</span>
        // Else retreat the units from combat when their transport retreats
<span class="nc" id="L1630">      } else {</span>
<span class="fc" id="L1631">        change.add(retreatFromDependents(retreating, bridge, to, dependentBattles));</span>
      }
    }
<span class="fc" id="L1634">    bridge.addChange(change);</span>
<span class="pc bpc" id="L1635" title="1 of 2 branches missed.">    final Collection&lt;Unit&gt; units = defender ? m_defendingUnits : m_attackingUnits;</span>
<span class="pc bpc" id="L1636" title="1 of 2 branches missed.">    final Collection&lt;Unit&gt; unitsRetreated = defender ? m_defendingUnitsRetreated : m_attackingUnitsRetreated;</span>
<span class="fc" id="L1637">    units.removeAll(retreating);</span>
<span class="fc" id="L1638">    unitsRetreated.addAll(retreating);</span>
<span class="pc bpc" id="L1639" title="3 of 4 branches missed.">    if (units.isEmpty() || m_isOver) {</span>
<span class="fc" id="L1640">      endBattle(bridge);</span>
<span class="pc bpc" id="L1641" title="1 of 2 branches missed.">      if (defender) {</span>
<span class="nc" id="L1642">        attackerWins(bridge);</span>
<span class="nc" id="L1643">      } else {</span>
<span class="fc" id="L1644">        defenderWins(bridge);</span>
      }
<span class="fc" id="L1646">    } else {</span>
<span class="nc" id="L1647">      getDisplay(bridge).notifyRetreat(m_battleID, retreating);</span>
    }
<span class="fc" id="L1649">  }</span>

  private void retreatUnitsAndPlanes(final Collection&lt;Unit&gt; retreating, final Territory to, final boolean defender,
      final IDelegateBridge bridge) {
    // Remove air from battle
<span class="nc bnc" id="L1654" title="All 2 branches missed.">    final Collection&lt;Unit&gt; units = defender ? m_defendingUnits : m_attackingUnits;</span>
<span class="nc bnc" id="L1655" title="All 2 branches missed.">    final Collection&lt;Unit&gt; unitsRetreated = defender ? m_defendingUnitsRetreated : m_attackingUnitsRetreated;</span>
<span class="nc" id="L1656">    units.removeAll(Match.getMatches(units, Matches.UnitIsAir));</span>
    // add all land units' dependents
    // retreating.addAll(getDependentUnits(retreating));
<span class="nc" id="L1659">    retreating.addAll(getDependentUnits(units));</span>
    // our own air units dont retreat with land units
<span class="nc" id="L1661">    final Match&lt;Unit&gt; notMyAir =</span>
<span class="nc" id="L1662">        new CompositeMatchOr&lt;&gt;(Matches.UnitIsNotAir, new InverseMatch&lt;&gt;(Matches.unitIsOwnedBy(m_attacker)));</span>
<span class="nc" id="L1663">    final Collection&lt;Unit&gt; nonAirRetreating = Match.getMatches(retreating, notMyAir);</span>
<span class="nc" id="L1664">    final String transcriptText = MyFormatter.unitsToTextNoOwner(nonAirRetreating) + &quot; retreated to &quot; + to.getName();</span>
<span class="nc" id="L1665">    bridge.getHistoryWriter().addChildToEvent(transcriptText, new ArrayList&lt;&gt;(nonAirRetreating));</span>
<span class="nc" id="L1666">    final CompositeChange change = new CompositeChange();</span>
<span class="nc" id="L1667">    change.add(ChangeFactory.moveUnits(m_battleSite, to, nonAirRetreating));</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">    if (m_isOver) {</span>
<span class="nc" id="L1669">      final Collection&lt;IBattle&gt; dependentBattles = m_battleTracker.getBlocked(this);</span>
      // If there are no dependent battles, check landings in allied territories
<span class="nc bnc" id="L1671" title="All 2 branches missed.">      if (dependentBattles.isEmpty()) {</span>
<span class="nc" id="L1672">        change.add(retreatFromNonCombat(nonAirRetreating, bridge, to));</span>
        // Else retreat the units from combat when their transport retreats
<span class="nc" id="L1674">      } else {</span>
<span class="nc" id="L1675">        change.add(retreatFromDependents(nonAirRetreating, bridge, to, dependentBattles));</span>
      }
    }
<span class="nc" id="L1678">    bridge.addChange(change);</span>
<span class="nc" id="L1679">    units.removeAll(nonAirRetreating);</span>
<span class="nc" id="L1680">    unitsRetreated.addAll(nonAirRetreating);</span>
<span class="nc bnc" id="L1681" title="All 4 branches missed.">    if (units.isEmpty() || m_isOver) {</span>
<span class="nc" id="L1682">      endBattle(bridge);</span>
<span class="nc bnc" id="L1683" title="All 2 branches missed.">      if (defender) {</span>
<span class="nc" id="L1684">        attackerWins(bridge);</span>
<span class="nc" id="L1685">      } else {</span>
<span class="nc" id="L1686">        defenderWins(bridge);</span>
      }
<span class="nc" id="L1688">    } else {</span>
<span class="nc" id="L1689">      getDisplay(bridge).notifyRetreat(m_battleID, retreating);</span>
    }
<span class="nc" id="L1691">  }</span>

  private void fire(final String stepName, final Collection&lt;Unit&gt; firingUnits, final Collection&lt;Unit&gt; attackableUnits,
      final List&lt;Unit&gt; allEnemyUnitsAliveOrWaitingToDie, final boolean defender, final ReturnFire returnFire,
      final IDelegateBridge bridge, final String text) {
<span class="fc bfc" id="L1696" title="All 2 branches covered.">    final PlayerID firing = defender ? m_defender : m_attacker;</span>
<span class="fc bfc" id="L1697" title="All 2 branches covered.">    final PlayerID defending = !defender ? m_defender : m_attacker;</span>
<span class="fc bfc" id="L1698" title="All 2 branches covered.">    if (firingUnits.isEmpty()) {</span>
<span class="fc" id="L1699">      return;</span>
    }
<span class="fc" id="L1701">    m_stack.push(new Fire(attackableUnits, returnFire, firing, defending, firingUnits, stepName, text, this, defender,</span>
<span class="fc" id="L1702">        m_dependentUnits, m_stack, m_headless, m_battleSite, m_territoryEffects, allEnemyUnitsAliveOrWaitingToDie));</span>
<span class="fc" id="L1703">  }</span>

  /**
   * Check for suicide units and kill them immediately (they get to shoot back, which is the point)
   *
   * @param bridge
   * @param player
   * @param defender
   */
  private void checkSuicideUnits(final IDelegateBridge bridge) {
<span class="pc bpc" id="L1713" title="1 of 2 branches missed.">    if (isDefendingSuicideAndMunitionUnitsDoNotFire()) {</span>
<span class="nc" id="L1714">      final List&lt;Unit&gt; deadUnits = Match.getMatches(m_attackingUnits, Matches.UnitIsSuicide);</span>
<span class="nc" id="L1715">      getDisplay(bridge).deadUnitNotification(m_battleID, m_attacker, deadUnits, m_dependentUnits);</span>
<span class="nc" id="L1716">      remove(deadUnits, bridge, m_battleSite, false, false);</span>
<span class="nc" id="L1717">    } else {</span>
<span class="fc" id="L1718">      final List&lt;Unit&gt; deadUnits = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1719">      deadUnits.addAll(Match.getMatches(m_defendingUnits, Matches.UnitIsSuicide));</span>
<span class="fc" id="L1720">      deadUnits.addAll(Match.getMatches(m_attackingUnits, Matches.UnitIsSuicide));</span>
<span class="fc" id="L1721">      getDisplay(bridge).deadUnitNotification(m_battleID, m_attacker, deadUnits, m_dependentUnits);</span>
<span class="fc" id="L1722">      getDisplay(bridge).deadUnitNotification(m_battleID, m_defender, deadUnits, m_dependentUnits);</span>
<span class="fc" id="L1723">      remove(deadUnits, bridge, m_battleSite, false, null);</span>
    }
<span class="fc" id="L1725">  }</span>

  /**
   * Check for unescorted TRNS and kill them immediately
   *
   * @param bridge
   * @param player
   * @param defender
   */
  private void checkUndefendedTransports(final IDelegateBridge bridge, final PlayerID player) {
    // if we are the attacker, we can retreat instead of dying
<span class="fc bfc" id="L1736" title="All 2 branches covered.">    if (player.equals(m_attacker)</span>
<span class="pc bpc" id="L1737" title="1 of 4 branches missed.">        &amp;&amp; (!getAttackerRetreatTerritories().isEmpty() || Match.someMatch(m_attackingUnits, Matches.UnitIsAir))) {</span>
<span class="fc" id="L1738">      return;</span>
    }
    // Get all allied transports in the territory
<span class="fc" id="L1741">    final CompositeMatch&lt;Unit&gt; matchAllied = new CompositeMatchAnd&lt;&gt;();</span>
<span class="fc" id="L1742">    matchAllied.add(Matches.UnitIsTransport);</span>
<span class="fc" id="L1743">    matchAllied.add(Matches.UnitIsNotCombatTransport);</span>
<span class="fc" id="L1744">    matchAllied.add(Matches.isUnitAllied(player, m_data));</span>
<span class="fc" id="L1745">    matchAllied.add(Matches.UnitIsSea);</span>
<span class="fc" id="L1746">    final List&lt;Unit&gt; alliedTransports = Match.getMatches(m_battleSite.getUnits().getUnits(), matchAllied);</span>
    // If no transports, just return
<span class="fc bfc" id="L1748" title="All 2 branches covered.">    if (alliedTransports.isEmpty()) {</span>
<span class="fc" id="L1749">      return;</span>
    }
    // Get all ALLIED, sea &amp; air units in the territory (that are NOT submerged)
<span class="fc" id="L1752">    final CompositeMatch&lt;Unit&gt; alliedUnitsMatch = new CompositeMatchAnd&lt;&gt;();</span>
<span class="fc" id="L1753">    alliedUnitsMatch.add(Matches.isUnitAllied(player, m_data));</span>
<span class="fc" id="L1754">    alliedUnitsMatch.add(Matches.UnitIsNotLand);</span>
<span class="fc" id="L1755">    alliedUnitsMatch.add(new InverseMatch&lt;&gt;(Matches.unitIsSubmerged(m_data)));</span>
<span class="fc" id="L1756">    final Collection&lt;Unit&gt; alliedUnits = Match.getMatches(m_battleSite.getUnits().getUnits(), alliedUnitsMatch);</span>
    // If transports are unescorted, check opposing forces to see if the Trns die automatically
<span class="fc bfc" id="L1758" title="All 2 branches covered.">    if (alliedTransports.size() == alliedUnits.size()) {</span>
      // Get all the ENEMY sea and air units (that can attack) in the territory
<span class="fc" id="L1760">      final CompositeMatch&lt;Unit&gt; enemyUnitsMatch = new CompositeMatchAnd&lt;&gt;();</span>
<span class="fc" id="L1761">      enemyUnitsMatch.add(Matches.UnitIsNotLand);</span>
      // enemyUnitsMatch.add(Matches.UnitIsNotTransportButCouldBeCombatTransport);
<span class="fc" id="L1763">      enemyUnitsMatch.add(Matches.unitIsNotSubmerged(m_data));</span>
<span class="fc" id="L1764">      enemyUnitsMatch.add(Matches.unitCanAttack(player));</span>
<span class="fc" id="L1765">      final Collection&lt;Unit&gt; enemyUnits = Match.getMatches(m_battleSite.getUnits().getUnits(), enemyUnitsMatch);</span>
      // If there are attackers set their movement to 0 and kill the transports
<span class="pc bpc" id="L1767" title="1 of 2 branches missed.">      if (enemyUnits.size() &gt; 0) {</span>
<span class="fc" id="L1768">        final Change change = ChangeFactory.markNoMovementChange(Match.getMatches(enemyUnits, Matches.UnitIsSea));</span>
<span class="fc" id="L1769">        bridge.addChange(change);</span>
<span class="fc" id="L1770">        final boolean defender = player.equals(m_defender);</span>
<span class="fc" id="L1771">        remove(alliedTransports, bridge, m_battleSite, false, defender);</span>
      }
    }
<span class="fc" id="L1774">  }</span>

  private void checkForUnitsThatCanRollLeft(final IDelegateBridge bridge, final boolean attacker) {
    // if we are the attacker, we can retreat instead of dying
<span class="fc bfc" id="L1778" title="All 2 branches covered.">    if (attacker</span>
<span class="pc bpc" id="L1779" title="1 of 4 branches missed.">        &amp;&amp; (!getAttackerRetreatTerritories().isEmpty() || Match.someMatch(m_attackingUnits, Matches.UnitIsAir))) {</span>
<span class="fc" id="L1780">      return;</span>
    }
<span class="pc bpc" id="L1782" title="1 of 4 branches missed.">    if (m_attackingUnits.isEmpty() || m_defendingUnits.isEmpty()) {</span>
<span class="fc" id="L1783">      return;</span>
    }
<span class="fc" id="L1785">    final CompositeMatch&lt;Unit&gt; notSubmergedAndType = new CompositeMatchAnd&lt;&gt;(Matches.unitIsNotSubmerged(m_data));</span>
<span class="fc bfc" id="L1786" title="All 2 branches covered.">    if (Matches.TerritoryIsLand.match(m_battleSite)) {</span>
<span class="fc" id="L1787">      notSubmergedAndType.add(Matches.UnitIsSea.invert());</span>
<span class="fc" id="L1788">    } else {</span>
<span class="fc" id="L1789">      notSubmergedAndType.add(Matches.UnitIsLand.invert());</span>
    }
    final Collection&lt;Unit&gt; unitsToKill;
    final boolean hasUnitsThatCanRollLeft;
<span class="fc bfc" id="L1793" title="All 2 branches covered.">    if (attacker) {</span>
<span class="fc" id="L1794">      hasUnitsThatCanRollLeft = Match.someMatch(m_attackingUnits, new CompositeMatchAnd&lt;&gt;(notSubmergedAndType,</span>
<span class="fc" id="L1795">          Matches.UnitIsSupporterOrHasCombatAbility(attacker, m_data)));</span>
<span class="fc" id="L1796">      unitsToKill = Match.getMatches(m_attackingUnits,</span>
<span class="fc" id="L1797">          new CompositeMatchAnd&lt;&gt;(notSubmergedAndType, Matches.UnitIsNotInfrastructure));</span>
<span class="fc" id="L1798">    } else {</span>
<span class="fc" id="L1799">      hasUnitsThatCanRollLeft = Match.someMatch(m_defendingUnits, new CompositeMatchAnd&lt;&gt;(notSubmergedAndType,</span>
<span class="fc" id="L1800">          Matches.UnitIsSupporterOrHasCombatAbility(attacker, m_data)));</span>
<span class="fc" id="L1801">      unitsToKill = Match.getMatches(m_defendingUnits,</span>
<span class="fc" id="L1802">          new CompositeMatchAnd&lt;&gt;(notSubmergedAndType, Matches.UnitIsNotInfrastructure));</span>
    }
<span class="fc bfc" id="L1804" title="All 2 branches covered.">    final boolean enemy = !attacker;</span>
    final boolean enemyHasUnitsThatCanRollLeft;
<span class="fc bfc" id="L1806" title="All 2 branches covered.">    if (enemy) {</span>
<span class="fc" id="L1807">      enemyHasUnitsThatCanRollLeft = Match.someMatch(m_attackingUnits,</span>
<span class="fc" id="L1808">          new CompositeMatchAnd&lt;&gt;(notSubmergedAndType, Matches.UnitIsSupporterOrHasCombatAbility(enemy, m_data)));</span>
<span class="fc" id="L1809">    } else {</span>
<span class="fc" id="L1810">      enemyHasUnitsThatCanRollLeft = Match.someMatch(m_defendingUnits,</span>
<span class="fc" id="L1811">          new CompositeMatchAnd&lt;&gt;(notSubmergedAndType, Matches.UnitIsSupporterOrHasCombatAbility(enemy, m_data)));</span>
    }
<span class="pc bpc" id="L1813" title="3 of 4 branches missed.">    if (!hasUnitsThatCanRollLeft &amp;&amp; enemyHasUnitsThatCanRollLeft) {</span>
<span class="nc bnc" id="L1814" title="All 2 branches missed.">      remove(unitsToKill, bridge, m_battleSite, false, !attacker);</span>
    }
<span class="fc" id="L1816">  }</span>

  /**
   * Submerge attacking/defending SUBS if they're alone OR with TRNS against only AIRCRAFT
   *
   * @param bridge
   * @param player
   * @param defender
   */
  private void submergeSubsVsOnlyAir(final IDelegateBridge bridge) {
    // if All attackers are AIR submerge any defending subs ..m_defendingUnits.removeAll(m_killed);
<span class="pc bpc" id="L1827" title="1 of 4 branches missed.">    if (Match.allMatch(m_attackingUnits, Matches.UnitIsAir) &amp;&amp; Match.someMatch(m_defendingUnits, Matches.UnitIsSub)) {</span>
      // Get all defending subs (including allies) in the territory.
<span class="nc" id="L1829">      final List&lt;Unit&gt; defendingSubs = Match.getMatches(m_defendingUnits, Matches.UnitIsSub);</span>
      // submerge defending subs
<span class="nc" id="L1831">      submergeUnits(defendingSubs, true, bridge);</span>
      // checking defending air on attacking subs
<span class="pc bpc" id="L1833" title="1 of 2 branches missed.">    } else if (Match.allMatch(m_defendingUnits, Matches.UnitIsAir)</span>
<span class="nc bnc" id="L1834" title="All 2 branches missed.">        &amp;&amp; Match.someMatch(m_attackingUnits, Matches.UnitIsSub)) {</span>
      // Get all attacking subs in the territory
<span class="nc" id="L1836">      final List&lt;Unit&gt; attackingSubs = Match.getMatches(m_attackingUnits, Matches.UnitIsSub);</span>
      // submerge attacking subs
<span class="nc" id="L1838">      submergeUnits(attackingSubs, false, bridge);</span>
    }
<span class="fc" id="L1840">  }</span>

  private void defendNonSubs(final IDelegateBridge bridge) {
<span class="fc bfc" id="L1843" title="All 2 branches covered.">    if (m_attackingUnits.size() == 0) {</span>
<span class="fc" id="L1844">      return;</span>
    }
<span class="fc" id="L1846">    Collection&lt;Unit&gt; units = new ArrayList&lt;&gt;(m_defendingUnits.size() + m_defendingWaitingToDie.size());</span>
<span class="fc" id="L1847">    units.addAll(m_defendingUnits);</span>
<span class="fc" id="L1848">    units.addAll(m_defendingWaitingToDie);</span>
<span class="fc" id="L1849">    units = Match.getMatches(units, Matches.UnitIsNotSub);</span>
    // if restricted, remove aircraft from attackers
<span class="fc bfc" id="L1851" title="All 4 branches covered.">    if (isAirAttackSubRestricted() &amp;&amp; !canAirAttackSubs(m_attackingUnits, units)) {</span>
<span class="fc" id="L1852">      units.removeAll(Match.getMatches(units, Matches.UnitIsAir));</span>
    }
<span class="fc bfc" id="L1854" title="All 2 branches covered.">    if (units.isEmpty()) {</span>
<span class="fc" id="L1855">      return;</span>
    }
<span class="fc" id="L1857">    final List&lt;Unit&gt; allEnemyUnitsAliveOrWaitingToDie = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1858">    allEnemyUnitsAliveOrWaitingToDie.addAll(m_attackingUnits);</span>
<span class="fc" id="L1859">    allEnemyUnitsAliveOrWaitingToDie.addAll(m_attackingWaitingToDie);</span>
<span class="fc" id="L1860">    fire(m_attacker.getName() + SELECT_CASUALTIES, units, m_attackingUnits, allEnemyUnitsAliveOrWaitingToDie, true,</span>
<span class="fc" id="L1861">        ReturnFire.ALL, bridge, &quot;Defenders fire, &quot;);</span>
<span class="fc" id="L1862">  }</span>

  // If there are no attacking DDs but defending SUBs, fire AIR at non-SUB forces ONLY
  private void attackAirOnNonSubs(final IDelegateBridge bridge) {
<span class="fc bfc" id="L1866" title="All 2 branches covered.">    if (m_defendingUnits.size() == 0) {</span>
<span class="fc" id="L1867">      return;</span>
    }
<span class="fc" id="L1869">    Collection&lt;Unit&gt; units = new ArrayList&lt;&gt;(m_attackingUnits.size() + m_attackingWaitingToDie.size());</span>
<span class="fc" id="L1870">    units.addAll(m_attackingUnits);</span>
<span class="fc" id="L1871">    units.addAll(m_attackingWaitingToDie);</span>
    // See if allied air can participate in combat
<span class="pc bpc" id="L1873" title="1 of 2 branches missed.">    if (!isAlliedAirIndependent()) {</span>
<span class="fc" id="L1874">      units = Match.getMatches(units, Matches.unitIsOwnedBy(m_attacker));</span>
    }
<span class="fc bfc" id="L1876" title="All 2 branches covered.">    if (!canAirAttackSubs(m_defendingUnits, units)) {</span>
<span class="fc" id="L1877">      units = Match.getMatches(units, Matches.UnitIsAir);</span>
<span class="fc" id="L1878">      final Collection&lt;Unit&gt; enemyUnitsNotSubs = Match.getMatches(m_defendingUnits, Matches.UnitIsNotSub);</span>
<span class="fc" id="L1879">      final List&lt;Unit&gt; allEnemyUnitsAliveOrWaitingToDie = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1880">      allEnemyUnitsAliveOrWaitingToDie.addAll(m_defendingUnits);</span>
<span class="fc" id="L1881">      allEnemyUnitsAliveOrWaitingToDie.addAll(m_defendingWaitingToDie);</span>
<span class="fc" id="L1882">      fire(m_defender.getName() + SELECT_CASUALTIES, units, enemyUnitsNotSubs, allEnemyUnitsAliveOrWaitingToDie, false,</span>
<span class="fc" id="L1883">          ReturnFire.ALL, bridge, &quot;Attacker's aircraft fire,&quot;);</span>
    }
<span class="fc" id="L1885">  }</span>

  private boolean canAirAttackSubs(final Collection&lt;Unit&gt; firedAt, final Collection&lt;Unit&gt; firing) {
<span class="fc bfc" id="L1888" title="All 4 branches covered.">    return !(m_battleSite.isWater() &amp;&amp; Match.someMatch(firedAt, Matches.UnitIsSub)</span>
<span class="pc bpc" id="L1889" title="1 of 2 branches missed.">        &amp;&amp; Match.noneMatch(firing, Matches.UnitIsDestroyer));</span>
  }

  private void defendAirOnNonSubs(final IDelegateBridge bridge) {
<span class="fc bfc" id="L1893" title="All 2 branches covered.">    if (m_attackingUnits.size() == 0) {</span>
<span class="fc" id="L1894">      return;</span>
    }
<span class="fc" id="L1896">    Collection&lt;Unit&gt; units = new ArrayList&lt;&gt;(m_defendingUnits.size() + m_defendingWaitingToDie.size());</span>
<span class="fc" id="L1897">    units.addAll(m_defendingUnits);</span>
<span class="fc" id="L1898">    units.addAll(m_defendingWaitingToDie);</span>

<span class="fc bfc" id="L1900" title="All 2 branches covered.">    if (!canAirAttackSubs(m_attackingUnits, units)) {</span>
<span class="fc" id="L1901">      units = Match.getMatches(units, Matches.UnitIsAir);</span>
<span class="fc" id="L1902">      final Collection&lt;Unit&gt; enemyUnitsNotSubs = Match.getMatches(m_attackingUnits, Matches.UnitIsNotSub);</span>
<span class="fc bfc" id="L1903" title="All 2 branches covered.">      if (enemyUnitsNotSubs.isEmpty()) {</span>
<span class="fc" id="L1904">        return;</span>
      }
<span class="fc" id="L1906">      final List&lt;Unit&gt; allEnemyUnitsAliveOrWaitingToDie = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1907">      allEnemyUnitsAliveOrWaitingToDie.addAll(m_attackingUnits);</span>
<span class="fc" id="L1908">      allEnemyUnitsAliveOrWaitingToDie.addAll(m_attackingWaitingToDie);</span>
<span class="fc" id="L1909">      fire(m_attacker.getName() + SELECT_CASUALTIES, units, enemyUnitsNotSubs, allEnemyUnitsAliveOrWaitingToDie, true,</span>
<span class="fc" id="L1910">          ReturnFire.ALL, bridge, &quot;Defender's aircraft fire,&quot;);</span>
    }
<span class="fc" id="L1912">  }</span>

  // If there are no attacking DDs, but defending SUBs, remove attacking AIR as they've already fired- otherwise fire
  // all attackers.
  private void attackNonSubs(final IDelegateBridge bridge) {
<span class="fc bfc" id="L1917" title="All 2 branches covered.">    if (m_defendingUnits.size() == 0) {</span>
<span class="fc" id="L1918">      return;</span>
    }
<span class="fc" id="L1920">    Collection&lt;Unit&gt; units = Match.getMatches(m_attackingUnits, Matches.UnitIsNotSub);</span>
<span class="fc" id="L1921">    units.addAll(Match.getMatches(m_attackingWaitingToDie, Matches.UnitIsNotSub));</span>
    // See if allied air can participate in combat
<span class="pc bpc" id="L1923" title="1 of 2 branches missed.">    if (!isAlliedAirIndependent()) {</span>
<span class="fc" id="L1924">      units = Match.getMatches(units, Matches.unitIsOwnedBy(m_attacker));</span>
    }
    // if restricted, remove aircraft from attackers
<span class="fc bfc" id="L1927" title="All 4 branches covered.">    if (isAirAttackSubRestricted() &amp;&amp; !canAirAttackSubs(m_defendingUnits, units)) {</span>
<span class="fc" id="L1928">      units.removeAll(Match.getMatches(units, Matches.UnitIsAir));</span>
    }
<span class="fc bfc" id="L1930" title="All 2 branches covered.">    if (units.isEmpty()) {</span>
<span class="fc" id="L1931">      return;</span>
    }
<span class="fc" id="L1933">    final List&lt;Unit&gt; allEnemyUnitsAliveOrWaitingToDie = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1934">    allEnemyUnitsAliveOrWaitingToDie.addAll(m_defendingUnits);</span>
<span class="fc" id="L1935">    allEnemyUnitsAliveOrWaitingToDie.addAll(m_defendingWaitingToDie);</span>
<span class="fc" id="L1936">    fire(m_defender.getName() + SELECT_CASUALTIES, units, m_defendingUnits, allEnemyUnitsAliveOrWaitingToDie, false,</span>
<span class="fc" id="L1937">        ReturnFire.ALL, bridge, &quot;Attackers fire,&quot;);</span>
<span class="fc" id="L1938">  }</span>

  private void attackSubs(final IDelegateBridge bridge, final ReturnFire returnFire) {
<span class="fc" id="L1941">    final Collection&lt;Unit&gt; firing = Match.getMatches(m_attackingUnits, Matches.UnitIsSub);</span>
<span class="fc bfc" id="L1942" title="All 2 branches covered.">    if (firing.isEmpty()) {</span>
<span class="fc" id="L1943">      return;</span>
    }
<span class="fc" id="L1945">    final Collection&lt;Unit&gt; attacked = Match.getMatches(m_defendingUnits, Matches.UnitIsNotAir);</span>
    // if there are destroyers in the attacked units, we can return fire.
<span class="fc" id="L1947">    final List&lt;Unit&gt; allEnemyUnitsAliveOrWaitingToDie = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1948">    allEnemyUnitsAliveOrWaitingToDie.addAll(m_defendingUnits);</span>
<span class="fc" id="L1949">    allEnemyUnitsAliveOrWaitingToDie.addAll(m_defendingWaitingToDie);</span>
<span class="fc" id="L1950">    fire(m_defender.getName() + SELECT_SUB_CASUALTIES, firing, attacked, allEnemyUnitsAliveOrWaitingToDie, false,</span>
<span class="fc" id="L1951">        returnFire, bridge, &quot;Subs fire,&quot;);</span>
<span class="fc" id="L1952">  }</span>

  private void defendSubs(final IDelegateBridge bridge, final ReturnFire returnFire) {
<span class="pc bpc" id="L1955" title="1 of 2 branches missed.">    if (m_attackingUnits.size() == 0) {</span>
<span class="nc" id="L1956">      return;</span>
    }
<span class="fc" id="L1958">    Collection&lt;Unit&gt; firing = new ArrayList&lt;&gt;(m_defendingUnits.size() + m_defendingWaitingToDie.size());</span>
<span class="fc" id="L1959">    firing.addAll(m_defendingUnits);</span>
<span class="fc" id="L1960">    firing.addAll(m_defendingWaitingToDie);</span>
<span class="fc" id="L1961">    firing = Match.getMatches(firing, Matches.UnitIsSub);</span>
<span class="fc bfc" id="L1962" title="All 2 branches covered.">    if (firing.isEmpty()) {</span>
<span class="fc" id="L1963">      return;</span>
    }
<span class="fc" id="L1965">    final Collection&lt;Unit&gt; attacked = Match.getMatches(m_attackingUnits, Matches.UnitIsNotAir);</span>
<span class="pc bpc" id="L1966" title="1 of 2 branches missed.">    if (attacked.isEmpty()) {</span>
<span class="nc" id="L1967">      return;</span>
    }
<span class="fc" id="L1969">    final List&lt;Unit&gt; allEnemyUnitsAliveOrWaitingToDie = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1970">    allEnemyUnitsAliveOrWaitingToDie.addAll(m_attackingUnits);</span>
<span class="fc" id="L1971">    allEnemyUnitsAliveOrWaitingToDie.addAll(m_attackingWaitingToDie);</span>
<span class="fc" id="L1972">    fire(m_attacker.getName() + SELECT_SUB_CASUALTIES, firing, attacked, allEnemyUnitsAliveOrWaitingToDie, true,</span>
<span class="fc" id="L1973">        returnFire, bridge, &quot;Subs defend, &quot;);</span>
<span class="fc" id="L1974">  }</span>

  void removeCasualties(final Collection&lt;Unit&gt; killed, final ReturnFire returnFire, final boolean defender,
      final IDelegateBridge bridge, final boolean isAA) {
<span class="fc bfc" id="L1978" title="All 2 branches covered.">    if (killed.isEmpty()) {</span>
<span class="fc" id="L1979">      return;</span>
    }
<span class="fc bfc" id="L1981" title="All 2 branches covered.">    if (returnFire == ReturnFire.ALL) {</span>
      // move to waiting to die
<span class="fc bfc" id="L1983" title="All 2 branches covered.">      if (defender) {</span>
<span class="fc" id="L1984">        m_defendingWaitingToDie.addAll(killed);</span>
<span class="fc" id="L1985">      } else {</span>
<span class="fc" id="L1986">        m_attackingWaitingToDie.addAll(killed);</span>
      }
<span class="fc bfc" id="L1988" title="All 2 branches covered.">    } else if (returnFire == ReturnFire.SUBS) {</span>
      // move to waiting to die
<span class="fc bfc" id="L1990" title="All 2 branches covered.">      if (defender) {</span>
<span class="fc" id="L1991">        m_defendingWaitingToDie.addAll(Match.getMatches(killed, Matches.UnitIsSub));</span>
<span class="fc" id="L1992">      } else {</span>
<span class="fc" id="L1993">        m_attackingWaitingToDie.addAll(Match.getMatches(killed, Matches.UnitIsSub));</span>
      }
<span class="fc" id="L1995">      remove(Match.getMatches(killed, Matches.UnitIsNotSub), bridge, m_battleSite, isAA, defender);</span>
<span class="pc bpc" id="L1996" title="1 of 2 branches missed.">    } else if (returnFire == ReturnFire.NONE) {</span>
<span class="fc" id="L1997">      remove(killed, bridge, m_battleSite, isAA, defender);</span>
    }
    // remove from the active fighting
<span class="fc bfc" id="L2000" title="All 2 branches covered.">    if (defender) {</span>
<span class="fc" id="L2001">      m_defendingUnits.removeAll(killed);</span>
<span class="fc" id="L2002">    } else {</span>
<span class="fc" id="L2003">      m_attackingUnits.removeAll(killed);</span>
    }
<span class="fc" id="L2005">  }</span>

  private void fireNavalBombardment(final IDelegateBridge bridge) {
    // TODO - check within the method for the bombarding limitations
<span class="fc" id="L2009">    final Collection&lt;Unit&gt; bombard = getBombardingUnits();</span>
<span class="fc" id="L2010">    final Collection&lt;Unit&gt; attacked = Match.getMatches(m_defendingUnits,</span>
<span class="fc" id="L2011">        Matches.UnitIsNotInfrastructureAndNotCapturedOnEntering(m_attacker, m_battleSite, m_data));</span>
    // bombarding units cant move after bombarding
<span class="fc bfc" id="L2013" title="All 2 branches covered.">    if (!m_headless) {</span>
<span class="fc" id="L2014">      final Change change = ChangeFactory.markNoMovementChange(bombard);</span>
<span class="fc" id="L2015">      bridge.addChange(change);</span>
    }
    /**
     * TODO This code is actually a bug- the property is intended to tell if the return fire is
     * RESTRICTED- but it's used as if it's ALLOWED. The reason is the default values on the
     * property definition. However, fixing this will entail a fix to the XML to reverse
     * all values. We'll leave it as is for now and try to figure out a patch strategy later.
     */
<span class="fc" id="L2023">    final boolean canReturnFire = (isNavalBombardCasualtiesReturnFire());</span>
<span class="pc bpc" id="L2024" title="1 of 4 branches missed.">    if (bombard.size() &gt; 0 &amp;&amp; attacked.size() &gt; 0) {</span>
<span class="pc bpc" id="L2025" title="1 of 2 branches missed.">      if (!m_headless) {</span>
<span class="fc" id="L2026">        bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_BOMBARD, m_attacker);</span>
      }
<span class="fc" id="L2028">      final List&lt;Unit&gt; allEnemyUnitsAliveOrWaitingToDie = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2029">      allEnemyUnitsAliveOrWaitingToDie.addAll(m_defendingUnits);</span>
<span class="fc" id="L2030">      allEnemyUnitsAliveOrWaitingToDie.addAll(m_defendingWaitingToDie);</span>
<span class="fc" id="L2031">      fire(SELECT_NAVAL_BOMBARDMENT_CASUALTIES, bombard, attacked, allEnemyUnitsAliveOrWaitingToDie, false,</span>
<span class="pc bpc" id="L2032" title="1 of 2 branches missed.">          canReturnFire ? ReturnFire.ALL : ReturnFire.NONE, bridge, &quot;Bombard&quot;);</span>
    }
<span class="fc" id="L2034">  }</span>

  private void fireSuicideUnitsAttack(final IDelegateBridge bridge) {
    // TODO: add a global toggle for returning fire (Veqryn)
<span class="fc" id="L2038">    final CompositeMatch&lt;Unit&gt; attackableUnits = new CompositeMatchAnd&lt;&gt;(</span>
<span class="fc" id="L2039">        Matches.UnitIsNotInfrastructureAndNotCapturedOnEntering(m_attacker, m_battleSite, m_data),</span>
<span class="fc" id="L2040">        Matches.UnitIsSuicide.invert(), Matches.unitIsBeingTransported().invert());</span>
<span class="fc" id="L2041">    final Collection&lt;Unit&gt; suicideAttackers = Match.getMatches(m_attackingUnits, Matches.UnitIsSuicide);</span>
<span class="fc" id="L2042">    final Collection&lt;Unit&gt; attackedDefenders = Match.getMatches(m_defendingUnits, attackableUnits);</span>
    // comparatively simple rules for isSuicide units. if AirAttackSubRestricted and you have no destroyers, you can't
    // attack subs with
    // anything.
<span class="fc bfc" id="L2046" title="All 4 branches covered.">    if (isAirAttackSubRestricted() &amp;&amp; !Match.someMatch(m_attackingUnits, Matches.UnitIsDestroyer)</span>
<span class="fc bfc" id="L2047" title="All 2 branches covered.">        &amp;&amp; Match.someMatch(attackedDefenders, Matches.UnitIsSub)) {</span>
<span class="fc" id="L2048">      attackedDefenders.removeAll(Match.getMatches(attackedDefenders, Matches.UnitIsSub));</span>
    }
<span class="pc bpc" id="L2050" title="1 of 2 branches missed.">    if (Match.allMatch(suicideAttackers, Matches.UnitIsSub)) {</span>
<span class="nc" id="L2051">      attackedDefenders.removeAll(Match.getMatches(attackedDefenders, Matches.UnitIsAir));</span>
    }
<span class="pc bpc" id="L2053" title="3 of 4 branches missed.">    if (suicideAttackers.size() == 0 || attackedDefenders.size() == 0) {</span>
<span class="fc" id="L2054">      return;</span>
    }
<span class="nc bnc" id="L2056" title="All 2 branches missed.">    final boolean canReturnFire = (!isSuicideAndMunitionCasualtiesRestricted());</span>
<span class="nc" id="L2057">    final List&lt;Unit&gt; allEnemyUnitsAliveOrWaitingToDie = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2058">    allEnemyUnitsAliveOrWaitingToDie.addAll(m_defendingUnits);</span>
<span class="nc" id="L2059">    allEnemyUnitsAliveOrWaitingToDie.addAll(m_defendingWaitingToDie);</span>
<span class="nc" id="L2060">    fire(m_defender.getName() + SELECT_CASUALTIES_SUICIDE, suicideAttackers, attackedDefenders,</span>
<span class="nc bnc" id="L2061" title="All 2 branches missed.">        allEnemyUnitsAliveOrWaitingToDie, false, canReturnFire ? ReturnFire.ALL : ReturnFire.NONE, bridge,</span>
<span class="nc" id="L2062">        SUICIDE_ATTACK);</span>
<span class="nc" id="L2063">  }</span>

  private void fireSuicideUnitsDefend(final IDelegateBridge bridge) {
<span class="pc bpc" id="L2066" title="1 of 2 branches missed.">    if (isDefendingSuicideAndMunitionUnitsDoNotFire()) {</span>
<span class="nc" id="L2067">      return;</span>
    }
    // TODO: add a global toggle for returning fire (Veqryn)
<span class="fc" id="L2070">    final CompositeMatch&lt;Unit&gt; attackableUnits = new CompositeMatchAnd&lt;&gt;(Matches.UnitIsNotInfrastructure,</span>
<span class="fc" id="L2071">        Matches.UnitIsSuicide.invert(), Matches.unitIsBeingTransported().invert());</span>
<span class="fc" id="L2072">    final Collection&lt;Unit&gt; suicideDefenders = Match.getMatches(m_defendingUnits, Matches.UnitIsSuicide);</span>
<span class="fc" id="L2073">    final Collection&lt;Unit&gt; attackedAttackers = Match.getMatches(m_attackingUnits, attackableUnits);</span>
    // comparatively simple rules for isSuicide units. if AirAttackSubRestricted and you have no destroyers, you can't
    // attack subs with
    // anything.
<span class="fc bfc" id="L2077" title="All 4 branches covered.">    if (isAirAttackSubRestricted() &amp;&amp; !Match.someMatch(m_defendingUnits, Matches.UnitIsDestroyer)</span>
<span class="fc bfc" id="L2078" title="All 2 branches covered.">        &amp;&amp; Match.someMatch(attackedAttackers, Matches.UnitIsSub)) {</span>
<span class="fc" id="L2079">      attackedAttackers.removeAll(Match.getMatches(attackedAttackers, Matches.UnitIsSub));</span>
    }
<span class="pc bpc" id="L2081" title="1 of 2 branches missed.">    if (Match.allMatch(suicideDefenders, Matches.UnitIsSub)) {</span>
<span class="nc" id="L2082">      suicideDefenders.removeAll(Match.getMatches(suicideDefenders, Matches.UnitIsAir));</span>
    }
<span class="pc bpc" id="L2084" title="3 of 4 branches missed.">    if (suicideDefenders.size() == 0 || attackedAttackers.size() == 0) {</span>
<span class="fc" id="L2085">      return;</span>
    }
<span class="nc bnc" id="L2087" title="All 2 branches missed.">    final boolean canReturnFire = (!isSuicideAndMunitionCasualtiesRestricted());</span>
<span class="nc" id="L2088">    final List&lt;Unit&gt; allEnemyUnitsAliveOrWaitingToDie = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2089">    allEnemyUnitsAliveOrWaitingToDie.addAll(m_attackingUnits);</span>
<span class="nc" id="L2090">    allEnemyUnitsAliveOrWaitingToDie.addAll(m_attackingWaitingToDie);</span>
<span class="nc" id="L2091">    fire(m_attacker.getName() + SELECT_CASUALTIES_SUICIDE, suicideDefenders, attackedAttackers,</span>
<span class="nc bnc" id="L2092" title="All 2 branches missed.">        allEnemyUnitsAliveOrWaitingToDie, true, canReturnFire ? ReturnFire.ALL : ReturnFire.NONE, bridge,</span>
<span class="nc" id="L2093">        SUICIDE_DEFEND);</span>
<span class="nc" id="L2094">  }</span>

  private boolean isWW2V2() {
<span class="fc" id="L2097">    return games.strategy.triplea.Properties.getWW2V2(m_data);</span>
  }

  private boolean isWW2V3() {
<span class="fc" id="L2101">    return games.strategy.triplea.Properties.getWW2V3(m_data);</span>
  }

  private boolean isPartialAmphibiousRetreat() {
<span class="fc" id="L2105">    return games.strategy.triplea.Properties.getPartialAmphibiousRetreat(m_data);</span>
  }

  private boolean isAlliedAirIndependent() {
<span class="fc" id="L2109">    return games.strategy.triplea.Properties.getAlliedAirIndependent(m_data);</span>
  }

  private boolean isDefendingSubsSneakAttack() {
<span class="fc" id="L2113">    return games.strategy.triplea.Properties.getDefendingSubsSneakAttack(m_data);</span>
  }

  private boolean isAttackerRetreatPlanes() {
<span class="fc" id="L2117">    return games.strategy.triplea.Properties.getAttackerRetreatPlanes(m_data);</span>
  }

  private boolean isNavalBombardCasualtiesReturnFire() {
<span class="fc" id="L2121">    return games.strategy.triplea.Properties.getNavalBombardCasualtiesReturnFireRestricted(m_data);</span>
  }

  private boolean isSuicideAndMunitionCasualtiesRestricted() {
<span class="nc" id="L2125">    return games.strategy.triplea.Properties.getSuicideAndMunitionCasualtiesRestricted(m_data);</span>
  }

  private boolean isDefendingSuicideAndMunitionUnitsDoNotFire() {
<span class="fc" id="L2129">    return games.strategy.triplea.Properties.getDefendingSuicideAndMunitionUnitsDoNotFire(m_data);</span>
  }

  private boolean isAirAttackSubRestricted() {
<span class="fc" id="L2133">    return games.strategy.triplea.Properties.getAirAttackSubRestricted(m_data);</span>
  }

  private boolean isSubRetreatBeforeBattle() {
<span class="fc" id="L2137">    return games.strategy.triplea.Properties.getSubRetreatBeforeBattle(m_data);</span>
  }

  private boolean isTransportCasualtiesRestricted() {
<span class="fc" id="L2141">    return games.strategy.triplea.Properties.getTransportCasualtiesRestricted(m_data);</span>
  }

  /**
   * @return territories where there are amphibious attacks
   */
  public Collection&lt;Territory&gt; getAmphibiousAttackTerritories() {
<span class="nc" id="L2148">    return m_amphibiousAttackFrom;</span>
  }

  private void fireOffensiveAAGuns(final IDelegateBridge bridge) {
<span class="nc" id="L2152">    m_stack.push(new FireAA(false));</span>
<span class="nc" id="L2153">  }</span>

  private void fireDefensiveAAGuns(final IDelegateBridge bridge) {
<span class="nc" id="L2156">    m_stack.push(new FireAA(true));</span>
<span class="nc" id="L2157">  }</span>

  class FireAA implements IExecutable {
    private static final long serialVersionUID = -6406659798754841382L;
    private final boolean m_defending;
    private DiceRoll m_dice;
    private CasualtyDetails m_casualties;
<span class="nc" id="L2164">    Collection&lt;Unit&gt; m_casualtiesSoFar = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L2166">    private FireAA(final boolean defending) {</span>
<span class="nc" id="L2167">      m_defending = defending;</span>
<span class="nc" id="L2168">    }</span>

    @Override
    public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="nc bnc" id="L2172" title="All 8 branches missed.">      if ((m_defending &amp;&amp; !canFireDefendingAA()) || (!m_defending &amp;&amp; !canFireOffensiveAA())) {</span>
<span class="nc" id="L2173">        return;</span>
      }
<span class="nc bnc" id="L2175" title="All 4 branches missed.">      for (final String currentTypeAA : (m_defending ? m_defendingAAtypes : m_offensiveAAtypes)) {</span>
<span class="nc" id="L2176">        final Collection&lt;Unit&gt; currentPossibleAA =</span>
<span class="nc bnc" id="L2177" title="All 2 branches missed.">            Match.getMatches((m_defending ? m_defendingAA : m_offensiveAA), Matches.UnitIsAAofTypeAA(currentTypeAA));</span>
<span class="nc" id="L2178">        final Set&lt;UnitType&gt; targetUnitTypesForThisTypeAA =</span>
<span class="nc" id="L2179">            UnitAttachment.get(currentPossibleAA.iterator().next().getType()).getTargetsAA(m_data);</span>
<span class="nc" id="L2180">        final Set&lt;UnitType&gt; airborneTypesTargettedToo =</span>
<span class="nc bnc" id="L2181" title="All 2 branches missed.">            m_defending ? TechAbilityAttachment.getAirborneTargettedByAA(m_attacker, m_data).get(currentTypeAA)</span>
<span class="nc" id="L2182">                : new HashSet&lt;&gt;();</span>
<span class="nc" id="L2183">        final Collection&lt;Unit&gt; validAttackingUnitsForThisRoll =</span>
<span class="nc bnc" id="L2184" title="All 2 branches missed.">            Match.getMatches((m_defending ? m_attackingUnits : m_defendingUnits),</span>
<span class="nc" id="L2185">                new CompositeMatchOr&lt;&gt;(Matches</span>
<span class="nc" id="L2186">                    .unitIsOfTypes(targetUnitTypesForThisTypeAA),</span>
<span class="nc" id="L2187">                    new CompositeMatchAnd&lt;Unit&gt;(Matches.UnitIsAirborne,</span>
<span class="nc" id="L2188">                        Matches.unitIsOfTypes(airborneTypesTargettedToo))));</span>
<span class="nc" id="L2189">        final IExecutable rollDice = new IExecutable() {</span>
          private static final long serialVersionUID = 6435935558879109347L;

          @Override
          public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="nc" id="L2194">            validAttackingUnitsForThisRoll.removeAll(m_casualtiesSoFar);</span>
<span class="nc bnc" id="L2195" title="All 2 branches missed.">            if (!validAttackingUnitsForThisRoll.isEmpty()) {</span>
<span class="nc" id="L2196">              m_dice =</span>
<span class="nc" id="L2197">                  DiceRoll.rollAA(validAttackingUnitsForThisRoll, currentPossibleAA, bridge, m_battleSite, m_defending);</span>
<span class="nc bnc" id="L2198" title="All 2 branches missed.">              if (!m_headless) {</span>
<span class="nc bnc" id="L2199" title="All 2 branches missed.">                if (currentTypeAA.equals(&quot;AA&quot;)) {</span>
<span class="nc bnc" id="L2200" title="All 2 branches missed.">                  if (m_dice.getHits() &gt; 0) {</span>
<span class="nc" id="L2201">                    bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_AA_HIT,</span>
<span class="nc bnc" id="L2202" title="All 2 branches missed.">                        (m_defending ? m_defender : m_attacker));</span>
<span class="nc" id="L2203">                  } else {</span>
<span class="nc" id="L2204">                    bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_AA_MISS,</span>
<span class="nc bnc" id="L2205" title="All 2 branches missed.">                        (m_defending ? m_defender : m_attacker));</span>
                  }
<span class="nc" id="L2207">                } else {</span>
<span class="nc bnc" id="L2208" title="All 2 branches missed.">                  if (m_dice.getHits() &gt; 0) {</span>
<span class="nc" id="L2209">                    bridge.getSoundChannelBroadcaster().playSoundForAll(</span>
<span class="nc" id="L2210">                        SoundPath.CLIP_BATTLE_X_PREFIX + currentTypeAA.toLowerCase() + SoundPath.CLIP_BATTLE_X_HIT,</span>
<span class="nc bnc" id="L2211" title="All 2 branches missed.">                        (m_defending ? m_defender : m_attacker));</span>
<span class="nc" id="L2212">                  } else {</span>
<span class="nc" id="L2213">                    bridge.getSoundChannelBroadcaster().playSoundForAll(</span>
<span class="nc" id="L2214">                        SoundPath.CLIP_BATTLE_X_PREFIX + currentTypeAA.toLowerCase() + SoundPath.CLIP_BATTLE_X_MISS,</span>
<span class="nc bnc" id="L2215" title="All 2 branches missed.">                        (m_defending ? m_defender : m_attacker));</span>
                  }
                }
              }
            }
<span class="nc" id="L2220">          }</span>
        };
<span class="nc" id="L2222">        final IExecutable selectCasualties = new IExecutable() {</span>
          private static final long serialVersionUID = 7943295620796835166L;

          @Override
          public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="nc bnc" id="L2227" title="All 2 branches missed.">            if (!validAttackingUnitsForThisRoll.isEmpty()) {</span>
<span class="nc" id="L2228">              final CasualtyDetails details =</span>
<span class="nc" id="L2229">                  selectCasualties(validAttackingUnitsForThisRoll, currentPossibleAA, bridge, currentTypeAA);</span>
<span class="nc" id="L2230">              markDamaged(details.getDamaged(), bridge, true);</span>
<span class="nc" id="L2231">              m_casualties = details;</span>
<span class="nc" id="L2232">              m_casualtiesSoFar.addAll(details.getKilled());</span>
            }
<span class="nc" id="L2234">          }</span>
        };
<span class="nc" id="L2236">        final IExecutable notifyCasualties = new IExecutable() {</span>
          private static final long serialVersionUID = -6759782085212899725L;

          @Override
          public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {
<span class="nc bnc" id="L2241" title="All 2 branches missed.">            if (!validAttackingUnitsForThisRoll.isEmpty()) {</span>
<span class="nc" id="L2242">              notifyCasualtiesAA(bridge, currentTypeAA);</span>
<span class="nc bnc" id="L2243" title="All 2 branches missed.">              removeCasualties(m_casualties.getKilled(), ReturnFire.ALL, !m_defending, bridge, m_defending);</span>
            }
<span class="nc" id="L2245">          }</span>
        };
        // push in reverse order of execution
<span class="nc" id="L2248">        stack.push(notifyCasualties);</span>
<span class="nc" id="L2249">        stack.push(selectCasualties);</span>
<span class="nc" id="L2250">        stack.push(rollDice);</span>
      }
<span class="nc" id="L2252">    }</span>

    private CasualtyDetails selectCasualties(final Collection&lt;Unit&gt; validAttackingUnitsForThisRoll,
        final Collection&lt;Unit&gt; defendingAA, final IDelegateBridge bridge, final String currentTypeAA) {
      // send defender the dice roll so he can see what the dice are while he waits for attacker to select casualties
<span class="nc bnc" id="L2257" title="All 2 branches missed.">      getDisplay(bridge).notifyDice(m_dice, (m_defending ? m_attacker.getName() : m_defender.getName())</span>
<span class="nc" id="L2258">          + SELECT_PREFIX + currentTypeAA + CASUALTIES_SUFFIX);</span>
<span class="nc bnc" id="L2259" title="All 2 branches missed.">      return BattleCalculator.getAACasualties(!m_defending, validAttackingUnitsForThisRoll,</span>
<span class="nc bnc" id="L2260" title="All 2 branches missed.">          (m_defending ? m_attackingUnits : m_defendingUnits), defendingAA,</span>
<span class="nc bnc" id="L2261" title="All 4 branches missed.">          (m_defending ? m_defendingUnits : m_attackingUnits), m_dice, bridge, (m_defending ? m_defender : m_attacker),</span>
<span class="nc bnc" id="L2262" title="All 2 branches missed.">          (m_defending ? m_attacker : m_defender), m_battleID, m_battleSite, m_territoryEffects, m_isAmphibious,</span>
<span class="nc" id="L2263">          m_amphibiousLandAttackers);</span>
    }

    private void notifyCasualtiesAA(final IDelegateBridge bridge, final String currentTypeAA) {
<span class="nc bnc" id="L2267" title="All 2 branches missed.">      if (m_headless) {</span>
<span class="nc" id="L2268">        return;</span>
      }
<span class="nc" id="L2270">      getDisplay(bridge).casualtyNotification(m_battleID,</span>
<span class="nc bnc" id="L2271" title="All 2 branches missed.">          (m_defending ? m_attacker.getName() : m_defender.getName()) + REMOVE_PREFIX + currentTypeAA</span>
<span class="nc" id="L2272">              + CASUALTIES_SUFFIX,</span>
<span class="nc bnc" id="L2273" title="All 2 branches missed.">          m_dice, (m_defending ? m_attacker : m_defender), new ArrayList&lt;&gt;(m_casualties.getKilled()),</span>
<span class="nc" id="L2274">          new ArrayList&lt;&gt;(m_casualties.getDamaged()), m_dependentUnits);</span>
<span class="nc bnc" id="L2275" title="All 2 branches missed.">      getRemote((m_defending ? m_attacker : m_defender), bridge).confirmOwnCasualties(m_battleID,</span>
<span class="nc" id="L2276">          &quot;Press space to continue&quot;);</span>
<span class="nc" id="L2277">      final Runnable r = () -&gt; {</span>
        try {
<span class="nc bnc" id="L2279" title="All 2 branches missed.">          getRemote((m_defending ? m_defender : m_attacker), bridge).confirmEnemyCasualties(m_battleID,</span>
<span class="nc bnc" id="L2280" title="All 2 branches missed.">              &quot;Press space to continue&quot;, (m_defending ? m_attacker : m_defender));</span>
<span class="nc" id="L2281">        } catch (final ConnectionLostException cle) {</span>
          // somone else will deal with this
          // System.out.println(cle.getMessage());
          // cle.printStackTrace(System.out);
<span class="nc" id="L2285">        } catch (final Exception e) {</span>
          // ignore
        }
<span class="nc" id="L2288">      };</span>
<span class="nc" id="L2289">      final Thread t = new Thread(r, &quot;click to continue waiter&quot;);</span>
<span class="nc" id="L2290">      t.start();</span>
      try {
<span class="nc" id="L2292">        bridge.leaveDelegateExecution();</span>
<span class="nc" id="L2293">        t.join();</span>
<span class="nc" id="L2294">      } catch (final InterruptedException e) {</span>
        // ignore
<span class="nc" id="L2296">      } finally {</span>
<span class="nc" id="L2297">        bridge.enterDelegateExecution();</span>
<span class="nc" id="L2298">      }</span>
<span class="nc" id="L2299">    }</span>
  }

  private boolean canFireDefendingAA() {
<span class="fc bfc" id="L2303" title="All 2 branches covered.">    if (m_defendingAA == null) {</span>
<span class="fc" id="L2304">      updateDefendingAAUnits();</span>
    }
<span class="pc bpc" id="L2306" title="1 of 2 branches missed.">    return m_defendingAA.size() &gt; 0;</span>
  }

  private boolean canFireOffensiveAA() {
<span class="fc bfc" id="L2310" title="All 2 branches covered.">    if (m_offensiveAA == null) {</span>
<span class="fc" id="L2311">      updateOffensiveAAUnits();</span>
    }
<span class="pc bpc" id="L2313" title="1 of 2 branches missed.">    return m_offensiveAA.size() &gt; 0;</span>
  }

  /**
   * @return a collection containing all the combatants in units non
   *         combatants include such things as factories, aaguns, land units
   *         in a water battle.
   */
  private List&lt;Unit&gt; removeNonCombatants(final Collection&lt;Unit&gt; units, final boolean attacking, final PlayerID player,
      final boolean doNotIncludeAA, final boolean doNotIncludeSeaBombardmentUnits, final boolean removeForNextRound) {
<span class="fc" id="L2323">    final List&lt;Unit&gt; unitList = new ArrayList&lt;&gt;(units);</span>
<span class="fc bfc" id="L2324" title="All 2 branches covered.">    if (m_battleSite.isWater()) {</span>
<span class="fc" id="L2325">      unitList.removeAll(Match.getMatches(unitList, Matches.UnitIsLand));</span>
    }
    // still allow infrastructure type units that can provide support have combat abilities
    // remove infrastructure units that can't take part in combat (air/naval bases, etc...)
<span class="fc" id="L2329">    unitList.removeAll(Match.getMatches(unitList,</span>
<span class="fc bfc" id="L2330" title="All 2 branches covered.">        Matches.UnitCanBeInBattle(attacking, !m_battleSite.isWater(), m_data,</span>
<span class="fc bfc" id="L2331" title="All 2 branches covered.">            (removeForNextRound ? m_round + 1 : m_round), true, doNotIncludeAA, doNotIncludeSeaBombardmentUnits)</span>
<span class="fc" id="L2332">            .invert()));</span>
    // remove any disabled units from combat
<span class="fc" id="L2334">    unitList.removeAll(Match.getMatches(unitList, Matches.UnitIsDisabled));</span>
    // remove capturableOnEntering units (veqryn)
<span class="fc" id="L2336">    unitList.removeAll(Match.getMatches(unitList,</span>
<span class="fc" id="L2337">        Matches.UnitCanBeCapturedOnEnteringToInThisTerritory(m_attacker, m_battleSite, m_data)));</span>
    // remove any allied air units that are stuck on damaged carriers (veqryn)
<span class="fc" id="L2339">    unitList.removeAll(Match.getMatches(unitList, new CompositeMatchAnd&lt;&gt;(Matches.unitIsBeingTransported(),</span>
<span class="fc" id="L2340">        Matches.UnitIsAir, Matches.UnitCanLandOnCarrier)));</span>
    // remove any units that were in air combat (veqryn)
<span class="fc" id="L2342">    unitList.removeAll(Match.getMatches(unitList, Matches.UnitWasInAirBattle));</span>
<span class="fc" id="L2343">    return unitList;</span>
  }

  private void removeNonCombatants(final IDelegateBridge bridge, final boolean doNotIncludeAA,
      final boolean doNotIncludeSeaBombardmentUnits, final boolean removeForNextRound) {
<span class="fc" id="L2348">    final List&lt;Unit&gt; notRemovedDefending = removeNonCombatants(m_defendingUnits, false, m_defender, doNotIncludeAA,</span>
<span class="fc" id="L2349">        doNotIncludeSeaBombardmentUnits, removeForNextRound);</span>
<span class="fc" id="L2350">    final List&lt;Unit&gt; notRemovedAttacking = removeNonCombatants(m_attackingUnits, true, m_attacker, doNotIncludeAA,</span>
<span class="fc" id="L2351">        doNotIncludeSeaBombardmentUnits, removeForNextRound);</span>
<span class="fc" id="L2352">    final Collection&lt;Unit&gt; toRemoveDefending = Util.difference(m_defendingUnits, notRemovedDefending);</span>
<span class="fc" id="L2353">    final Collection&lt;Unit&gt; toRemoveAttacking = Util.difference(m_attackingUnits, notRemovedAttacking);</span>
<span class="fc" id="L2354">    m_defendingUnits = notRemovedDefending;</span>
<span class="fc" id="L2355">    m_attackingUnits = notRemovedAttacking;</span>
<span class="fc bfc" id="L2356" title="All 2 branches covered.">    if (!m_headless) {</span>
<span class="fc bfc" id="L2357" title="All 2 branches covered.">      if (!toRemoveDefending.isEmpty()) {</span>
<span class="fc" id="L2358">        getDisplay(bridge).changedUnitsNotification(m_battleID, m_defender, toRemoveDefending, null, null);</span>
      }
<span class="fc bfc" id="L2360" title="All 2 branches covered.">      if (!toRemoveAttacking.isEmpty()) {</span>
<span class="fc" id="L2361">        getDisplay(bridge).changedUnitsNotification(m_battleID, m_attacker, toRemoveAttacking, null, null);</span>
      }
    }
<span class="fc" id="L2364">  }</span>

  private void landParatroops(final IDelegateBridge bridge) {
<span class="pc bpc" id="L2367" title="1 of 2 branches missed.">    if (TechAttachment.isAirTransportable(m_attacker)) {</span>
<span class="nc" id="L2368">      final Collection&lt;Unit&gt; airTransports =</span>
<span class="nc" id="L2369">          Match.getMatches(m_battleSite.getUnits().getUnits(), Matches.UnitIsAirTransport);</span>
<span class="nc bnc" id="L2370" title="All 2 branches missed.">      if (!airTransports.isEmpty()) {</span>
<span class="nc" id="L2371">        final Collection&lt;Unit&gt; dependents = getDependentUnits(airTransports);</span>
<span class="nc bnc" id="L2372" title="All 2 branches missed.">        if (!dependents.isEmpty()) {</span>
<span class="nc" id="L2373">          final Iterator&lt;Unit&gt; dependentsIter = dependents.iterator();</span>
<span class="nc" id="L2374">          final CompositeChange change = new CompositeChange();</span>
          // remove dependency from paratroops
          // unload the transports
<span class="nc bnc" id="L2377" title="All 2 branches missed.">          while (dependentsIter.hasNext()) {</span>
<span class="nc" id="L2378">            final Unit unit = dependentsIter.next();</span>
<span class="nc" id="L2379">            change.add(TransportTracker.unloadAirTransportChange((TripleAUnit) unit, m_battleSite, m_attacker, false));</span>
          }
<span class="nc" id="L2381">          bridge.addChange(change);</span>
          // remove bombers from m_dependentUnits
<span class="nc bnc" id="L2383" title="All 2 branches missed.">          for (final Unit unit : airTransports) {</span>
<span class="nc" id="L2384">            m_dependentUnits.remove(unit);</span>
          }
        }
      }
    }
<span class="fc" id="L2389">  }</span>

  private void markNoMovementLeft(final IDelegateBridge bridge) {
<span class="fc bfc" id="L2392" title="All 2 branches covered.">    if (m_headless) {</span>
<span class="fc" id="L2393">      return;</span>
    }
<span class="fc" id="L2395">    final Collection&lt;Unit&gt; attackingNonAir = Match.getMatches(m_attackingUnits, Matches.UnitIsAir.invert());</span>
<span class="fc" id="L2396">    final Change noMovementChange = ChangeFactory.markNoMovementChange(attackingNonAir);</span>
<span class="fc bfc" id="L2397" title="All 2 branches covered.">    if (!noMovementChange.isEmpty()) {</span>
<span class="fc" id="L2398">      bridge.addChange(noMovementChange);</span>
    }
<span class="fc" id="L2400">  }</span>

  // Figure out what units a transport is transported and has unloaded
  public Collection&lt;Unit&gt; getTransportDependents(final Collection&lt;Unit&gt; targets, final GameData data) {
<span class="fc bfc" id="L2404" title="All 2 branches covered.">    if (m_headless) {</span>
<span class="fc" id="L2405">      return Collections.emptyList();</span>
    }
<span class="fc" id="L2407">    final Collection&lt;Unit&gt; dependents = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L2408" title="1 of 2 branches missed.">    if (Match.someMatch(targets, Matches.UnitCanTransport)) {</span>
      // just worry about transports
<span class="fc bfc" id="L2410" title="All 2 branches covered.">      for (final Unit target : targets) {</span>
<span class="fc" id="L2411">        dependents.addAll(TransportTracker.transportingAndUnloaded(target));</span>
      }
    }
<span class="fc" id="L2414">    return dependents;</span>
  }

  private void remove(final Collection&lt;Unit&gt; killed, final IDelegateBridge bridge, final Territory battleSite,
      final boolean isAA, final Boolean defenderDying) {
<span class="fc bfc" id="L2419" title="All 2 branches covered.">    if (killed.size() == 0) {</span>
<span class="fc" id="L2420">      return;</span>
    }
<span class="fc" id="L2422">    final Collection&lt;Unit&gt; dependent = getDependentUnits(killed);</span>
<span class="fc" id="L2423">    killed.addAll(dependent);</span>
<span class="fc" id="L2424">    final Change killedChange = ChangeFactory.removeUnits(battleSite, killed);</span>
<span class="fc" id="L2425">    m_killed.addAll(killed);</span>
<span class="fc" id="L2426">    final String transcriptText = MyFormatter.unitsToText(killed) + &quot; lost in &quot; + battleSite.getName();</span>
<span class="fc" id="L2427">    bridge.getHistoryWriter().addChildToEvent(transcriptText, new ArrayList&lt;&gt;(killed));</span>
<span class="fc" id="L2428">    bridge.addChange(killedChange);</span>
<span class="fc" id="L2429">    final Collection&lt;IBattle&gt; dependentBattles = m_battleTracker.getBlocked(this);</span>
    // If there are NO dependent battles, check for unloads in allied territories
<span class="fc bfc" id="L2431" title="All 2 branches covered.">    if (dependentBattles.isEmpty()) {</span>
<span class="fc" id="L2432">      removeFromNonCombatLandings(killed, bridge);</span>
      // otherwise remove them and the units involved
<span class="fc" id="L2434">    } else {</span>
<span class="fc" id="L2435">      removeFromDependents(killed, bridge, dependentBattles);</span>
    }
    // and remove them from the battle display
<span class="fc bfc" id="L2438" title="All 4 branches covered.">    if (defenderDying == null || defenderDying) {</span>
<span class="fc" id="L2439">      m_defendingUnits.removeAll(killed);</span>
    }
<span class="fc bfc" id="L2441" title="All 4 branches covered.">    if (defenderDying == null || !defenderDying) {</span>
<span class="fc" id="L2442">      m_attackingUnits.removeAll(killed);</span>
    }
<span class="fc" id="L2444">  }</span>

  private void removeFromDependents(final Collection&lt;Unit&gt; units, final IDelegateBridge bridge,
      final Collection&lt;IBattle&gt; dependents) {
<span class="fc bfc" id="L2448" title="All 2 branches covered.">    for (final IBattle dependent : dependents) {</span>
<span class="fc" id="L2449">      dependent.unitsLostInPrecedingBattle(this, units, bridge, false);</span>
    }
<span class="fc" id="L2451">  }</span>

  // Remove landed units from allied territory when their transport sinks
  private void removeFromNonCombatLandings(final Collection&lt;Unit&gt; units, final IDelegateBridge bridge) {
<span class="fc bfc" id="L2455" title="All 2 branches covered.">    for (final Unit transport : Match.getMatches(units, Matches.UnitIsTransport)) {</span>
<span class="fc" id="L2456">      final Collection&lt;Unit&gt; lost = getTransportDependents(Collections.singleton(transport), m_data);</span>
<span class="pc bpc" id="L2457" title="1 of 2 branches missed.">      if (lost.isEmpty()) {</span>
<span class="fc" id="L2458">        continue;</span>
      }
<span class="nc" id="L2460">      final Territory landedTerritory = TransportTracker.getTerritoryTransportHasUnloadedTo(transport);</span>
<span class="nc bnc" id="L2461" title="All 2 branches missed.">      if (landedTerritory == null) {</span>
<span class="nc" id="L2462">        throw new IllegalStateException(&quot;not unloaded?:&quot; + units);</span>
      }
<span class="nc" id="L2464">      remove(lost, bridge, landedTerritory, false, false);</span>
    }
<span class="fc" id="L2466">  }</span>

  private void clearWaitingToDie(final IDelegateBridge bridge) {
<span class="fc" id="L2469">    final Collection&lt;Unit&gt; units = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2470">    units.addAll(m_attackingWaitingToDie);</span>
<span class="fc" id="L2471">    units.addAll(m_defendingWaitingToDie);</span>
<span class="fc" id="L2472">    remove(units, bridge, m_battleSite, false, null);</span>
<span class="fc" id="L2473">    m_defendingWaitingToDie.clear();</span>
<span class="fc" id="L2474">    m_attackingWaitingToDie.clear();</span>
<span class="fc" id="L2475">  }</span>

  private void defenderWins(final IDelegateBridge bridge) {
<span class="fc" id="L2478">    m_whoWon = WhoWon.DEFENDER;</span>
<span class="fc" id="L2479">    getDisplay(bridge).battleEnd(m_battleID, m_defender.getName() + &quot; win&quot;);</span>
<span class="pc bpc" id="L2480" title="1 of 2 branches missed.">    if (games.strategy.triplea.Properties.getAbandonedTerritoriesMayBeTakenOverImmediately(m_data)) {</span>
<span class="nc bnc" id="L2481" title="All 2 branches missed.">      if (Match.getMatches(m_defendingUnits, Matches.UnitIsNotInfrastructure).size() == 0) {</span>
<span class="nc" id="L2482">        final List&lt;Unit&gt; allyOfAttackerUnits = m_battleSite.getUnits().getMatches(Matches.UnitIsNotInfrastructure);</span>
<span class="nc bnc" id="L2483" title="All 2 branches missed.">        if (!allyOfAttackerUnits.isEmpty()) {</span>
<span class="nc" id="L2484">          final PlayerID abandonedToPlayer = AbstractBattle.findPlayerWithMostUnits(allyOfAttackerUnits);</span>
<span class="nc" id="L2485">          bridge.getHistoryWriter()</span>
<span class="nc" id="L2486">              .addChildToEvent(</span>
<span class="nc" id="L2487">                  abandonedToPlayer.getName() + &quot; takes over &quot; + m_battleSite.getName()</span>
<span class="nc" id="L2488">                      + &quot; as there are no defenders left&quot;,</span>
<span class="nc" id="L2489">                  allyOfAttackerUnits);</span>
          // should we create a new battle records to show the ally capturing the territory (in the case where they
          // didn't already own/allied it)?
<span class="nc" id="L2492">          m_battleTracker.takeOver(m_battleSite, abandonedToPlayer, bridge, null, allyOfAttackerUnits);</span>
        }
<span class="nc" id="L2494">      } else {</span>
        // should we create a new battle records to show the defender capturing the territory (in the case where they
        // didn't already own/allied it)?
<span class="nc" id="L2497">        m_battleTracker.takeOver(m_battleSite, m_defender, bridge, null, m_defendingUnits);</span>
      }
    }
<span class="fc" id="L2500">    bridge.getHistoryWriter().addChildToEvent(m_defender.getName() + &quot; win&quot;, new ArrayList&lt;&gt;(m_defendingUnits));</span>
<span class="fc" id="L2501">    m_battleResultDescription = BattleRecord.BattleResultDescription.LOST;</span>
<span class="fc" id="L2502">    showCasualties(bridge);</span>
<span class="fc bfc" id="L2503" title="All 2 branches covered.">    if (!m_headless) {</span>
<span class="fc" id="L2504">      m_battleTracker.getBattleRecords().addResultToBattle(m_attacker, m_battleID, m_defender, m_attackerLostTUV,</span>
<span class="fc" id="L2505">          m_defenderLostTUV, m_battleResultDescription, new BattleResults(this, m_data));</span>
    }
<span class="fc" id="L2507">    checkDefendingPlanesCanLand(bridge, m_defender);</span>
<span class="fc" id="L2508">    BattleTracker.captureOrDestroyUnits(m_battleSite, m_defender, m_defender, bridge, null);</span>
<span class="fc bfc" id="L2509" title="All 2 branches covered.">    if (!m_headless) {</span>
<span class="fc" id="L2510">      bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_FAILURE, m_attacker);</span>
    }
<span class="fc" id="L2512">  }</span>

  private void nobodyWins(final IDelegateBridge bridge) {
<span class="nc" id="L2515">    m_whoWon = WhoWon.DRAW;</span>
<span class="nc" id="L2516">    getDisplay(bridge).battleEnd(m_battleID, &quot;Stalemate&quot;);</span>
<span class="nc" id="L2517">    bridge.getHistoryWriter()</span>
<span class="nc" id="L2518">        .addChildToEvent(m_defender.getName() + &quot; and &quot; + m_attacker.getName() + &quot; reach a stalemate&quot;);</span>
<span class="nc" id="L2519">    m_battleResultDescription = BattleRecord.BattleResultDescription.STALEMATE;</span>
<span class="nc" id="L2520">    showCasualties(bridge);</span>
<span class="nc bnc" id="L2521" title="All 2 branches missed.">    if (!m_headless) {</span>
<span class="nc" id="L2522">      m_battleTracker.getBattleRecords().addResultToBattle(m_attacker, m_battleID, m_defender, m_attackerLostTUV,</span>
<span class="nc" id="L2523">          m_defenderLostTUV, m_battleResultDescription, new BattleResults(this, m_data));</span>
<span class="nc" id="L2524">      bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_STALEMATE, m_attacker);</span>
    }
<span class="nc" id="L2526">    checkDefendingPlanesCanLand(bridge, m_defender);</span>
<span class="nc" id="L2527">  }</span>

  private void attackerWins(final IDelegateBridge bridge) {
<span class="fc" id="L2530">    m_whoWon = WhoWon.ATTACKER;</span>
<span class="fc" id="L2531">    getDisplay(bridge).battleEnd(m_battleID, m_attacker.getName() + &quot; win&quot;);</span>
<span class="fc bfc" id="L2532" title="All 2 branches covered.">    if (m_headless) {</span>
<span class="fc" id="L2533">      return;</span>
    }
    // do we need to change ownership
<span class="fc bfc" id="L2536" title="All 2 branches covered.">    if (Match.someMatch(m_attackingUnits, Matches.UnitIsNotAir)) {</span>
<span class="fc bfc" id="L2537" title="All 2 branches covered.">      if (Matches.isTerritoryEnemyAndNotUnownedWater(m_attacker, m_data).match(m_battleSite)) {</span>
<span class="fc" id="L2538">        m_battleTracker.addToConquered(m_battleSite);</span>
      }
<span class="fc" id="L2540">      m_battleTracker.takeOver(m_battleSite, m_attacker, bridge, null, m_attackingUnits);</span>
<span class="fc" id="L2541">      m_battleResultDescription = BattleRecord.BattleResultDescription.CONQUERED;</span>
<span class="fc" id="L2542">    } else {</span>
<span class="fc" id="L2543">      m_battleResultDescription = BattleRecord.BattleResultDescription.WON_WITHOUT_CONQUERING;</span>
    }
    // Clear the transported_by for successfully offloaded units
<span class="fc" id="L2546">    final Collection&lt;Unit&gt; transports = Match.getMatches(m_attackingUnits, Matches.UnitIsTransport);</span>
<span class="pc bpc" id="L2547" title="1 of 2 branches missed.">    if (!transports.isEmpty()) {</span>
<span class="nc" id="L2548">      final CompositeChange change = new CompositeChange();</span>
<span class="nc" id="L2549">      final Collection&lt;Unit&gt; dependents = getTransportDependents(transports, m_data);</span>
<span class="nc bnc" id="L2550" title="All 2 branches missed.">      if (!dependents.isEmpty()) {</span>
<span class="nc bnc" id="L2551" title="All 2 branches missed.">        for (final Unit unit : dependents) {</span>
          // clear the loaded by ONLY for Combat unloads. NonCombat unloads are handled elsewhere.
<span class="nc bnc" id="L2553" title="All 2 branches missed.">          if (Matches.UnitWasUnloadedThisTurn.match(unit)) {</span>
<span class="nc" id="L2554">            change.add(ChangeFactory.unitPropertyChange(unit, null, TripleAUnit.TRANSPORTED_BY));</span>
          }
        }
<span class="nc" id="L2557">        bridge.addChange(change);</span>
      }
    }
<span class="fc" id="L2560">    bridge.getHistoryWriter().addChildToEvent(m_attacker.getName() + &quot; win&quot;, new ArrayList&lt;&gt;(m_attackingUnits));</span>
<span class="fc" id="L2561">    showCasualties(bridge);</span>
<span class="pc bpc" id="L2562" title="1 of 2 branches missed.">    if (!m_headless) {</span>
<span class="fc" id="L2563">      m_battleTracker.getBattleRecords().addResultToBattle(m_attacker, m_battleID, m_defender, m_attackerLostTUV,</span>
<span class="fc" id="L2564">          m_defenderLostTUV, m_battleResultDescription, new BattleResults(this, m_data));</span>
    }
<span class="pc bpc" id="L2566" title="1 of 2 branches missed.">    if (!m_headless) {</span>
<span class="fc bfc" id="L2567" title="All 2 branches covered.">      if (Matches.TerritoryIsWater.match(m_battleSite)) {</span>
<span class="fc bfc" id="L2568" title="All 2 branches covered.">        if (Match.allMatch(m_attackingUnits, Matches.UnitIsAir)) {</span>
<span class="fc" id="L2569">          bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_AIR_SUCCESSFUL,</span>
<span class="fc" id="L2570">              m_attacker);</span>
<span class="fc" id="L2571">        } else {</span>
          // assume some naval
<span class="fc" id="L2573">          bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_SEA_SUCCESSFUL,</span>
<span class="fc" id="L2574">              m_attacker);</span>
        }
<span class="fc" id="L2576">      } else {</span>
        // no sounds for a successful land battle, because land battle means we are going to capture a territory, and we
        // have capture sounds
        // for that
<span class="pc bpc" id="L2580" title="1 of 2 branches missed.">        if (Match.allMatch(m_attackingUnits, Matches.UnitIsAir)) {</span>
<span class="nc" id="L2581">          bridge.getSoundChannelBroadcaster().playSoundForAll(SoundPath.CLIP_BATTLE_AIR_SUCCESSFUL,</span>
<span class="nc" id="L2582">              m_attacker);</span>
        }
      }
    }
<span class="fc" id="L2586">  }</span>

  /**
   * The defender has won, but there may be defending fighters that cant stay
   * in the sea zone due to insufficient carriers.
   */
  private void checkDefendingPlanesCanLand(final IDelegateBridge bridge, final PlayerID defender) {
<span class="fc bfc" id="L2593" title="All 2 branches covered.">    if (m_headless) {</span>
<span class="fc" id="L2594">      return;</span>
    }
    // not water, not relevant.
<span class="fc bfc" id="L2597" title="All 2 branches covered.">    if (!m_battleSite.isWater()) {</span>
<span class="fc" id="L2598">      return;</span>
    }
    // TODO: why do we keep checking throughout this entire class if the units in m_defendingUnits are allied with
    // defender, and if the
    // units in m_attackingUnits are allied with the attacker? Does it really matter?
<span class="fc" id="L2603">    final CompositeMatch&lt;Unit&gt; alliedDefendingAir =</span>
<span class="fc" id="L2604">        new CompositeMatchAnd&lt;&gt;(Matches.UnitIsAir, Matches.UnitWasScrambled.invert());</span>
<span class="fc" id="L2605">    final Collection&lt;Unit&gt; m_defendingAir = Match.getMatches(m_defendingUnits, alliedDefendingAir);</span>
    // no planes, exit
<span class="fc bfc" id="L2607" title="All 2 branches covered.">    if (m_defendingAir.isEmpty()) {</span>
<span class="fc" id="L2608">      return;</span>
    }
<span class="fc" id="L2610">    int carrierCost = AirMovementValidator.carrierCost(m_defendingAir);</span>
<span class="fc" id="L2611">    final int carrierCapacity = AirMovementValidator.carrierCapacity(m_defendingUnits, m_battleSite);</span>
    // add dependant air to carrier cost
<span class="fc" id="L2613">    carrierCost +=</span>
<span class="fc" id="L2614">        AirMovementValidator.carrierCost(Match.getMatches(getDependentUnits(m_defendingUnits), alliedDefendingAir));</span>
    // all planes can land, exit
<span class="pc bpc" id="L2616" title="1 of 2 branches missed.">    if (carrierCapacity &gt;= carrierCost) {</span>
<span class="nc" id="L2617">      return;</span>
    }
    // find out what we must remove
    // remove all the air that can land on carriers from defendingAir
<span class="fc" id="L2621">    carrierCost = 0;</span>
    // add dependant air to carrier cost
<span class="fc" id="L2623">    carrierCost +=</span>
<span class="fc" id="L2624">        AirMovementValidator.carrierCost(Match.getMatches(getDependentUnits(m_defendingUnits), alliedDefendingAir));</span>
<span class="fc bfc" id="L2625" title="All 2 branches covered.">    for (final Unit currentUnit : new ArrayList&lt;&gt;(m_defendingAir)) {</span>
<span class="pc bpc" id="L2626" title="1 of 2 branches missed.">      if (!Matches.UnitCanLandOnCarrier.match(currentUnit)) {</span>
<span class="nc" id="L2627">        m_defendingAir.remove(currentUnit);</span>
<span class="nc" id="L2628">        continue;</span>
      }
<span class="fc" id="L2630">      carrierCost += UnitAttachment.get(currentUnit.getType()).getCarrierCost();</span>
<span class="pc bpc" id="L2631" title="1 of 2 branches missed.">      if (carrierCapacity &gt;= carrierCost) {</span>
<span class="nc" id="L2632">        m_defendingAir.remove(currentUnit);</span>
      }
    }
    // Moved this choosing to after all battles, as we legally should be able to land in a territory if we win there.
<span class="fc" id="L2636">    m_battleTracker.addToDefendingAirThatCanNotLand(m_defendingAir, m_battleSite);</span>
<span class="fc" id="L2637">  }</span>

  public static CompositeChange clearTransportedByForAlliedAirOnCarrier(final Collection&lt;Unit&gt; attackingUnits,
      final Territory battleSite, final PlayerID attacker, final GameData data) {
<span class="fc" id="L2641">    final CompositeChange change = new CompositeChange();</span>
    // Clear the transported_by for successfully won battles where there was an allied air unit held as cargo by an
    // carrier unit
<span class="fc" id="L2644">    final Collection&lt;Unit&gt; carriers = Match.getMatches(attackingUnits, Matches.UnitIsCarrier);</span>
<span class="pc bpc" id="L2645" title="3 of 4 branches missed.">    if (!carriers.isEmpty() &amp;&amp; !games.strategy.triplea.Properties.getAlliedAirIndependent(data)) {</span>
<span class="nc" id="L2646">      final Match&lt;Unit&gt; alliedFighters = new CompositeMatchAnd&lt;&gt;(Matches.isUnitAllied(attacker, data),</span>
<span class="nc" id="L2647">          Matches.unitIsOwnedBy(attacker).invert(), Matches.UnitIsAir, Matches.UnitCanLandOnCarrier);</span>
<span class="nc" id="L2648">      final Collection&lt;Unit&gt; alliedAirInTerr = Match.getMatches(battleSite.getUnits().getUnits(), alliedFighters);</span>
<span class="nc bnc" id="L2649" title="All 2 branches missed.">      for (final Unit fighter : alliedAirInTerr) {</span>
<span class="nc" id="L2650">        final TripleAUnit taUnit = (TripleAUnit) fighter;</span>
<span class="nc bnc" id="L2651" title="All 2 branches missed.">        if (taUnit.getTransportedBy() != null) {</span>
<span class="nc" id="L2652">          final Unit carrierTransportingThisUnit = taUnit.getTransportedBy();</span>
<span class="nc" id="L2653">          if (!Matches.UnitHasWhenCombatDamagedEffect(UnitAttachment.UNITSMAYNOTLEAVEALLIEDCARRIER)</span>
<span class="nc bnc" id="L2654" title="All 2 branches missed.">              .match(carrierTransportingThisUnit)) {</span>
<span class="nc" id="L2655">            change.add(ChangeFactory.unitPropertyChange(fighter, null, TripleAUnit.TRANSPORTED_BY));</span>
          }
        }
      }
    }
<span class="fc" id="L2660">    return change;</span>
  }

  private void showCasualties(final IDelegateBridge bridge) {
<span class="fc bfc" id="L2664" title="All 2 branches covered.">    if (m_killed.isEmpty()) {</span>
<span class="fc" id="L2665">      return;</span>
    }
    // a handy summary of all the units killed
<span class="fc" id="L2668">    IntegerMap&lt;UnitType&gt; costs = BattleCalculator.getCostsForTUV(m_attacker, m_data);</span>
<span class="fc" id="L2669">    final int tuvLostAttacker = BattleCalculator.getTUV(m_killed, m_attacker, costs, m_data);</span>
<span class="fc" id="L2670">    costs = BattleCalculator.getCostsForTUV(m_defender, m_data);</span>
<span class="fc" id="L2671">    final int tuvLostDefender = BattleCalculator.getTUV(m_killed, m_defender, costs, m_data);</span>
<span class="fc" id="L2672">    final int tuvChange = tuvLostDefender - tuvLostAttacker;</span>
<span class="fc" id="L2673">    bridge.getHistoryWriter().addChildToEvent(</span>
<span class="fc" id="L2674">        &quot;Battle casualty summary: Battle score (TUV change) for attacker is &quot; + tuvChange,</span>
<span class="fc" id="L2675">        new ArrayList&lt;&gt;(m_killed));</span>
<span class="fc" id="L2676">    m_attackerLostTUV += tuvLostAttacker;</span>
<span class="fc" id="L2677">    m_defenderLostTUV += tuvLostDefender;</span>
<span class="fc" id="L2678">  }</span>

  private void endBattle(final IDelegateBridge bridge) {
<span class="fc" id="L2681">    clearWaitingToDie(bridge);</span>
<span class="fc" id="L2682">    m_isOver = true;</span>
<span class="fc" id="L2683">    m_battleTracker.removeBattle(this);</span>
<span class="fc" id="L2684">    final CompositeChange clearAlliedAir =</span>
<span class="fc" id="L2685">        clearTransportedByForAlliedAirOnCarrier(m_attackingUnits, m_battleSite, m_attacker, m_data);</span>
<span class="pc bpc" id="L2686" title="1 of 2 branches missed.">    if (!clearAlliedAir.isEmpty()) {</span>
<span class="nc" id="L2687">      bridge.addChange(clearAlliedAir);</span>
    }
<span class="fc" id="L2689">  }</span>

  @Override
  public void cancelBattle(final IDelegateBridge bridge) {
<span class="fc" id="L2693">    endBattle(bridge);</span>
<span class="fc" id="L2694">  }</span>

  @Override
  public String toString() {
<span class="nc" id="L2698">    return &quot;Battle in:&quot; + m_battleSite + &quot; battle type:&quot; + m_battleType + &quot; defender:&quot; + m_defender.getName()</span>
<span class="nc" id="L2699">        + &quot; attacked by:&quot; + m_attacker.getName() + &quot; from:&quot; + m_attackingFrom + &quot; attacking with: &quot; + m_attackingUnits;</span>
  }

  // In an amphibious assault, sort on who is unloading from xports first
  // This will allow the marines with higher scores to get killed last
  public void sortAmphib(final List&lt;Unit&gt; units, final GameData data) {
<span class="fc" id="L2705">    final Comparator&lt;Unit&gt; decreasingMovement = UnitComparator.getLowestToHighestMovementComparator();</span>
<span class="fc" id="L2706">    final Comparator&lt;Unit&gt; comparator = (u1, u2) -&gt; {</span>
<span class="fc" id="L2707">      int amphibComp = 0;</span>
<span class="fc bfc" id="L2708" title="All 2 branches covered.">      if (u1.getUnitType().equals(u2.getUnitType())) {</span>
<span class="fc" id="L2709">        final UnitAttachment ua = UnitAttachment.get(u1.getType());</span>
<span class="fc" id="L2710">        final UnitAttachment ua2 = UnitAttachment.get(u2.getType());</span>
<span class="pc bpc" id="L2711" title="3 of 4 branches missed.">        if (ua.getIsMarine() != 0 &amp;&amp; ua2.getIsMarine() != 0) {</span>
<span class="nc" id="L2712">          amphibComp = compareAccordingToAmphibious(u1, u2);</span>
        }
<span class="pc bpc" id="L2714" title="1 of 2 branches missed.">        if (amphibComp == 0) {</span>
<span class="fc" id="L2715">          return decreasingMovement.compare(u1, u2);</span>
        }
<span class="nc" id="L2717">        return amphibComp;</span>
      }
<span class="fc" id="L2719">      return u1.getUnitType().getName().compareTo(u2.getUnitType().getName());</span>
    };
<span class="fc" id="L2721">    Collections.sort(units, comparator);</span>
<span class="fc" id="L2722">  }</span>

  private int compareAccordingToAmphibious(final Unit u1, final Unit u2) {
<span class="nc bnc" id="L2725" title="All 4 branches missed.">    if (m_amphibiousLandAttackers.contains(u1) &amp;&amp; !m_amphibiousLandAttackers.contains(u2)) {</span>
<span class="nc" id="L2726">      return -1;</span>
<span class="nc bnc" id="L2727" title="All 4 branches missed.">    } else if (m_amphibiousLandAttackers.contains(u2) &amp;&amp; !m_amphibiousLandAttackers.contains(u1)) {</span>
<span class="nc" id="L2728">      return 1;</span>
    }
<span class="nc" id="L2730">    final int m1 = UnitAttachment.get(u1.getType()).getIsMarine();</span>
<span class="nc" id="L2731">    final int m2 = UnitAttachment.get(u2.getType()).getIsMarine();</span>
<span class="nc" id="L2732">    return m2 - m1;</span>
  }

  public Collection&lt;Territory&gt; getAttackingFrom() {
<span class="fc" id="L2736">    return m_attackingFrom;</span>
  }

  public Map&lt;Territory, Collection&lt;Unit&gt;&gt; getAttackingFromMap() {
<span class="fc" id="L2740">    return m_attackingFromMap;</span>
  }

  // used for setting stuff when we make a scrambling battle when there was no previous battle there, and we need
  // retreat spaces
  public void setAttackingFromAndMap(final Map&lt;Territory, Collection&lt;Unit&gt;&gt; attackingFromMap) {
<span class="nc" id="L2746">    m_attackingFromMap = attackingFromMap;</span>
<span class="nc" id="L2747">    m_attackingFrom = new HashSet&lt;&gt;(attackingFromMap.keySet());</span>
<span class="nc" id="L2748">  }</span>

  @Override
  public void unitsLostInPrecedingBattle(final IBattle battle, final Collection&lt;Unit&gt; units,
      final IDelegateBridge bridge, final boolean withdrawn) {
<span class="fc" id="L2753">    Collection&lt;Unit&gt; lost = getDependentUnits(units);</span>
<span class="fc" id="L2754">    lost.addAll(Util.intersection(units, m_attackingUnits));</span>
    // if all the amphibious attacking land units are lost, then we are
    // no longer a naval invasion
<span class="fc" id="L2757">    m_amphibiousLandAttackers.removeAll(lost);</span>
<span class="fc bfc" id="L2758" title="All 2 branches covered.">    if (m_amphibiousLandAttackers.isEmpty()) {</span>
<span class="fc" id="L2759">      m_isAmphibious = false;</span>
<span class="fc" id="L2760">      m_bombardingUnits.clear();</span>
    }
<span class="fc" id="L2762">    m_attackingUnits.removeAll(lost);</span>
    // now that they are definitely removed from our attacking list, make sure that they were not already removed from
    // the territory by the
    // previous battle's remove method
<span class="fc" id="L2766">    lost = Match.getMatches(lost, Matches.unitIsInTerritory(m_battleSite));</span>
<span class="pc bpc" id="L2767" title="1 of 2 branches missed.">    if (!withdrawn) {</span>
<span class="fc" id="L2768">      remove(lost, bridge, m_battleSite, false, false);</span>
    }
<span class="fc bfc" id="L2770" title="All 2 branches covered.">    if (m_attackingUnits.isEmpty()) {</span>
<span class="fc" id="L2771">      final IntegerMap&lt;UnitType&gt; costs = BattleCalculator.getCostsForTUV(m_attacker, m_data);</span>
<span class="pc bpc" id="L2772" title="1 of 2 branches missed.">      final int tuvLostAttacker = (withdrawn ? 0 : BattleCalculator.getTUV(lost, m_attacker, costs, m_data));</span>
<span class="fc" id="L2773">      m_attackerLostTUV += tuvLostAttacker;</span>
<span class="fc" id="L2774">      m_whoWon = WhoWon.DEFENDER;</span>
<span class="pc bpc" id="L2775" title="1 of 2 branches missed.">      if (!m_headless) {</span>
<span class="fc" id="L2776">        m_battleTracker.getBattleRecords().addResultToBattle(m_attacker, m_battleID, m_defender,</span>
<span class="fc" id="L2777">            m_attackerLostTUV, m_defenderLostTUV, BattleRecord.BattleResultDescription.LOST,</span>
<span class="fc" id="L2778">            new BattleResults(this, m_data));</span>
      }
<span class="fc" id="L2780">      m_battleTracker.removeBattle(this);</span>
    }
<span class="fc" id="L2782">  }</span>

  /**
   * Returns a map of transport -&gt; collection of transported units.
   */
  private Map&lt;Unit, Collection&lt;Unit&gt;&gt; transporting(final Collection&lt;Unit&gt; units) {
<span class="fc" id="L2788">    return TransportTracker.transporting(units);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>test (25/nov/2016 10:16:58)</div></body></html>