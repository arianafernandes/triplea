<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>AirMovementValidator.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">test (25/nov/2016 10:16:58)</a> &gt; <a href="../../index.html" class="el_group">triplea</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">games.strategy.triplea.delegate</a> &gt; <span class="el_source">AirMovementValidator.java</span></div><h1>AirMovementValidator.java</h1><pre class="source lang-java linenums"><span class="fc" id="L1">package games.strategy.triplea.delegate;</span>

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import games.strategy.engine.data.GameData;
import games.strategy.engine.data.GameMap;
import games.strategy.engine.data.PlayerID;
import games.strategy.engine.data.Route;
import games.strategy.engine.data.Territory;
import games.strategy.engine.data.Unit;
import games.strategy.triplea.Constants;
import games.strategy.triplea.TripleAUnit;
import games.strategy.triplea.attachments.UnitAttachment;
import games.strategy.triplea.delegate.dataObjects.MoveValidationResult;
import games.strategy.util.CompositeMatchAnd;
import games.strategy.util.IntegerMap;
import games.strategy.util.Match;

/**
 * Provides static methods for evaluating movement of air units.
 */
<span class="nc" id="L33">public class AirMovementValidator {</span>
  public static final String NOT_ALL_AIR_UNITS_CAN_LAND = &quot;Not all air units can land&quot;;

  // TODO: this class does a pretty good job already, but could be improved by having the carriers that are potentially
  // moved also look for
  // any owned air units that are in sea zones without carriers. these would be air units that have already been moved
  // this turn, and
  // therefore would need pickup.
  public static MoveValidationResult validateAirCanLand(final GameData data, final Collection&lt;Unit&gt; units,
      final Route route, final PlayerID player, final MoveValidationResult result) {
    // First check if we even need to check
<span class="pc bpc" id="L44" title="1 of 2 branches missed.">    if (getEditMode(data) || // Edit Mode, no need to check</span>
<span class="fc bfc" id="L45" title="All 2 branches covered.">        !Match.someMatch(units, Matches.UnitIsAir) || // No Airunits, nothing to check</span>
<span class="pc bpc" id="L46" title="1 of 2 branches missed.">        route.hasNoSteps() || // if there are no steps, we didn't move, so it is always OK!</span>
<span class="fc bfc" id="L47" title="All 2 branches covered.">        Matches.airCanLandOnThisAlliedNonConqueredLandTerritory(player, data).match(route.getEnd()) || // we can land at</span>
                                                                                                       // the end,
                                                                                                       // nothing
                                                                                                       // left to check
<span class="pc bpc" id="L51" title="1 of 2 branches missed.">        isKamikazeAircraft(data) // we do not do any validation at all, cus they can all die and we don't care</span>
    ) {
<span class="fc" id="L53">      return result;</span>
    }
    // Find which aircraft cannot find friendly land to land on
<span class="fc" id="L56">    final Collection&lt;Unit&gt; ownedAirThatMustLandOnCarriers =</span>
<span class="fc" id="L57">        getAirThatMustLandOnCarriers(data, getAirUnitsToValidate(units, route, player), route, result, player);</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">    if (ownedAirThatMustLandOnCarriers.isEmpty()) {</span>
      // we are done, everything can find a place to land
<span class="fc" id="L60">      return result;</span>
    }
<span class="fc" id="L62">    final Territory routeEnd = route.getEnd();</span>
<span class="fc" id="L63">    final Territory routeStart = route.getStart();</span>
    // we cannot forget to account for allied air at our location already
<span class="fc" id="L65">    final Match&lt;Unit&gt; airAlliedNotOwned = new CompositeMatchAnd&lt;&gt;(Matches.unitIsOwnedBy(player).invert(),</span>
<span class="fc" id="L66">        Matches.isUnitAllied(player, data), Matches.UnitIsAir, Matches.UnitCanLandOnCarrier);</span>
<span class="fc" id="L67">    final HashSet&lt;Unit&gt; airThatMustLandOnCarriersHash = new HashSet&lt;&gt;();</span>
<span class="fc" id="L68">    airThatMustLandOnCarriersHash.addAll(Match.getMatches(routeEnd.getUnits().getUnits(), airAlliedNotOwned));</span>
<span class="fc" id="L69">    airThatMustLandOnCarriersHash.addAll(Match.getMatches(units, airAlliedNotOwned));</span>
    // now we must see if we also need to account for units (allied cargo) that are moving with our carriers, if we have
    // selected any
    // carriers
<span class="fc" id="L73">    final Collection&lt;Unit&gt; movingCarriersAtStartLocationBeingMoved = Match.getMatches(units, Matches.UnitIsCarrier);</span>
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">    if (!movingCarriersAtStartLocationBeingMoved.isEmpty()) {</span>
<span class="nc" id="L75">      final Map&lt;Unit, Collection&lt;Unit&gt;&gt; carrierToAlliedCargo =</span>
<span class="nc" id="L76">          MoveValidator.carrierMustMoveWith(units, routeStart, data, player);</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">      for (final Collection&lt;Unit&gt; alliedAirOnCarrier : carrierToAlliedCargo.values()) {</span>
<span class="nc" id="L78">        airThatMustLandOnCarriersHash.addAll(alliedAirOnCarrier);</span>
      }
    }
    // now we can add our owned air. we add our owned air last because it can be moved, while allied air cannot be. we
    // want the lowest
    // movement to be validated first.
<span class="fc" id="L84">    airThatMustLandOnCarriersHash.addAll(ownedAirThatMustLandOnCarriers);</span>
<span class="fc" id="L85">    final List&lt;Unit&gt; airThatMustLandOnCarriers = new ArrayList&lt;&gt;(airThatMustLandOnCarriersHash);</span>
    // sort the list by shortest range first so those birds will get first pick of landingspots
<span class="fc" id="L87">    Collections.sort(airThatMustLandOnCarriers, getLowestToHighestMovementComparatorIncludingUnitsNotYetMoved(route));</span>
    // now we should see if the carriers we are moving with, plus the carriers already there, can handle all our air
    // units (we check ending
    // territories first, separately, because it is special [it includes units in our selection])
<span class="fc" id="L91">    final Collection&lt;Unit&gt; carriersAtEnd = Match.getMatches(getFriendly(routeEnd, player, data), Matches.UnitIsCarrier);</span>
<span class="fc" id="L92">    carriersAtEnd.addAll(movingCarriersAtStartLocationBeingMoved);</span>
    // to keep track of all carriers, and their fighters, that have moved, so that we do not move them again.
<span class="fc" id="L94">    final Map&lt;Unit, Collection&lt;Unit&gt;&gt; movedCarriersAndTheirFighters = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">    for (final Unit carrier : carriersAtEnd) {</span>
<span class="fc" id="L96">      movedCarriersAndTheirFighters.put(carrier, new ArrayList&lt;&gt;());</span>
    }
<span class="fc" id="L98">    final Collection&lt;Unit&gt; airNotToConsiderBecauseWeAreValidatingThem = new ArrayList&lt;&gt;(airThatMustLandOnCarriers);</span>
<span class="fc" id="L99">    airThatMustLandOnCarriers</span>
<span class="fc" id="L100">        .removeAll(whatAirCanLandOnTheseCarriers(carriersAtEnd, airThatMustLandOnCarriers, routeEnd));</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">    if (airThatMustLandOnCarriers.isEmpty()) {</span>
<span class="fc" id="L102">      return result;</span>
    }
    // we still have air left, so begin calling carriers to come here to pick up the air

    // figure out what is the max distance of
    // our remaining air units
<span class="fc" id="L108">    final int maxMovementLeftForTheseAirUnitsBeingValidated =</span>
<span class="fc" id="L109">        maxMovementLeftForTheseAirUnitsBeingValidated(airThatMustLandOnCarriers, route, player);</span>
    // figure out what is the max distance
    // of our remaining carrier units
<span class="fc" id="L112">    final int maxMovementLeftForAllOwnedCarriers = maxMovementLeftForAllOwnedCarriers(player, data);</span>
<span class="fc" id="L113">    final List&lt;Territory&gt; landingSpots = new ArrayList&lt;&gt;(Collections.singleton(routeEnd));</span>
<span class="fc" id="L114">    landingSpots.addAll(data.getMap().getNeighbors(routeEnd, maxMovementLeftForTheseAirUnitsBeingValidated,</span>
        // where can we fly to?
<span class="fc" id="L116">        Matches.airCanFlyOver(player, data, areNeutralsPassableByAir(data))));</span>
    // we only want to consider
<span class="fc" id="L118">    landingSpots.removeAll(Match.getMatches(landingSpots, Matches.seaCanMoveOver(player, data).invert()));</span>
    // places we can move carriers to
<span class="fc" id="L120">    Collections.sort(landingSpots, getLowestToHighestDistance(routeEnd, Matches.seaCanMoveOver(player, data)));</span>
<span class="fc" id="L121">    final Collection&lt;Territory&gt; potentialCarrierOrigins = new LinkedHashSet&lt;&gt;(landingSpots);</span>
<span class="fc" id="L122">    potentialCarrierOrigins.addAll(data.getMap().getNeighbors(new HashSet&lt;&gt;(landingSpots),</span>
<span class="fc" id="L123">        maxMovementLeftForAllOwnedCarriers, Matches.seaCanMoveOver(player, data)));</span>
<span class="fc" id="L124">    potentialCarrierOrigins.remove(routeEnd);</span>
<span class="fc" id="L125">    potentialCarrierOrigins</span>
<span class="fc" id="L126">        .removeAll(Match.getMatches(potentialCarrierOrigins, Matches.TerritoryHasOwnedCarrier(player).invert()));</span>
    // now see if we can move carriers there to pick up
<span class="fc" id="L128">    validateAirCaughtByMovingCarriersAndOwnedAndAlliedAir(result, landingSpots, potentialCarrierOrigins,</span>
<span class="fc" id="L129">        movedCarriersAndTheirFighters, airThatMustLandOnCarriers, airNotToConsiderBecauseWeAreValidatingThem, player,</span>
<span class="fc" id="L130">        route, data);</span>
<span class="fc" id="L131">    return result;</span>
  }

  private static LinkedHashMap&lt;Unit, Integer&gt; getMovementLeftForValidatingAir(final Collection&lt;Unit&gt; airBeingValidated,
      final PlayerID player, final Route route) {
<span class="fc" id="L136">    final LinkedHashMap&lt;Unit, Integer&gt; map = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">    for (final Unit unit : airBeingValidated) {</span>
      // unit must be in either start or end.
      int movementLeft;
<span class="fc bfc" id="L140" title="All 2 branches covered.">      if (Matches.unitIsOwnedBy(player).match(unit)) {</span>
<span class="fc" id="L141">        movementLeft = getMovementLeftForAirUnitNotMovedYet(unit, route);</span>
<span class="fc" id="L142">      } else {</span>
<span class="fc" id="L143">        movementLeft = 0;</span>
      }
<span class="fc" id="L145">      map.put(unit, movementLeft);</span>
    }
<span class="fc" id="L147">    return map;</span>
  }

  private static int getMovementLeftForAirUnitNotMovedYet(final Unit airBeingValidated, final Route route) {
<span class="fc bfc" id="L151" title="All 2 branches covered.">    if (route.getEnd().getUnits().getUnits().contains(airBeingValidated)) {</span>
      // they are not being moved, they are already at the end
<span class="fc" id="L153">      return ((TripleAUnit) airBeingValidated).getMovementLeft();</span>
    } else {
      // they are being moved (they are still at the start location)
<span class="fc" id="L156">      return route.getMovementLeft(airBeingValidated);</span>
    }
  }

  private static IntegerMap&lt;Territory&gt; populateStaticAlliedAndBuildingCarrierCapacity(
      final List&lt;Territory&gt; landingSpots, final Map&lt;Unit, Collection&lt;Unit&gt;&gt; movedCarriersAndTheirFighters,
      final PlayerID player, final GameData data) {
<span class="fc" id="L163">    final IntegerMap&lt;Territory&gt; startingSpace = new IntegerMap&lt;&gt;();</span>
<span class="fc" id="L164">    final Match&lt;Unit&gt; carrierAlliedNotOwned = new CompositeMatchAnd&lt;&gt;(Matches.unitIsOwnedBy(player).invert(),</span>
<span class="fc" id="L165">        Matches.isUnitAllied(player, data), Matches.UnitIsCarrier);</span>
    // final Match&lt;Unit&gt; airAlliedNotOwned = new CompositeMatchAnd&lt;Unit&gt;(Matches.unitIsOwnedBy(player).invert(),
    // Matches.isUnitAllied(player, data), Matches.UnitIsAir, Matches.UnitCanLandOnCarrier);
<span class="fc bfc" id="L168" title="All 2 branches covered.">    final boolean landAirOnNewCarriers = AirThatCantLandUtil.isLHTRCarrierProduction(data)</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">        || AirThatCantLandUtil.isLandExistingFightersOnNewCarriers(data);</span>
    // final boolean areNeutralsPassableByAir = areNeutralsPassableByAir(data);
<span class="fc" id="L171">    final List&lt;Unit&gt; carriersInProductionQueue = player.getUnits().getMatches(Matches.UnitIsCarrier);</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">    for (final Territory t : landingSpots) {</span>
<span class="fc bfc" id="L173" title="All 4 branches covered.">      if (landAirOnNewCarriers &amp;&amp; !carriersInProductionQueue.isEmpty()) {</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">        if (Matches.TerritoryIsWater.match(t)</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">            &amp;&amp; Matches.territoryHasOwnedAtBeginningOfTurnIsFactoryOrCanProduceUnitsNeighbor(data, player).match(t)) {</span>
          // TODO: Here we are assuming that this factory can produce all of the carriers. Actually it might not be able
          // to produce any
          // carriers (because of complex requires units coding) or because of unit damage or maximum production.
          // TODO: Here we are also assuming that the first territory we find that has an adjacent factory is the
          // closest one in terms of
          // unit movement. We have sorted the list of territories so this IS the closest in terms of steps, but each
          // unit may have specific
          // movement allowances for different terrain or some bullshit like that.
<span class="fc" id="L184">          final int producedCarrierCapacity = carrierCapacity(carriersInProductionQueue, t);</span>
<span class="fc" id="L185">          startingSpace.add(t, producedCarrierCapacity);</span>
<span class="fc" id="L186">          carriersInProductionQueue.clear();</span>
        }
      }
<span class="fc" id="L189">      final Collection&lt;Unit&gt; alliedCarriers = t.getUnits().getMatches(carrierAlliedNotOwned);</span>
<span class="fc" id="L190">      alliedCarriers.removeAll(movedCarriersAndTheirFighters.keySet());</span>
      // Collection&lt;Unit&gt; alliedAir = t.getUnits().getMatches(airAlliedNotOwned);
<span class="fc" id="L192">      final int alliedCarrierCapacity = carrierCapacity(alliedCarriers, t);</span>
<span class="fc" id="L193">      startingSpace.add(t, alliedCarrierCapacity);</span>
    }
<span class="fc" id="L195">    return startingSpace;</span>
  }

  private static void validateAirCaughtByMovingCarriersAndOwnedAndAlliedAir(final MoveValidationResult result,
      final List&lt;Territory&gt; landingSpots, final Collection&lt;Territory&gt; potentialCarrierOrigins,
      final Map&lt;Unit, Collection&lt;Unit&gt;&gt; movedCarriersAndTheirFighters, final Collection&lt;Unit&gt; airThatMustLandOnCarriers,
      final Collection&lt;Unit&gt; airNotToConsider, final PlayerID player, final Route route, final GameData data) {
<span class="fc" id="L202">    final Match&lt;Unit&gt; ownedCarrierMatch =</span>
<span class="fc" id="L203">        new CompositeMatchAnd&lt;&gt;(Matches.unitIsOwnedBy(player), Matches.UnitIsCarrier);</span>
<span class="fc" id="L204">    final Match&lt;Unit&gt; ownedAirMatch =</span>
<span class="fc" id="L205">        new CompositeMatchAnd&lt;&gt;(Matches.unitIsOwnedBy(player), Matches.UnitIsAir, Matches.UnitCanLandOnCarrier);</span>
<span class="fc" id="L206">    final Match&lt;Unit&gt; alliedNotOwnedAirMatch = new CompositeMatchAnd&lt;&gt;(Matches.unitIsOwnedBy(player).invert(),</span>
<span class="fc" id="L207">        Matches.isUnitAllied(player, data), Matches.UnitIsAir, Matches.UnitCanLandOnCarrier);</span>
<span class="fc" id="L208">    final Match&lt;Unit&gt; alliedNotOwnedCarrierMatch = new CompositeMatchAnd&lt;&gt;(Matches.unitIsOwnedBy(player).invert(),</span>
<span class="fc" id="L209">        Matches.isUnitAllied(player, data), Matches.UnitIsCarrier);</span>
<span class="fc" id="L210">    final Territory routeEnd = route.getEnd();</span>
<span class="fc" id="L211">    final boolean areNeutralsPassableByAir = areNeutralsPassableByAir(data);</span>
<span class="fc" id="L212">    final IntegerMap&lt;Territory&gt; landingSpotsWithCarrierCapacity =</span>
        // fill our landing spot capacity with capacity from allied carriers and potential building of new carriers
<span class="fc" id="L214">        populateStaticAlliedAndBuildingCarrierCapacity(landingSpots, movedCarriersAndTheirFighters, player, data);</span>
<span class="fc" id="L215">    final LinkedHashMap&lt;Unit, Integer&gt; movementLeftForAirToValidate =</span>
        // calculate movement left only once
<span class="fc" id="L217">        getMovementLeftForValidatingAir(airThatMustLandOnCarriers, player, route);</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">    for (final Territory landingSpot : landingSpots) {</span>
      // since we are here, no point looking at this place twice
<span class="fc" id="L220">      potentialCarrierOrigins.remove(landingSpot);</span>
<span class="fc" id="L221">      final List&lt;Unit&gt; airCanReach = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">      for (final Unit air : airThatMustLandOnCarriers) {</span>
<span class="fc" id="L223">        if (canAirReachThisSpot(data, player, air, routeEnd, movementLeftForAirToValidate.get(air), landingSpot,</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">            areNeutralsPassableByAir)) {</span>
          // get all air that can reach this spot
<span class="fc" id="L226">          airCanReach.add(air);</span>
        }
      }
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">      if (airCanReach.isEmpty()) {</span>
<span class="nc" id="L230">        continue;</span>
      }
<span class="fc" id="L232">      final Collection&lt;Unit&gt; unitsInLandingSpot = landingSpot.getUnits().getUnits();</span>
<span class="fc" id="L233">      unitsInLandingSpot.removeAll(movedCarriersAndTheirFighters.keySet());</span>
      // make sure to remove any units we have already moved, or units that are excluded
<span class="fc" id="L235">      unitsInLandingSpot.removeAll(airNotToConsider);</span>
      // because they are in our mouse selection
<span class="fc bfc" id="L237" title="All 2 branches covered.">      for (final Collection&lt;Unit&gt; ftrs : movedCarriersAndTheirFighters.values()) {</span>
        // also remove any fighters that are being moved with carriers that we have already moved
<span class="fc" id="L239">        unitsInLandingSpot.removeAll(ftrs);</span>
      }
<span class="fc" id="L241">      final Collection&lt;Unit&gt; ownedCarriersInLandingSpot = Match.getMatches(unitsInLandingSpot, ownedCarrierMatch);</span>
      // get air we own here, but exclude any air that can fly to allied land
<span class="fc" id="L243">      final Collection&lt;Unit&gt; airInLandingSpot = Match.getMatches(Match.getMatches(unitsInLandingSpot, ownedAirMatch),</span>
<span class="fc" id="L244">          UnitCanFindLand(data, landingSpot).invert());</span>
      // add allied air (it can't fly away)
<span class="fc" id="L246">      airInLandingSpot.addAll(Match.getMatches(unitsInLandingSpot, alliedNotOwnedAirMatch));</span>
      // make sure we don't count this again
      // airNotToConsider.addAll(airInLandingSpot);
      // get the current capacity
<span class="fc" id="L250">      int landingSpotCapacity = landingSpotsWithCarrierCapacity.getInt(landingSpot);</span>
      // add capacity of owned carriers
<span class="fc" id="L252">      landingSpotCapacity += carrierCapacity(ownedCarriersInLandingSpot, landingSpot);</span>
      // minus capacity of air in the territory
<span class="fc" id="L254">      landingSpotCapacity -= carrierCost(airInLandingSpot);</span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">      if (!airCanReach.isEmpty()) {</span>
<span class="fc" id="L256">        final Iterator&lt;Unit&gt; airIter = airCanReach.iterator();</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">        while (airIter.hasNext()) {</span>
<span class="fc" id="L258">          final Unit air = airIter.next();</span>
<span class="fc" id="L259">          final int carrierCost = carrierCost(air);</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">          if (landingSpotCapacity &gt;= carrierCost) {</span>
<span class="fc" id="L261">            landingSpotCapacity -= carrierCost;</span>
            // we can land this one here, yay
<span class="fc" id="L263">            airThatMustLandOnCarriers.remove(air);</span>
<span class="fc" id="L264">            airIter.remove();</span>
          }
        }
      }
<span class="fc bfc" id="L268" title="All 2 branches covered.">      if (airThatMustLandOnCarriers.isEmpty()) {</span>
        // all can land here, so return
<span class="fc" id="L270">        return;</span>
      }
      // final int lowestCarrierCost = getLowestCarrierCost(airCanReach);
      // now bring carriers here...
<span class="fc" id="L274">      final Iterator&lt;Territory&gt; iter = potentialCarrierOrigins.iterator();</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">      while (iter.hasNext()) {</span>
<span class="fc" id="L276">        final Territory carrierSpot = iter.next();</span>
<span class="fc" id="L277">        final Collection&lt;Unit&gt; unitsInCarrierSpot = carrierSpot.getUnits().getUnits();</span>
        // remove carriers we have already moved
<span class="fc" id="L279">        unitsInCarrierSpot.removeAll(movedCarriersAndTheirFighters.keySet());</span>
        // remove units we do not want to consider because they are in our mouse selection
<span class="fc" id="L281">        unitsInCarrierSpot.removeAll(airNotToConsider);</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">        for (final Collection&lt;Unit&gt; ftrs : movedCarriersAndTheirFighters.values()) {</span>
          // remove the fighters that are moving with the carriers we have already moved
<span class="nc" id="L284">          unitsInCarrierSpot.removeAll(ftrs);</span>
        }
<span class="fc" id="L286">        final Collection&lt;Unit&gt; ownedCarriersInCarrierSpot = Match.getMatches(unitsInCarrierSpot, ownedCarrierMatch);</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">        if (ownedCarriersInCarrierSpot.isEmpty()) {</span>
<span class="nc" id="L288">          iter.remove();</span>
<span class="nc" id="L289">          continue;</span>
        }
<span class="fc" id="L291">        final Collection&lt;Unit&gt; ownedAirInCarrierSpot = Match.getMatches(</span>
            // exclude any owned air that can fly to land
<span class="fc" id="L293">            Match.getMatches(unitsInCarrierSpot, ownedAirMatch), UnitCanFindLand(data, carrierSpot).invert());</span>
<span class="fc" id="L294">        final Collection&lt;Unit&gt; alliedNotOwnedAirInCarrierSpot =</span>
<span class="fc" id="L295">            Match.getMatches(unitsInCarrierSpot, alliedNotOwnedAirMatch);</span>
<span class="fc" id="L296">        final Map&lt;Unit, Collection&lt;Unit&gt;&gt; mustMoveWithMap =</span>
            // this only returns the allied cargo
<span class="fc" id="L298">            MoveValidator.carrierMustMoveWith(ownedCarriersInCarrierSpot, carrierSpot, data, player);</span>
        // planes that MUST travel with the carrier
        // get the current capacity for the carrier spot
<span class="fc" id="L301">        int carrierSpotCapacity = landingSpotsWithCarrierCapacity.getInt(carrierSpot);</span>
        // we don't have it because this spot is not in the landing zone area.
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">        if (!landingSpotsWithCarrierCapacity.containsKey(carrierSpot)) {</span>
          // we still have a capacity for allied carriers, but only to carry other allied or local owned units, not to
          // carry our selected
          // units.
<span class="nc" id="L307">          carrierSpotCapacity =</span>
<span class="nc" id="L308">              carrierCapacity(carrierSpot.getUnits().getMatches(alliedNotOwnedCarrierMatch), carrierSpot);</span>
<span class="nc" id="L309">          landingSpotsWithCarrierCapacity.put(carrierSpot, carrierSpotCapacity);</span>
        }
        // we have allied air here, so we need to account for them before moving any carriers
<span class="pc bpc" id="L312" title="2 of 4 branches missed.">        if (!alliedNotOwnedAirInCarrierSpot.isEmpty() || !mustMoveWithMap.isEmpty()) {</span>
          // mustMoveWithMap is only filled if we have so many allied air that our owned carriers are carrying some of
          // them
<span class="nc bnc" id="L315" title="All 2 branches missed.">          if (mustMoveWithMap.isEmpty()) {</span>
            // allied carriers can carry enough
<span class="nc" id="L317">            carrierSpotCapacity -= carrierCost(alliedNotOwnedAirInCarrierSpot);</span>
            // we do not want to consider these units again
<span class="nc" id="L319">            airNotToConsider.addAll(alliedNotOwnedAirInCarrierSpot);</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">            if (carrierSpotCapacity &gt; 0) {</span>
              // we can hold some of the owned air here too
<span class="nc" id="L322">              final Iterator&lt;Unit&gt; ownedIter = ownedAirInCarrierSpot.iterator();</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">              while (ownedIter.hasNext()) {</span>
<span class="nc" id="L324">                final Unit air = ownedIter.next();</span>
<span class="nc" id="L325">                final int carrierCost = carrierCost(air);</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">                if (carrierSpotCapacity &gt;= carrierCost) {</span>
<span class="nc" id="L327">                  carrierSpotCapacity -= carrierCost;</span>
                  // we do not want to consider this one again
<span class="nc" id="L329">                  airNotToConsider.add(air);</span>
<span class="nc" id="L330">                  ownedIter.remove();</span>
                }
              }
            }
            // put correct value for future reference now that we
            // have considered the allied air
<span class="nc" id="L336">            landingSpotsWithCarrierCapacity.put(carrierSpot, carrierSpotCapacity);</span>
<span class="nc" id="L337">          } else {</span>
            // carrierMustMoveWith does not account for any allied cargo already moved out.
<span class="nc bnc" id="L339" title="All 2 branches missed.">            for (final Collection&lt;Unit&gt; airMovingWith : mustMoveWithMap.values()) {</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">              for (final Collection&lt;Unit&gt; ftrs : movedCarriersAndTheirFighters.values()) {</span>
                // remove the fighters that are moving with the carriers we have already moved
<span class="nc" id="L342">                airMovingWith.removeAll(ftrs);</span>
              }
            }
<span class="nc bnc" id="L345" title="All 2 branches missed.">            for (final Collection&lt;Unit&gt; airMovingWith : mustMoveWithMap.values()) {</span>
              // we will consider these as part of their moving carrier
<span class="nc" id="L347">              alliedNotOwnedAirInCarrierSpot.removeAll(airMovingWith);</span>
            }
<span class="nc" id="L349">            carrierSpotCapacity -= carrierCost(alliedNotOwnedAirInCarrierSpot);</span>
            // we do not want to consider these units again
<span class="nc" id="L351">            airNotToConsider.addAll(alliedNotOwnedAirInCarrierSpot);</span>
            // put correct value for future reference now that we
            // have considered the allied air
<span class="nc" id="L354">            landingSpotsWithCarrierCapacity.put(carrierSpot, carrierSpotCapacity);</span>
          }
        }
<span class="fc" id="L357">        final Route toLandingSpot =</span>
<span class="fc" id="L358">            data.getMap().getRoute(carrierSpot, landingSpot, Matches.seaCanMoveOver(player, data));</span>
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">        if (toLandingSpot == null) {</span>
<span class="nc" id="L360">          continue;</span>
        }
<span class="fc" id="L362">        final List&lt;Unit&gt; carrierCanReach =</span>
<span class="fc" id="L363">            Match.getMatches(ownedCarriersInCarrierSpot, Matches.UnitHasEnoughMovementForRoute(toLandingSpot));</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">        if (carrierCanReach.isEmpty()) {</span>
          // none can reach
<span class="nc" id="L366">          continue;</span>
        }
<span class="fc" id="L368">        final List&lt;Unit&gt; carrierNotReach = new ArrayList&lt;&gt;(ownedCarriersInCarrierSpot);</span>
        // we want to see if the air units can be put on the carriers that cannot make it
        // first, before taking up room on the carriers that can make it
<span class="fc" id="L371">        carrierNotReach.removeAll(carrierCanReach);</span>
<span class="fc" id="L372">        final List&lt;Unit&gt; allCarriers = new ArrayList&lt;&gt;(carrierNotReach);</span>
        // so we remove them from the list then re-add them so that they will be at the end of the list
<span class="fc" id="L374">        allCarriers.addAll(carrierCanReach);</span>
        // now we want to make a map of the carriers to the units they must carry with them (both allied and owned)
<span class="fc" id="L376">        final Map&lt;Unit, Collection&lt;Unit&gt;&gt; carriersToMove = new HashMap&lt;&gt;();</span>
<span class="fc" id="L377">        final List&lt;Unit&gt; carrierFull = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">        for (final Unit carrier : allCarriers) {</span>
<span class="fc" id="L379">          final Collection&lt;Unit&gt; airMovingWith = new ArrayList&lt;&gt;();</span>
          // first add allied cargo
<span class="fc" id="L381">          final Collection&lt;Unit&gt; alliedMovingWith = mustMoveWithMap.get(carrier);</span>
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">          if (alliedMovingWith != null) {</span>
<span class="nc" id="L383">            airMovingWith.addAll(alliedMovingWith);</span>
          }
          // now test if our carrier has any room for owned fighters
<span class="fc" id="L386">          int carrierCapacity = carrierCapacity(carrier, carrierSpot);</span>
<span class="fc" id="L387">          carrierCapacity -= carrierCost(airMovingWith);</span>
<span class="fc" id="L388">          final Iterator&lt;Unit&gt; ownedIter = ownedAirInCarrierSpot.iterator();</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">          while (ownedIter.hasNext()) {</span>
<span class="nc" id="L390">            final Unit air = ownedIter.next();</span>
<span class="nc" id="L391">            final int carrierCost = carrierCost(air);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">            if (carrierCapacity &gt;= carrierCost) {</span>
<span class="nc" id="L393">              carrierCapacity -= carrierCost;</span>
<span class="nc" id="L394">              airMovingWith.add(air);</span>
<span class="nc" id="L395">              ownedIter.remove();</span>
            }
          }
<span class="fc" id="L398">          carriersToMove.put(carrier, airMovingWith);</span>
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">          if (carrierCapacity &lt;= 0) {</span>
<span class="nc" id="L400">            carrierFull.add(carrier);</span>
          }
        }
        // if all carriers full, remove this carrier spot from consideration
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">        if (carrierFull.containsAll(allCarriers)) {</span>
<span class="nc" id="L405">          iter.remove();</span>
<span class="nc" id="L406">          continue;</span>
        }
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">        if (carrierFull.containsAll(carrierNotReach)) {</span>
<span class="fc" id="L409">          iter.remove();</span>
        }
        // ok, now lets move them.
<span class="fc bfc" id="L412" title="All 2 branches covered.">        for (final Unit carrier : carrierCanReach) {</span>
<span class="fc" id="L413">          movedCarriersAndTheirFighters.put(carrier, carriersToMove.get(carrier));</span>
<span class="fc" id="L414">          landingSpotCapacity += carrierCapacity(carrier, carrierSpot);</span>
<span class="fc" id="L415">          landingSpotCapacity -= carrierCost(carriersToMove.get(carrier));</span>
        }
        // optional for debugging
        // landingSpotsWithCarrierCapacity.put(landingSpot, landingSpotCapacity);
<span class="fc" id="L419">        final Iterator&lt;Unit&gt; reachIter = airCanReach.iterator();</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">        while (reachIter.hasNext()) {</span>
<span class="fc" id="L421">          final Unit air = reachIter.next();</span>
<span class="fc" id="L422">          final int carrierCost = carrierCost(air);</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">          if (landingSpotCapacity &gt;= carrierCost) {</span>
<span class="fc" id="L424">            landingSpotCapacity -= carrierCost;</span>
            // we can land this one here, yay
<span class="fc" id="L426">            airThatMustLandOnCarriers.remove(air);</span>
<span class="fc" id="L427">            reachIter.remove();</span>
          }
        }
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">        if (airThatMustLandOnCarriers.isEmpty()) {</span>
          // all can land here, so return
<span class="fc" id="L432">          return;</span>
        }
      }
    }
    // anyone left over cannot land
<span class="fc bfc" id="L437" title="All 2 branches covered.">    for (final Unit air : airThatMustLandOnCarriers) {</span>
<span class="fc" id="L438">      result.addDisallowedUnit(NOT_ALL_AIR_UNITS_CAN_LAND, air);</span>
    }
<span class="fc" id="L440">  }</span>

  private static Comparator&lt;Territory&gt; getLowestToHighestDistance(final Territory territoryWeMeasureDistanceFrom,
      final Match&lt;Territory&gt; condition) {
<span class="fc" id="L444">    return (t1, t2) -&gt; {</span>
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">      if (t1.equals(t2)) {</span>
<span class="nc" id="L446">        return 0;</span>
      }
<span class="fc" id="L448">      final GameMap map = t1.getData().getMap();</span>
<span class="fc" id="L449">      final int distance1 = map.getDistance(territoryWeMeasureDistanceFrom, t1, condition);</span>
<span class="fc" id="L450">      final int distance2 = map.getDistance(territoryWeMeasureDistanceFrom, t2, condition);</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">      if (distance1 == distance2) {</span>
<span class="fc" id="L452">        return 0;</span>
      }
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">      if (distance1 &lt; 0) {</span>
<span class="nc" id="L455">        return 1;</span>
      }
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">      if (distance2 &lt; 0) {</span>
<span class="nc" id="L458">        return -1;</span>
      }
<span class="fc bfc" id="L460" title="All 2 branches covered.">      if (distance1 &lt; distance2) {</span>
<span class="fc" id="L461">        return -1;</span>
      }
<span class="fc" id="L463">      return 1;</span>
    };
  }

  private static int maxMovementLeftForAllOwnedCarriers(final PlayerID player, final GameData data) {
<span class="fc" id="L468">    int max = 0;</span>
<span class="fc" id="L469">    final Match&lt;Unit&gt; ownedCarrier = new CompositeMatchAnd&lt;&gt;(Matches.UnitIsCarrier, Matches.unitIsOwnedBy(player));</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">    for (final Territory t : data.getMap().getTerritories()) {</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">      for (final Unit carrier : t.getUnits().getMatches(ownedCarrier)) {</span>
<span class="fc" id="L472">        max = Math.max(max, ((TripleAUnit) carrier).getMovementLeft());</span>
      }
    }
<span class="fc" id="L475">    return max;</span>
  }

  private static int maxMovementLeftForTheseAirUnitsBeingValidated(final Collection&lt;Unit&gt; airUnits, final Route route,
      final PlayerID player) {
<span class="fc" id="L480">    int max = 0;</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">    for (final Unit u : airUnits) {</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">      if (Matches.unitIsOwnedBy(player).match(u)) {</span>
        // unit must be in either start or end.
<span class="fc" id="L484">        final int movementLeft = getMovementLeftForAirUnitNotMovedYet(u, route);</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">        if (movementLeft &gt; max) {</span>
<span class="fc" id="L486">          max = movementLeft;</span>
        }
      }
      // allied units can't move....
    }
<span class="fc" id="L491">    return max;</span>
  }

  private static Collection&lt;Unit&gt; whatAirCanLandOnTheseCarriers(final Collection&lt;Unit&gt; carriers,
      final Collection&lt;Unit&gt; airUnits, final Territory territoryUnitsAreIn) {
<span class="fc" id="L496">    final Collection&lt;Unit&gt; airThatCanLandOnThem = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">    for (final Unit carrier : carriers) {</span>
<span class="fc" id="L498">      int carrierCapacity = carrierCapacity(carrier, territoryUnitsAreIn);</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">      for (final Unit air : airUnits) {</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">        if (airThatCanLandOnThem.contains(air)) {</span>
<span class="fc" id="L501">          continue;</span>
        }
<span class="fc" id="L503">        final int airCost = carrierCost(air);</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">        if (carrierCapacity &gt;= airCost) {</span>
<span class="fc" id="L505">          carrierCapacity -= airCost;</span>
<span class="fc" id="L506">          airThatCanLandOnThem.add(air);</span>
        }
      }
    }
<span class="fc" id="L510">    return airThatCanLandOnThem;</span>
  }

  /**
   * @param units
   *        the units flying this route
   * @param route
   *        the route flown
   * @param player
   *        the player owning the units
   * @return the combination of units that fly here and the existing owned units
   */
  private static List&lt;Unit&gt; getAirUnitsToValidate(final Collection&lt;Unit&gt; units, final Route route,
      final PlayerID player) {
<span class="fc" id="L524">    final Match&lt;Unit&gt; ownedAirMatch =</span>
<span class="fc" id="L525">        new CompositeMatchAnd&lt;&gt;(Matches.UnitIsAir, Matches.unitOwnedBy(player), Matches.UnitIsKamikaze.invert());</span>
<span class="fc" id="L526">    final List&lt;Unit&gt; ownedAir = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L527">    ownedAir.addAll(Match.getMatches(route.getEnd().getUnits().getUnits(), ownedAirMatch));</span>
<span class="fc" id="L528">    ownedAir.addAll(Match.getMatches(units, ownedAirMatch));</span>
    // sort the list by shortest range first so those birds will get first pick of landingspots
<span class="fc" id="L530">    Collections.sort(ownedAir, getLowestToHighestMovementComparatorIncludingUnitsNotYetMoved(route));</span>
<span class="fc" id="L531">    return ownedAir;</span>
  }

  private static Comparator&lt;Unit&gt; getLowestToHighestMovementComparatorIncludingUnitsNotYetMoved(final Route route) {
<span class="fc" id="L535">    return (u1, u2) -&gt; {</span>
<span class="fc" id="L536">      final int left1 = getMovementLeftForAirUnitNotMovedYet(u1, route);</span>
<span class="fc" id="L537">      final int left2 = getMovementLeftForAirUnitNotMovedYet(u2, route);</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">      if (left1 == left2) {</span>
<span class="fc" id="L539">        return 0;</span>
      }
<span class="fc bfc" id="L541" title="All 2 branches covered.">      if (left1 &gt; left2) {</span>
<span class="fc" id="L542">        return 1;</span>
      }
<span class="fc" id="L544">      return -1;</span>
    };
  }

  private static boolean canAirReachThisSpot(final GameData data, final PlayerID player, final Unit unit,
      final Territory currentSpot, final int movementLeft, final Territory landingSpot,
      final boolean areNeutralsPassableByAir) {
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">    if (areNeutralsPassableByAir) {</span>
<span class="nc" id="L552">      final Route neutralViolatingRoute = data.getMap().getRoute(currentSpot, landingSpot,</span>
<span class="nc" id="L553">          Matches.airCanFlyOver(player, data, areNeutralsPassableByAir));</span>
<span class="nc bnc" id="L554" title="All 6 branches missed.">      return (neutralViolatingRoute != null &amp;&amp; neutralViolatingRoute.getMovementCost(unit) &lt;= movementLeft</span>
<span class="nc" id="L555">          &amp;&amp; getNeutralCharge(data, neutralViolatingRoute) &lt;= player.getResources().getQuantity(Constants.PUS));</span>
    } else {
<span class="fc" id="L557">      final Route noNeutralRoute = data.getMap().getRoute(currentSpot, landingSpot,</span>
<span class="fc" id="L558">          Matches.airCanFlyOver(player, data, areNeutralsPassableByAir));</span>
<span class="pc bpc" id="L559" title="1 of 4 branches missed.">      return (noNeutralRoute != null &amp;&amp; noNeutralRoute.getMovementCost(unit) &lt;= movementLeft);</span>
    }
  }

  /**
   * Can this airunit reach safe land at this point in the route?
   *
   * @param data
   * @param unit
   *        the airunit in question
   * @param route
   *        the current spot from which he needs to reach safe land.
   * @return whether the air-unit can find a stretch of friendly land to land on given her current spot and the
   *         remaining range.
   */
  private static boolean canFindLand(final GameData data, final Unit unit, final Route route) {
<span class="fc" id="L575">    final Territory routeEnd = route.getEnd();</span>
    // unit must be in either start or end.
<span class="fc" id="L577">    final int movementLeft = getMovementLeftForAirUnitNotMovedYet(unit, route);</span>
<span class="fc" id="L578">    return canFindLand(data, unit, routeEnd, movementLeft);</span>
  }

  private static boolean canFindLand(final GameData data, final Unit unit, final Territory current) {
<span class="fc" id="L582">    final int movementLeft = ((TripleAUnit) unit).getMovementLeft();</span>
<span class="fc" id="L583">    return canFindLand(data, unit, current, movementLeft);</span>
  }

  private static boolean canFindLand(final GameData data, final Unit unit, final Territory current,
      final int movementLeft) {
<span class="fc bfc" id="L588" title="All 2 branches covered.">    if (movementLeft &lt;= 0) {</span>
<span class="fc" id="L589">      return false;</span>
    }
<span class="fc" id="L591">    final boolean areNeutralsPassableByAir = areNeutralsPassableByAir(data);</span>
<span class="fc" id="L592">    final PlayerID player = unit.getOwner();</span>
<span class="fc" id="L593">    final List&lt;Territory&gt; possibleSpots = Match.getMatches(data.getMap().getNeighbors(current, movementLeft),</span>
<span class="fc" id="L594">        Matches.airCanLandOnThisAlliedNonConqueredLandTerritory(player, data));</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">    for (final Territory landingSpot : possibleSpots) { // TODO EW: Assuming movement cost of 1, this could get VERY</span>
                                                        // slow when the
                                                        // movementcost is very high and airunits have a lot of
                                                        // movementcapacity.
<span class="fc bfc" id="L599" title="All 2 branches covered.">      if (canAirReachThisSpot(data, player, unit, current, movementLeft, landingSpot, areNeutralsPassableByAir)) {</span>
<span class="fc" id="L600">        return true;</span>
      }
    }
<span class="fc" id="L603">    return false;</span>
  }

  private static Match&lt;Unit&gt; UnitCanFindLand(final GameData data, final Territory current) {
<span class="fc" id="L607">    return new Match&lt;Unit&gt;() {</span>
      @Override
      public boolean match(final Unit u) {
<span class="fc" id="L610">        return canFindLand(data, u, current);</span>
      }
    };
  }

  /**
   * Returns true if the given air units can land in the given territory.
   * Does take into account whether a battle has been fought in the territory already.
   * Note units must only be air units
   */
  public static boolean canLand(final Collection&lt;Unit&gt; airUnits, final Territory territory, final PlayerID player,
      final GameData data) {
<span class="fc bfc" id="L622" title="All 2 branches covered.">    if (!Match.allMatch(airUnits, Matches.UnitIsAir)) {</span>
<span class="fc" id="L623">      throw new IllegalArgumentException(&quot;can only test if air will land&quot;);</span>
    }
<span class="fc bfc" id="L625" title="All 4 branches covered.">    if (!territory.isWater() &amp;&amp; AbstractMoveDelegate.getBattleTracker(data).wasConquered(territory)) {</span>
<span class="fc" id="L626">      return false;</span>
    }
<span class="fc bfc" id="L628" title="All 2 branches covered.">    if (territory.isWater()) {</span>
      // if they cant all land on carriers
<span class="fc bfc" id="L630" title="All 2 branches covered.">      if (!Match.allMatch(airUnits, Matches.UnitCanLandOnCarrier)) {</span>
<span class="fc" id="L631">        return false;</span>
      }
      // when doing the calculation, make sure to include the units
      // in the territory
<span class="fc" id="L635">      final Set&lt;Unit&gt; friendly = new HashSet&lt;&gt;();</span>
<span class="fc" id="L636">      friendly.addAll(getFriendly(territory, player, data));</span>
<span class="fc" id="L637">      friendly.addAll(airUnits);</span>
      // make sure we have the carrier capacity
<span class="fc" id="L639">      final int capacity = carrierCapacity(friendly, territory);</span>
<span class="fc" id="L640">      final int cost = carrierCost(friendly);</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">      return capacity &gt;= cost;</span>
    } else {
<span class="fc" id="L643">      return data.getRelationshipTracker().canLandAirUnitsOnOwnedLand(player, territory.getOwner());</span>
    }
  }

  private static Collection&lt;Unit&gt; getAirThatMustLandOnCarriers(final GameData data, final Collection&lt;Unit&gt; ownedAir,
      final Route route, final MoveValidationResult result, final PlayerID player) {
<span class="fc" id="L649">    final Collection&lt;Unit&gt; airThatMustLandOnCarriers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L650">    final Match&lt;Unit&gt; canLandOnCarriers = Matches.UnitCanLandOnCarrier;</span>
<span class="fc bfc" id="L651" title="All 2 branches covered.">    for (final Unit unit : ownedAir) {</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">      if (!canFindLand(data, unit, route)) {</span>
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">        if (canLandOnCarriers.match(unit)) {</span>
<span class="fc" id="L654">          airThatMustLandOnCarriers.add(unit);</span>
<span class="fc" id="L655">        } else {</span>
          // not everything can land on a carrier (i.e. bombers)
<span class="nc" id="L657">          result.addDisallowedUnit(NOT_ALL_AIR_UNITS_CAN_LAND, unit);</span>
        }
      }
    }
<span class="fc" id="L661">    return airThatMustLandOnCarriers;</span>
  }

  /**
   * Does not, and is not supposed to, account for any units already on this carrier (like allied/cargo fighters).
   * Instead this method only adds up the total capacity of each unit, and accounts for damaged carriers with special
   * properties and
   * restrictions.
   *
   * @param units
   * @param territory
   */
  public static int carrierCapacity(final Collection&lt;Unit&gt; units, final Territory territoryUnitsAreCurrentlyIn) {
<span class="fc" id="L674">    int sum = 0;</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">    for (final Unit unit : units) {</span>
<span class="fc" id="L676">      sum += carrierCapacity(unit, territoryUnitsAreCurrentlyIn);</span>
    }
<span class="fc" id="L678">    return sum;</span>
  }

  /**
   * Does not, and is not supposed to, account for any units already on this carrier (like allied/cargo fighters).
   * Instead this method only adds up the total capacity of each unit, and accounts for damaged carriers with special
   * properties and
   * restrictions.
   *
   * @param unit
   * @param territoryUnitsAreCurrentlyIn
   */
  public static int carrierCapacity(final Unit unit, final Territory territoryUnitsAreCurrentlyIn) {
<span class="fc bfc" id="L691" title="All 2 branches covered.">    if (Matches.UnitIsCarrier.match(unit)) {</span>
      // here we check to see if the unit can no longer carry units
<span class="pc bpc" id="L693" title="1 of 2 branches missed.">      if (Matches.UnitHasWhenCombatDamagedEffect(UnitAttachment.UNITSMAYNOTLANDONCARRIER).match(unit)) {</span>
        // and we must check to make sure we let any allied air that are cargo stay here
<span class="nc bnc" id="L695" title="All 2 branches missed.">        if (Matches.UnitHasWhenCombatDamagedEffect(UnitAttachment.UNITSMAYNOTLEAVEALLIEDCARRIER).match(unit)) {</span>
<span class="nc" id="L696">          int cargo = 0;</span>
<span class="nc" id="L697">          final Collection&lt;Unit&gt; airCargo = territoryUnitsAreCurrentlyIn.getUnits()</span>
<span class="nc" id="L698">              .getMatches(new CompositeMatchAnd&lt;&gt;(Matches.UnitIsAir, Matches.UnitCanLandOnCarrier));</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">          for (final Unit airUnit : airCargo) {</span>
<span class="nc" id="L700">            final TripleAUnit taUnit = (TripleAUnit) airUnit;</span>
<span class="nc bnc" id="L701" title="All 4 branches missed.">            if (taUnit.getTransportedBy() != null &amp;&amp; taUnit.getTransportedBy().equals(unit)) {</span>
              // capacity = are cargo only
<span class="nc" id="L703">              cargo += UnitAttachment.get(taUnit.getType()).getCarrierCost();</span>
            }
          }
<span class="nc" id="L706">          return cargo;</span>
        } else {
          // capacity = zero 0
<span class="nc" id="L709">          return 0;</span>
        }
      } else {
<span class="fc" id="L712">        final UnitAttachment ua = UnitAttachment.get(unit.getType());</span>
<span class="fc" id="L713">        return ua.getCarrierCapacity();</span>
      }
    }
<span class="fc" id="L716">    return 0;</span>
  }

  public static int carrierCost(final Collection&lt;Unit&gt; units) {
<span class="fc" id="L720">    int sum = 0;</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">    for (final Unit unit : units) {</span>
<span class="fc" id="L722">      sum += carrierCost(unit);</span>
    }
<span class="fc" id="L724">    return sum;</span>
  }

  public static int carrierCost(final Unit unit) {
<span class="fc bfc" id="L728" title="All 2 branches covered.">    if (Matches.UnitCanLandOnCarrier.match(unit)) {</span>
<span class="fc" id="L729">      return UnitAttachment.get(unit.getType()).getCarrierCost();</span>
    }
<span class="fc" id="L731">    return 0;</span>
  }

  private static boolean getEditMode(final GameData data) {
<span class="fc" id="L735">    return BaseEditDelegate.getEditMode(data);</span>
  }

  public static Collection&lt;Unit&gt; getFriendly(final Territory territory, final PlayerID player, final GameData data) {
<span class="fc" id="L739">    return territory.getUnits().getMatches(Matches.alliedUnit(player, data));</span>
  }

  private static boolean isKamikazeAircraft(final GameData data) {
<span class="fc" id="L743">    return games.strategy.triplea.Properties.getKamikaze_Airplanes(data);</span>
  }

  private static boolean areNeutralsPassableByAir(final GameData data) {
<span class="pc bpc" id="L747" title="3 of 4 branches missed.">    return (games.strategy.triplea.Properties.getNeutralFlyoverAllowed(data) &amp;&amp; !isNeutralsImpassable(data));</span>
  }

  private static boolean isNeutralsImpassable(final GameData data) {
<span class="nc" id="L751">    return games.strategy.triplea.Properties.getNeutralsImpassable(data);</span>
  }

  private static int getNeutralCharge(final GameData data, final Route route) {
<span class="nc" id="L755">    return getNeutralCharge(data, MoveDelegate.getEmptyNeutral(route).size());</span>
  }

  private static int getNeutralCharge(final GameData data, final int numberOfTerritories) {
<span class="nc" id="L759">    return numberOfTerritories * games.strategy.triplea.Properties.getNeutralCharge(data);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>test (25/nov/2016 10:16:58)</div></body></html>