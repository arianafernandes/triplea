## Introduction

The major goals of the software development’s life cycle and the project as a whole are the quality and consistency of the requirement elicitation. It´s all about preventing early misunderstood in the project that would otherwise lead to unnecessary expenses and a waste of time and resources due to the going back and forth in the project.
Requirements engineer (RE) is used to translate incomplete /imprecise needs or wishes of potential users and costumers into structured and realistic goals for the project.
The requirements can be divided in two main types:
Functional, if they represent a capability that the software must perform;
Nonfunctional, if they are more focused in the constrains of the solution;
Another taxonomy of the requirements is related to their level of application: business, user, system and software requirements.
The main goal of this assignment is to study the process of requirement elicitation in a specific project: TripleA. 

In the following sections, it will be presented the use cases and the requirements and features of TripleA. In the last section, it will be presented and discussed the domain model of the project.

## Description
Relying on a community willing to participate in improving TripleA, it would become very hard to manage the project without well-defined elicitation techniques. Notwithstanding, it’s obviously not mandatory for the stakeholders to participate in the requirement elicitation process, due to the "open source" development style of the project, it´s very natural to engage. 
There is a section explaining the details of all contributions and the levels that can be done, using a tag system. The issues can be divided in three groups: discussion, feature, bug, infra/code.
All the stakeholders can contribute on the process of requirements elicitation. This process involves a few steps: proposal, discussion inside the community, establish its priority and ,finally, the decision about the implementation. We can find some examples of this process here (link). 




## Use Cases

* Table

* Diagram

## Requirements and Features

* Functional Requirements

* Non-Functional Requirements

## Domain Model
